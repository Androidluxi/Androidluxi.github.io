<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>音视频基础知识</title>
    <link href="/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>音视频</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg交叉编译</title>
    <link href="/ffmpeg%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <url>/ffmpeg%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="什么是交叉编译？"><a href="#什么是交叉编译？" class="headerlink" title="什么是交叉编译？"></a>什么是交叉编译？</h2><p>‌<strong>交叉编译</strong>‌是指在一种平台上编译程序，使其能够在另一种不同的平台上运行的过程。这种编译方式主要用于开发嵌入式系统、移动设备和其他受限环境中的应用程序‌。</p><h3 id="交叉编译的基本概念"><a href="#交叉编译的基本概念" class="headerlink" title="交叉编译的基本概念"></a>交叉编译的基本概念</h3><ol><li>‌<strong>本地编译</strong>‌：在当前的平台上编译程序，生成的代码直接在当前平台上运行。例如，在x86架构的电脑上编译的程序直接在x86架构的电脑上运行‌。</li><li>‌<strong>交叉编译</strong>‌：在一种平台上编译程序，生成的代码在另一种平台上运行。例如，在x86架构的电脑上编译的程序在ARM架构的设备上运行‌。</li></ol><p><a href="https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/10916911">交叉编译百度百科</a></p><h3 id="交叉编译的平台"><a href="#交叉编译的平台" class="headerlink" title="交叉编译的平台"></a>交叉编译的平台</h3><p>在讨论交叉编译时，常见的平台通常指的是不同的硬件架构和操作系统组合。一般会是</p><p><strong>x86&#x2F;x86_64 (Intel&#x2F;AMD Architecture)</strong></p><ol><li><p>这是桌面和服务器领域最常用的架构。</p></li><li><p>支持的操作系统包括Windows、Linux、macOS等。</p></li></ol><p> <strong>ARM (Advanced RISC Machine)</strong></p><ol><li>广泛应用于移动设备如智能手机和平板电脑。</li><li>ARM架构有多种版本，如ARMv7（用于32位处理器）、ARMv8&#x2F;Aarch64（用于64位处理器）。</li></ol><p>这里我们主要关注在Android平台上的交叉编译，也就是<strong>ARM</strong>硬件平台，支持的子架构包括<code>armeabi-v7a</code>（32位）和<code>arm64-v8a</code>（64位）。<strong>x86</strong>: 主要用于一些平板电脑和模拟器中。<strong>x86_64</strong>: 类似于x86，但支持64位架构。</p><h2 id="交叉编译的准备工作"><a href="#交叉编译的准备工作" class="headerlink" title="交叉编译的准备工作"></a>交叉编译的准备工作</h2><p>要进行交叉编译，首先需要准备交叉编译工具链。</p><p><strong>交叉编译工具链</strong>是一组用于在一台机器（宿主机）上生成另一台不同架构或操作系统的机器（目标机）可执行文件的程序。这些工具通常包括编译器、汇编器、链接器和调试器等，它们都是针对特定的目标平台进行定制的。</p><p>在Android开发中，交叉编译工具链主要通过<strong>Android NDK (Native Development Kit)</strong> 提供。NDK允许开发者使用C或C++编写部分应用，并将其编译为适用于不同Android设备的原生代码。</p><p>NDK可以直接在Android Studio中Android Studio SDK Manager下载，也可以在<a href="https://developer.android.google.cn/ndk/downloads/?hl=zh-cn">官网</a>中下载，下载后解压到相应目录即可。</p><p>Android中的**编译器 (Compiler)**通常为GCC或者Clang，前者成熟度高，支持广泛，后者错误提示友好且性能较好。</p><p>但是在实际项目中，直接使用编译器命令进行编译往往不够灵活和高效，尤其是在处理大型项目时。这就引入了构建系统工具，比如<code>Makefile</code>以及更现代的<code>CMake</code>等，它们用于自动化和管理整个构建过程。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250508214545511.png"><h3 id="Makefile与编译器的关系"><a href="#Makefile与编译器的关系" class="headerlink" title="Makefile与编译器的关系"></a><code>Makefile</code>与编译器的关系</h3><ul><li><p>**<code>Makefile</code>**：是一种用于存储项目构建指令的特殊格式文件。它定义了一系列规则来告诉<code>make</code>工具如何编译和链接程序。通过编写<code>Makefile</code>，你可以指定哪些文件需要被编译、如何编译这些文件、以及它们之间如何相互依赖。这样做的好处是可以避免每次都手动输入长长的编译命令，并且只重新编译那些真正修改过的文件，从而节省时间。</p><p>使用<code>make</code>配合<code>Makefile</code>工作时，实际上是调用了底层的编译器（如GCC或Clang）来执行具体的编译任务。</p></li></ul><h3 id="CMake的角色及其与编译器的关系"><a href="#CMake的角色及其与编译器的关系" class="headerlink" title="CMake的角色及其与编译器的关系"></a><code>CMake</code>的角色及其与编译器的关系</h3><ul><li>**<code>CMake</code>**：是一个跨平台的开源构建系统生成器。不同于直接编写<code>Makefile</code>或使用<code>nmake</code>，<code>CMake</code>允许开发者通过编写高层级的配置脚本（<code>CMakeLists.txt</code>），然后根据不同的操作系统和编译器自动生成合适的本地构建文件（如<code>Makefile</code>、Visual Studio解决方案文件等）。这意味着无论你的目标平台是Linux、Windows还是macOS，都可以使用相同的<code>CMakeLists.txt</code>文件来管理和构建项目。<ul><li><strong>与编译器的关系</strong>：<code>CMake</code>本身并不执行编译；相反，它生成适合特定构建系统的配置文件（例如<code>Makefile</code>），然后调用相应的构建工具（如<code>make</code>或<code>nmake</code>）来完成编译过程。在这个过程中，<code>CMake</code>会根据你的配置选择合适的编译器（如GCC、Clang或MSVC）</li></ul></li></ul><h2 id="什么是FFmpeg"><a href="#什么是FFmpeg" class="headerlink" title="什么是FFmpeg"></a>什么是FFmpeg</h2><p><a href="https://baike.baidu.com/item/ffmpeg/2665727?fr=aladdinFFmpeg">FFmpeg百度百科的解释</a>是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。</p><p>它包含了非常先进的音频&#x2F;视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的FFmpeg在Linux平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括Windows、MacOS X等。这个项目最早由Fabrice Bellard发起，2004年至2015年间由Michael Niedermayer主要负责维护。许多FFmpeg的开发人员都来自MPlayer项目，而且当前FFmpeg也是放在MPlayer项目组的服务器上。项目的名称来自MPEG视频编码标准，前面的”FF”代表”Fast Forward”。</p><p>FFmpeg是一套可以用来记录、转换<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E9%9F%B3%E9%A2%91/5942163?fromModule=lemma_inlink">数字音频</a>、视频，并能将其转化为流的开源计算机<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/13831935?fromModule=lemma_inlink">程序</a>。它包括了领先的音&#x2F;视频编码库libavcodec等。</p><ol><li><strong>libavformat</strong>：用于各种音视频<a href="https://baike.baidu.com/item/%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F/7015654?fromModule=lemma_inlink">封装格式</a>的生成和解析，包括获取解码所需信息以生成解码<a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87/2884376?fromModule=lemma_inlink">上下文</a>结构和读取音视频帧等功能；</li><li><strong>libavcodec</strong>：用于各种类型声音&#x2F;图像编<a href="https://baike.baidu.com/item/%E8%A7%A3%E7%A0%81/10944752?fromModule=lemma_inlink">解码</a>；</li><li><strong>libavutil</strong>：包含一些公共的工具函数；</li><li><strong>libswscale</strong>：用于视频场景比例缩放、色彩映射转换；</li><li><strong>libpostproc</strong>：用于后期效果处理；</li><li><strong>ffmpeg</strong>：该项目提供的一个工具，可用于<a href="https://baike.baidu.com/item/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/55388491?fromModule=lemma_inlink">格式转换</a>、解码或<a href="https://baike.baidu.com/item/%E7%94%B5%E8%A7%86%E5%8D%A1/817994?fromModule=lemma_inlink">电视卡</a>即时编码等；</li><li><strong>ffsever</strong>：一个 HTTP 多媒体即时广播串流服务器；</li><li><strong>ffplay</strong>：是一个简单的播放器，使用ffmpeg 库解析和解码，通过<a href="https://baike.baidu.com/item/SDL/224181?fromModule=lemma_inlink">SDL</a>显示；</li></ol><p>总之，学习音视频开发，FFmpeg是绕不过去的坎。</p><h3 id="交叉编译FFmpeg库"><a href="#交叉编译FFmpeg库" class="headerlink" title="交叉编译FFmpeg库"></a>交叉编译FFmpeg库</h3><p><a href="https://www.ffmpeg.org/releases/">版本下载链接</a></p><p>交叉编译FFmpeg库是一件比较困难的事情，不同的FFmpeg版本和NDK版本，都会使编译指令存在细微差异。</p><p>我这里使用的<code>ffmpeg-4.0.2.tar.bz2</code>，NDK版本使用的是<code>android-ndk-r17c-linux-x86_64.zip</code>。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250508214545576.png"><p>在根目录下执行shell脚本命令，只需要修改里面的路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 首先定义一个NDK目录的变量 NDK_ROOT</span><br>NDK_ROOT=/home/lux/Android/ndk/android-ndk-r17c<br><br><br><span class="hljs-comment"># 此变量执行ndk中的交叉编译gcc所在目录  32位 </span><br><span class="hljs-comment">#TOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><br><span class="hljs-comment">#此变量执行ndk中的交叉编译gcc所在目录  64位</span><br>TOOLCHAIN=<span class="hljs-variable">$NDK_ROOT</span>/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64<br><br><span class="hljs-comment">#从as的 externalNativeBuild/xxx/build.ninja，  反正下面的配置，可以压制警告的意思   32位 </span><br><span class="hljs-comment">#FLAGS=&quot;-isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC&quot;</span><br><span class="hljs-comment">#INCLUDES=&quot; -isystem $NDK_ROOT/sources/android/support/include&quot;</span><br><br><span class="hljs-comment"># 设置编译标志，适配aarch64架构</span><br>FLAGS=<span class="hljs-string">&quot;-isystem <span class="hljs-variable">$NDK_ROOT</span>/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -O0 -fPIC&quot;</span><br>INCLUDES=<span class="hljs-string">&quot; -isystem <span class="hljs-variable">$NDK_ROOT</span>/sources/android/support/include&quot;</span><br><br><span class="hljs-comment"># 1.定义编译后，所存放的目录</span><br>PREFIX=./android/arm<br><br><span class="hljs-comment"># 2.--enable-small 优化大小 非常重要，必须优化才行的哦</span><br><span class="hljs-comment"># 3.--disable-programs 不编译ffmpeg程序（命令行工具），我们是需要获取静态、动态库</span><br><span class="hljs-comment"># 4.--disable-avdevice 关闭avdevice模块，此模块在android中无用</span><br><span class="hljs-comment"># 5.--disable-encoders 关闭所有编码器（播放不需要编码）</span><br><span class="hljs-comment"># 6.--disable-muxers 关闭所有复用器（封装器），不需要生成mp4这样的文件，所有关闭</span><br><span class="hljs-comment"># 7.--disable-filters 关闭所有滤镜</span><br><span class="hljs-comment"># 8.--enable-cross-compile 开启交叉编译（ffmpeg是跨平台的，注意：并不是所有库都有这么happy的选项）</span><br><span class="hljs-comment"># 9.--cross-prefix 看右边的值就知道是干嘛的，gcc的前缀..</span><br><span class="hljs-comment"># 10.disable-shared / enable-static 这个不写也可以，默认就是这样的，（代表关闭动态库，开启静态库）</span><br><span class="hljs-comment"># 11.--sysroot</span><br><span class="hljs-comment"># 12.--extra-cflags 会传给gcc的参数</span><br><span class="hljs-comment"># 13.--arch  --target-os</span><br><br><span class="hljs-comment">#./configure \</span><br><span class="hljs-comment">#--prefix=$PREFIX \</span><br><span class="hljs-comment">#--enable-small \</span><br><span class="hljs-comment">#--disable-programs \</span><br><span class="hljs-comment">#--disable-avdevice \</span><br><span class="hljs-comment">#--disable-encoders \</span><br><span class="hljs-comment">#--disable-muxers \</span><br><span class="hljs-comment">#--disable-filters \</span><br><span class="hljs-comment">#--enable-cross-compile \</span><br><span class="hljs-comment">#--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \</span><br><span class="hljs-comment">#--disable-shared \</span><br><span class="hljs-comment">#--enable-static \</span><br><span class="hljs-comment">#--sysroot=$NDK_ROOT/platforms/android-21/arch-arm \</span><br><span class="hljs-comment">#--extra-cflags=&quot;$FLAGS $INCLUDES&quot; \</span><br><span class="hljs-comment">#--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot/&quot; \</span><br><span class="hljs-comment">#--arch=arm \</span><br><span class="hljs-comment">#--target-os=android</span><br><br><br><span class="hljs-comment"># 配置并编译FFmpeg</span><br>./configure \<br>--prefix=<span class="hljs-variable">$PREFIX</span> \<br>--enable-small \<br>--disable-programs \<br>--disable-avdevice \<br>--disable-encoders \<br>--disable-muxers \<br>--disable-filters \<br>--enable-cross-compile \<br>--cross-prefix=<span class="hljs-variable">$TOOLCHAIN</span>/bin/aarch64-linux-android- \<br>--disable-shared \<br>--enable-static \<br>--sysroot=<span class="hljs-variable">$NDK_ROOT</span>/platforms/android-21/arch-arm64 \<br>--extra-cflags=<span class="hljs-string">&quot;<span class="hljs-variable">$FLAGS</span> <span class="hljs-variable">$INCLUDES</span>&quot;</span> \<br>--extra-cflags=<span class="hljs-string">&quot;-isysroot <span class="hljs-variable">$NDK_ROOT</span>/sysroot/&quot;</span> \<br>--<span class="hljs-built_in">arch</span>=aarch64 \<br>--target-os=android<br><br>make clean<br>make install<br></code></pre></td></tr></table></figure><p>对于FFmpeg的功能开启的一些的帮助选项，可以通过<code>./configure --help</code>查看：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs text">~/code/ffmpeg-4.0.2 git:[master]<br>./configure --help<br>Usage: configure [options]<br>Options: [defaults in brackets after descriptions]<br><br>Help options:<br>  --help                   print this message<br>  --quiet                  Suppress showing informative output   抑制显示信息性输出，使得输出更加简洁。<br>  --list-decoders          --list-decoders: 列出所有可用的解码器。<br>  --list-encoders:         列出所有可用的编码器。<br>  --list-hwaccels:         列出所有可用的硬件加速器。<br>  --list-demuxers:         列出所有可用的解复用器（用于解析多媒体文件格式）。<br>  --list-muxers:           列出所有可用的复用器（用于封装多媒体文件格式）。<br>  --list-parsers:          列出所有可用的解析器（用于处理多媒体流中的数据包）。<br>  --list-protocols:        列出所有可用的协议（支持的网络协议或文件访问方法）。<br>  --list-bsfs:             列出所有可用的比特流过滤器（用于修改编码比特流）。<br>  --list-indevs:           列出所有可用的输入设备（如摄像头、音频输入等）。<br>  --list-outdevs:          列出所有可用的输出设备（如屏幕、音频输出等）。<br>  --list-filters:          列出所有可用的滤镜（用于视频和音频的处理和效果添加）。<br>  --list-encoders          show all available encoders<br>  --list-hwaccels          show all available hardware accelerators<br>  --list-demuxers          show all available demuxers<br>  --list-muxers            show all available muxers<br>  --list-parsers           show all available parsers<br>  --list-protocols         show all available protocols<br>  --list-bsfs              show all available bitstream filters<br>  --list-indevs            show all available input devices<br>  --list-outdevs           show all available output devices<br>  --list-filters           show all available filters<br><br>Standard options:<br>  --logfile=FILE           log tests and output to FILE [ffbuild/config.log]<br>  --disable-logging        do not log configure debug information<br>  --fatal-warnings         fail if any configure warning is generated<br>  --prefix=PREFIX          install in PREFIX [/usr/local]<br>  --bindir=DIR             install binaries in DIR [PREFIX/bin]<br>  --datadir=DIR            install data files in DIR [PREFIX/share/ffmpeg]<br>  --docdir=DIR             install documentation in DIR [PREFIX/share/doc/ffmpeg]<br>  ......<br>  ......<br>  ......<br></code></pre></td></tr></table></figure><p>编译成功后的静态文件</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250508214545546.png"><h3 id="集成到Android"><a href="#集成到Android" class="headerlink" title="集成到Android"></a>集成到Android</h3><p>在现代的Android Studio中会默认使用cmake去管理C&#x2F;C++源码的交叉编译。</p><p><strong>CMakeLists.txt</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>.<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">project</span>(<span class="hljs-string">&quot;demo2&quot;</span>)<br><br><br><span class="hljs-comment"># 引入FFmpeg的头文件</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><br><span class="hljs-comment"># 设置库路径时避免重复路径</span><br><span class="hljs-keyword">set</span>(LIB_PATH <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;ANDROID_ABI&#125;</span>)<br><br><br><span class="hljs-comment"># 链接目录设置为FFmpeg库所在的目录</span><br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;LIB_PATH&#125;</span>)<br><br><br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> SHARED<br>        <span class="hljs-comment"># List C/C++ source files with relative paths to this CMakeLists.txt.</span><br>        native-lib.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;CMAKE_PROJECT_NAME&#125;</span><br>        <span class="hljs-variable">$&#123;LIB_PATH&#125;</span>/libavutil.a<br>        <span class="hljs-variable">$&#123;LIB_PATH&#125;</span>/libavfilter.a<br>        <span class="hljs-variable">$&#123;LIB_PATH&#125;</span>/libavformat.a<br>        <span class="hljs-variable">$&#123;LIB_PATH&#125;</span>/libswresample.a<br>        <span class="hljs-variable">$&#123;LIB_PATH&#125;</span>/libswscale.a<br>        <span class="hljs-variable">$&#123;LIB_PATH&#125;</span>/libavcodec.a<br>        android<br>        log)<br></code></pre></td></tr></table></figure><p>在<strong>native-lib.cpp</strong>中可以简单打印FFmpeg的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libavutil/avutil.h&quot;</span></span><br>&#125;<br><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_example_demo2_MainActivity_stringFromJNI</span><span class="hljs-params">(JNIEnv *env, jobject thiz)</span> </span>&#123;<br>    std::string hello = <span class="hljs-string">&quot;当前的FFmpeg的版本是：&quot;</span>;<br>    hello.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">av_version_info</span>());<br>    <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(hello.<span class="hljs-built_in">c_str</span>());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的控制</title>
    <link href="/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6/"/>
    <url>/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h3><p>在上面提到，Linux在内核层面没有专门为线程设计一套系统调用接口，但是在应用层为用户提供了一套原生线程库。</p><p><code>pthread</code>线程库就是应用层的原生线程库：</p><ul><li>应用层指的是这个线程库并不是系统接口直接提供的，而是由第三方帮我们提供的</li><li>原生指的是大部分Linux系统都会默认带上该线程库</li><li>与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以”<code>pthread_</code>“打头的</li><li>要使用这些函数库，需要包含头文件<code>pthread.h</code></li><li>链接这些线程函数库时，要使用编译器的”<code>-lpthread</code>“选项</li></ul><p>错误检查：</p><ul><li>传统的一个函数是，成功返回0，错误返回-1，并且对全局变量<code>errno</code>赋值以指示错误</li><li>但是<code>pthreads</code>函数出错时并不会设置<code>errno</code>，而是将错误代码通过返回值返回</li><li><code>pthreads</code>同样也提供了线程内的<code>errno</code>变量，以支持其他使用<code>errno</code>的代码。对于<code>pthreads</code>函数的错误，建议通过返回值来判定，因为读取返回值要比读取线程内的<code>errno</code>变量开销更小。</li></ul><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p><strong>创建线程的函数为pthread_create</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的线程</title>
    <link href="/Linux%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/Linux%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><ul><li>在一个程序里的一个执行路线就叫做线程。更准确的定义是：线程是“一个进程内部的控制序列”</li><li>一切进程都至少有一个执行线程</li><li>线程在进程内部运行，本质是在进程地址空间内运行</li><li>在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更轻量化</li><li>透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流</li></ul><p>进程的创建伴随着<a href="https://so.csdn.net/so/search?q=%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97&spm=1001.2101.3001.7020">进程控制块</a>，进程地址空间以及页表的创建，虚拟地址和物理地址就是通过页表建立映射的。<br>但是如果我们在创建“进程”时，只创建<strong>task_struct</strong>，并要求创建出来的<strong>task_struct</strong>和父<strong>task_struct</strong>共享进程地址空间和页表，那么创建的结果就是这样的</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/进程空间.png"><p>此时我们创建的实际上就是四个线程：</p><p>其中每一个线程都是当前进程里面的一个执行流，也就是我们说的“线程是进程内部的一个执行分支”。<br>同时我们也可以看出，线程在进程内部运行，本质就是线程在进程地址空间内运行，也就是说曾经这个进程申请的所有资源，几乎都是被所有线程共享的。<br>注意：单纯从技术角度，这个是一定能实现的，因为它比创建一个原始进程所做的工作更加轻量化了。</p><p><font color="red" size="5">该如何理解之前的进程？</font></p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/进程空间2.png"><p>所谓的进程并不是通过<strong>task_struct</strong>来衡量的，除了<strong>task_struct</strong>之外，一个进程还要有进程地址空间，文件，信号等等，合起来称为一个进程。<br>如果我们站在内核角度来看，承担分配系统资源的基本实体，叫做进程。<br>换言之，当我们创建进程时是创建一个<strong>task_struct</strong>，创建地址空间，维护页表，然后在物理内存当中开辟空间，构建映射，打开进程默认打开的相关文件，注册信号对应的处理方案等等。<br>而我们之前接触到的进程都只有一个<strong>task_struct</strong>，也就是该进程内部只有一个执行流，即单执行流进程，反之，内部有多个执行流的进程叫做多执行流进程。<br><font color="red" size="5">在Linux中，站在CPU的角度，能否识别当前调度的task_struct是进程还是线程？</font></p><p><font color="green">不能！也不需要。</font>CPU只关心一个一个的独立执行流。无论进程内部只有一个执行流还是有多个执行流，CPU都是以task_struct为单位进行调度的。</p><p>单执行流进程被调度：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/单执行流-进程.png"><p>多执行流进程被调度：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/多执行流进程.png"><p><strong>Linux并不存在真正的线程，Linux中的线程是用进程模拟的！</strong></p><p>操作系统中存在大量的进程，一个进程内又存在一个或多个线程，因此线程的数量一定比进程的数量多，当线程的数量足够多的时候，很明显线程的执行粒度要比进程更细。</p><p>如果一款操作系统要支持线程，那么就需要对这些线程进行管理，比如线程创建，线程调度，线程切换，线程资源分配，线程资源释放及回收等等，这些操作相比于进程都需要另起炉灶，搭建一套比进程平行的线程管理模块。</p><p>因此，如果要支持线程一定会提高操作系统设计的复杂程度。但是在Linux看来，描述进程的控制块和描述线程的控制块是很类似的，于是Linux就没有重新为线程设计管理模块，而是直接复用了进程控制块，所以我们可以说Linux中的线程也叫做轻量级进程。</p><p>也有真的为线程设计控制块的操作系统，比如Window操作系统，因此Windows操作系统的实现逻辑一定比Linux的实现逻辑要复杂的多。</p><p><strong>既然在Linux中没有真正的线程，那么也就没有真正与线程相关的系统调用！</strong></p><p>Linux中都没有真正意义上的线程了，自然也就没有真正意义上的与线程相关的系统调用了。但是Linux提供了创建轻量级进程的接口，也就是创建进程，共享空间，比如vfork函数。</p><p><strong>vfork可以创建子进程，但是父子共享进程地址空间。</strong></p><p>相对于vfork，可能我们更加熟悉fork函数。</p><p>​<strong>vfork</strong>的返回值与<strong>fork</strong>函数返回值相同，都是给父进程返回子进程PID，给子进程返回0。</p><p>​复制父进程：<strong>fork</strong> 创建的子进程会获得父进程数据段、堆栈段以及代码段的副本。</p><p>​资源共享：虽然文件描述符等资源会在父子进程间共享，但内存空间是独立的。这意味着对内存的任何修改在父进程中不可见，在子进程中则是独立的。</p><p>下面我们可以对比一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> g_val_1 = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> g_val_2 = <span class="hljs-number">100</span>;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> id1 = fork();<br>    <span class="hljs-keyword">if</span> (id1 == <span class="hljs-number">0</span>)<br>    &#123;<br>        g_val_1 = <span class="hljs-number">200</span>;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 使用vfork创建一个子进程</span><br>    <span class="hljs-comment">// vfork()函数与fork()类似，但创建的子进程只能执行exec或exit函数</span><br>    <span class="hljs-comment">// 子进程不会生成独立的地址空间，会与父进程共享地址空间</span><br>    <span class="hljs-type">pid_t</span> id2 = vfork();<br>    <span class="hljs-keyword">if</span> (id2 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 这里的修改会影响到父进程，因为子进程与父进程共享地址空间</span><br>        g_val_2 = <span class="hljs-number">300</span>;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    sleep(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_val: %d\n&quot;</span>, g_val_1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_val: %d\n&quot;</span>, g_val_2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">g_val: 100<br>g_val: 300<br></code></pre></td></tr></table></figure><p>Linux中，在内核角度没有真正意义上与线程有关的接口，但是站在用户角度，系统为用户封装并提供了原生线程库pthread。</p><p><code>pthread</code>库其实就是对轻量级进程的系统调用进行了封装，在用户层模拟实现了一套线程相关的接口。</p><p>因此对于我们来讲，我们要在Linux下学习线程实际上就是学习用户层的这一套接口，而非操作系统的接口。</p><h3 id="pthread-库"><a href="#pthread-库" class="headerlink" title="pthread 库"></a>pthread 库</h3><p>全称为POSIX线程（POSIX Threads），是用于多线程编程的一个标准接口集，旨在提供一种跨不同操作系统平台的可移植方式来编写并发程序。</p><p>POSIX（Portable Operating System Interface，可移植操作系统接口）是一个由IEEE制定的标准集合，旨在促进软件在不同Unix系统间的兼容性和可移植性。随着其发展，POSIX标准也被广泛应用于类Unix系统之外的操作系统上，包括许多版本的Linux、macOS，甚至一些实时操作系统和微软Windows上的某些子系统。</p><p><strong>POSIX标准的重要性</strong></p><ul><li><p>提高软件的可移植性：通过遵循POSIX标准，开发人员可以编写能够在多个操作系统上运行的应用程序，只需少量或无需修改代码。</p></li><li><p>促进互操作性：POSIX定义了API和shell及工具的行为，使得不同的操作系统能够以一致的方式进行交互。</p></li><li><p>支持多线程编程：POSIX线程（pthread）提供了一种标准化的多线程编程接口，增强了程序并发处理能力。</p></li></ul><p>POSIX标准涵盖了很多方面，主要包括但不限于：</p><ul><li>系统接口：定义了操作系统提供的基本服务，如文件I&#x2F;O、进程控制、信号处理等。</li><li>C库函数：包括标准输入输出、字符串操作、数学计算等基础函数。</li><li>Shell和工具：规定了命令行解释器（Shell）以及一系列常用命令的行为。</li><li>线程管理：提供了创建、同步、调度线程的机制，即pthread库。</li><li>网络编程：涵盖了套接字编程接口，允许程序之间通过网络进行通信。</li></ul><h3 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h3><ul><li><p>创建一个新线程的代价比创建一个新进程小得多</p></li><li><p>与进程之间的切换相比，线程之间的切换需要操作系统做的工作更少</p></li><li><p>线程占用的资源比进程少很多</p></li><li><p>能充分利用多处理器的可并行数量</p></li><li><p>在等待慢速IO操作结束的同时，程序可以执行其他的计算任务</p></li><li><p>计算密集型应用，为了能在多处理器上运行，将计算分解到多个线程中实现</p></li><li><p>IO密集型应用，为了提高性能，将IO操作重叠，线程可以同时等待不同的IO操作</p></li></ul><h3 id="线程的缺点"><a href="#线程的缺点" class="headerlink" title="线程的缺点"></a>线程的缺点</h3><ul><li><p>性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与其他线程共享一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能有较大的能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。</p></li><li><p>健壮性降低：编写多线程需要更全面深入的考虑，在一个多线程程序里，因时间分配上的细微差别或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说，线程之间是缺乏保护的。</p></li><li><p>缺乏访问控制：进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</p></li><li><p>编程难度提高：编写与调试一个多线程程序比单线程程度困难得多。</p></li></ul><h3 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h3><ul><li>单个线程如果出现除0，野指针等问题导致线程崩溃，进程也会随着崩溃。</li><li>线程是进程的执行分支，线程出现异常，就类似进程出现异常，会除法信号机制，终止进程，进程终止之后该进程内所有线程也会随即退出。</li></ul><h3 id="线程用途"><a href="#线程用途" class="headerlink" title="线程用途"></a>线程用途</h3><ul><li>合理地使用多线程，能提高CPU密集型程序的执行效率。</li><li>合理地使用多线程，能提高IO密集型程序的用户体验。</li></ul><h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p><strong>以32位平台为例，在32位平台下一共有2^32个地址，也就意味着需要有2^32个地址需要被映射</strong></p><p>如果我们所谓的页表就是单纯的一张表，那么这张表就需要建议2^32个<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80&spm=1001.2101.3001.7020">虚拟地址</a>与物理地址之间的映射关系，即这张表要有2^32个映射项。且每一个表项中除了要有虚拟地址与其映射的物理地址之外，实际上还需要有一些权限信息，比如我们所说的用户级页表和内核级页表，实际就是通过权限进行区分的。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/二级页表.png"><p>每个页表中存储一个物理地址和一个虚拟地址就需要8个字节，考虑到还需要包含权限相关的各种信息，这里每一个表项就按10个字节计算。这里一共有232个表项，也就意味着存储这张页表我们需要用232 * 10个字节，也就是40GB。而在32位平台下我们的内存可能一共就只有4GB，也就是说我们根本无法存储这样一张页表。</p><p><strong>因此所谓的页表就不是单纯的一张表</strong></p><p>还是以32位平台为例，其页表的映射如下：</p><ol><li><p>选择虚拟地址的前10个比特位在页目录下进行查找，找到对应的页表</p></li><li><p>再选择虚拟地址的10个比特位在对应的页表当中进行查找，找到物理内存中对应页框的起始地址</p></li><li><p>最后将虚拟地址中剩下的12个比特位作为偏移量从对应页框的起始地址处向后偏移，找到物理内存中某一个对应的字节数据</p></li></ol><p>相关说明：</p><ol><li>物理内存实际是被划分成一个个4KB大小的页框的，而磁盘上的程序也是被划分成一个个4KB大小的页帧的，当内存和磁盘进行数据交换时就是以4KB为单位进行加载和保存的。</li><li>4KB实际上就是2^12个字节，也就是说一个页框中有2^12个字节，而访问内存的基本大小是1字节，因此一个页框中就有2^12个地址，于是我们就可以将剩下的12个比特位作为偏移量，从页框的起始地址处开始向后进行便宜，从而找到物理内存中某一个对应字节数据。</li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250413151221177.png"><p>这实际上就是我们所谓的二级页表，其中页目录项是一级页表，页表项是二级页表。</p><p>每一个表项还是按10字节计算，页目录和页表的表项都是2^10个，因此一个表的大小就是2^10 * 10个字节，也就是10KB。而页目录有2^10个表项也就意味着页表有2^10个，也就是说一级页表有1张，二级页表有2^10张，总共算下来就是10MB，内存消耗并不高，Linux实际上就是这样映射的。</p><p>上面所说的所有映射过程，都是由MMU这个硬件完成的，该硬件是集成在CPU内的。页表是一种软件映射，MMU是一种硬件映射，所以计算机进行虚拟地址到物理地址的转化采用的是软硬件结合的方式。</p><p>注意：在Linux中，32位平台下用的是二级页表，64位平台下采用的是多级页表。</p><p><font color="red">修改常量字符串为什么会触发段错误？</font></p><p>当我们要修改一个字符串常量时，虚拟地址必须经过页表映射找到对应的物理内存，而在查表过程中发现其权限是只读的，此时你要对其进行修改就会在MMU内部触发硬件错误，操作系统在识别到是哪一个进程导致的之后，就会给该进程发送的信号对其进行终止。</p><h3 id="线程与进程对比"><a href="#线程与进程对比" class="headerlink" title="线程与进程对比"></a>线程与进程对比</h3><p>进程是承担分配系统资源的基本实体，线程是调度的基本单位。</p><p>线程共享进程数据，但也拥有自己的一部分数据：</p><ul><li>线程ID</li><li>一组寄存器</li><li>栈空间</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><p>同一进程的线程共享一些资源：</p><p>因为是在同一个地址空间，因此所谓的代码段（Text Segment），数据段（Data Segment）都是共享的：</p><ul><li>如果定义一个函数，在各线程中都可以使用</li><li>如果定义一个全局变量，在各线程中都可以访问到</li></ul><p>除此之外，各线程还共享以下进程资源和环境：</p><ul><li>文件描述符表（进程打开一个文件后，其他进程也能看到）</li><li>每种信号的处理方式（SIG_IGN，SIG_DFL或者自定义的信号处理函数）</li><li>当前工作目录</li><li>用户ID</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="第四章-操作系统"><a href="#第四章-操作系统" class="headerlink" title="第四章 操作系统"></a>第四章 操作系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>计算机系统由两部分组成：</p><ul><li><strong>硬件</strong></li><li><strong>软件</strong></li></ul><p>通常把未配置软件的计算机称为裸机。</p><p>操作系统目的是：为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。</p><p>操作系统也包括了系统软件。</p><p>操作系统在计算机系统中的地位：</p><div style="text-align: center;">    <img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/操作系统.png" alt="操作系统" style="max-width: 100%; height:auto;"></div><p>操作系统是用户与计算机之间的接口，它在计算机系统中占据重要而特殊的地位，所有其他软件，如编辑程序、汇编程序、编译程序、数据库管理系统等系统软件，以及大量的应用软件都是建立在操作系统基础上的，并得到它的支持和取得它的服务。</p><h3 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h3><p>程序顺序执行时的主要特征包括：顺序性、封闭性和可再现性。</p><p>程序并发执行时的主要特征包括：失去了程序的封闭性、程序和机器的执行程序的活动不再一一对应、并发程序之间的相互制约性。</p><h3 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h3><p>在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化，因此进程一般有3种基本状态：运行、就绪和阻塞。</p><ul><li><strong>运行</strong>：当一个进程在处理机上运行时。</li><li><strong>就绪</strong>：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行（还未得到）。</li><li><strong>阻塞</strong>（等待或睡眠）：一个进程正在等待某一事件发生而暂时停止运行，这时即使把处理机分配给进程也无法运行。</li></ul><div style="text-align: center;">    <img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/状态图.png" alt="操作系统" style="max-width: 100%; height:auto;"></div><table><thead><tr><th align="center">进程</th><th align="center">CPU</th><th align="center">资源</th></tr></thead><tbody><tr><td align="center">运行</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">就绪</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">阻塞</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h3 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h3><p>在多道程序环境的系统中存在多个可以并发执行的进程，故进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程。</p><h4 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h4><ul><li><p><strong>同步</strong>：合作进程间的直接制约问题。</p><p>进程间的同步：是指在系统中一些需要相互合作，协同工作的进程，这样的相互联系称为进程的同步。</p><p>例如，进程A向缓冲区送数据，进程B从缓冲区取数据加工，当进程B要取数据加工时，必须是进程A完成了向缓冲区送数据的操作，否则进程B必须停下来等待进程A的操作结束。</p></li><li><p><strong>互斥</strong>：申请临界资源进程间的间接制约问题。</p><p>进程间的互斥：是指系统中多个进程因争用临界资源而互斥执行。</p><blockquote><p>临界资源：在多道程序系统环境中，那些一次只能供一个进程使用的资源。如打印机、共享变量和表格等。</p></blockquote></li></ul><p>临界区管理的原则：</p><blockquote><p>临界区：是进程中对临界资源实施操作的那段程序。</p></blockquote><p>对互斥临界区管理的4条原则如下：</p><ul><li><strong>有空即进</strong>：当无进程处于临界区时，允许进程进入临界区，并且只能在临界区运行有限 的时间。</li><li><strong>无空则等</strong>：当有一个进程在临界区时，其他欲进入临界区的进程必须等待，以保证进程互斥地访问临界资源。</li><li><strong>有限等待</strong>：对于要求访问临界资源的进程，应保证进程能在有限的时间进入临界区，以免陷入“<strong>饥饿</strong>”状态。</li><li><strong>让权等待</strong>：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入<strong>忙等</strong>状态</li></ul><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量机制是一种有效的进程同步与互斥工具。</p><p>信号量机制主要有：</p><ul><li>整型信号量</li><li>记录型信号量</li><li>信号量集机制</li></ul><p>整型信号量：</p><p>信号量是一个整型变量，根据控制对象的不同被赋予不同的值。信号量分为如下两类：</p><ul><li>公用信号量：实现进程间的互斥，初值为<code>1</code>或资源的数目。</li><li>私用信号量：实现进程间的同步，初值为<code>0</code>或某个正整数。</li></ul><p>信号量 S 的物理意义：</p><ul><li>S ≥ 0：表示某资源的可用数，此时<strong>有可用资源</strong>；</li><li>S＜0：则其绝对值表示阻塞队列中等待该资源的进程数，此时无可用资源，并且有进程被阻塞。</li></ul><h4 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h4><p>PV操作：实现<strong>进程同步与互斥</strong>的常用方法。</p><p>P操作和V操作是低级通信原语，在执行期间不可分割。其中：</p><ul><li><p><strong>P操作</strong>（减）：表示<strong>申请</strong>一个资源；</p><p>定义：S :&#x3D; S−1（S表示信号量）</p><ul><li>S ≥ 0：执行P操作的进程继续执行；</li><li>S＜0：无可用资源，置该进程为<strong>阻塞</strong>状态，并将其插入阻塞队列。</li></ul></li><li><p><strong>V操作</strong>（加）：表示<strong>释放</strong>一个资源。</p><p>定义：S :&#x3D; S+1</p><ul><li>S ≥ 0：执行V操作的进程继续执行；</li><li>S＜0：表示释放前有程序被阻塞，从阻塞状态唤醒一个进程，并将其插入就绪队列，然后执行V操作的进程继续。</li></ul></li></ul><blockquote><p>P减V加，P进V出。</p></blockquote><p><strong>利用PV操作实现进程的互斥：</strong></p><ol><li>令信号量<code>mutex</code>的初始值为1；</li><li>进入临界区：执行P操作；</li><li>推出临界区：执行V操作。</li></ol><p><strong>利用PV操作实现进程的同步：</strong></p><p>实现进程的同步可用一个信号量与消息联系起来。</p><p>信号量的值：</p><ul><li>为<code>0</code>：表示希望的消息未产生；</li><li>非<code>0</code>：表示希望的消息已经存在。</li></ul><p>假定信号量S表示某条消息，进程可以：</p><ul><li>调用P操作：测试消息是否到达；</li><li>调用V操作：通知消息已经准备好。</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>当有 n 个进程，m个资源，且每个进程所需要的资源数为k，并且系统采用的分配策略是轮流地为每个进程分配资源时，判断是否发生死锁的公式如下：<br>$$<br>m &gt;&#x3D; n * (k-1)+1<br>$$<br>死锁的处理策略主要有4种：鸵鸟策略（即不理睬策略）、预防策略、<strong>避免策略</strong>和检测与解除死锁。</p><h4 id="进程资源图"><a href="#进程资源图" class="headerlink" title="进程资源图"></a>进程资源图</h4><p>做题方法：先分配，再申请</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>传统进程有两个基本属性：</p><ul><li>可拥有资源的独立单位；</li><li>可独立调度和分配的基本单位。</li></ul></blockquote><p>引入线程的原因是，进程的系统必须付出较大的时空开销。引入线程后，将传统进程的两个基本属性分开：</p><ul><li>线程：作为调度和分配的基本单位；</li><li>进程：作为独立分配资源的单位。</li></ul><p>线程是进程中的一个实体，是被系统独立分配和调度的基本单位。</p><p>线程的特点：</p><ul><li>线程基本上不拥有资源，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈），它可与同属一个进程的其他线程共享进程所拥有的全部资源。</li><li>线程也具有就绪、运行和阻塞3种基本状态。</li><li>线程可创建另一个线程。</li><li>同一个进程中的多个线程可并发执行。</li></ul><p>线程因其具有许多传统进程所具有的特性，故称为”轻型进程”；而传统进程称为”重型进程”。</p><p>线程分为：</p><ul><li>用户级线程（User-Level Threads）：不依赖于内核，该类线程的创建、撤销和切换都不利用系统调用来实现；</li><li>内核支持线程（Kernel-Supported Threads）：依赖于内核，即无论是在用户进程中的线程，还是在系统中的线程，它们的创建、撤销和切换都利用系统调用来实现。</li></ul><p>某些系统同时实现了两种类型的线程。</p><blockquote><p>与线程不同的是，不论是系统进程还是用户进程，在进行切换时，都要依赖于内核中的进程调度。因此，不论是什么进程都是与内核有关的，是在内核支持下进行切换的。</p></blockquote><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><p>程序在执行时将呈现出局部性规律，即在一段时间内，程序的执行仅局限于某个部分。相应地，它所访问的存储空间也局限于某个区域内。</p><p>程序的局限性表现在以下两个方面：</p><ul><li><p><strong>时间局限性</strong>：</p><ul><li>如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；</li><li>如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。</li></ul><p>产生时间局限性的典型原因是在程序中存在着<strong>大量的循环操作</strong>。</p></li><li><p><strong>空间局限性</strong>：指一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。</p><p>即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型原因为<strong>程序是顺序执行</strong>。</p></li></ul><h4 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h4><p>分页原理：</p><ul><li><strong>页</strong>：将一个进程的地址空间划分成若干个大小相等的区域，称为页。</li><li><strong>块</strong>（<strong>页框</strong>）：将主存空间划分成与页相同大小的若干个物理块，称为块或页框。</li></ul><p>在为进程分配主存时，将进程中若干页分别装入多个不相邻接的块中。</p><p>地址结构：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250411010229136.png"><p>其中，页内地址是同一页（页号）中的偏移量。</p><p>分页的过程是由操作系统完成的，对用户是透明的，所以用户不必关心分页的过程，其优点是能有效地提高主存利用率，其缺点是不易实现共享。</p><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><p>结合分页和分段存储管理方式，形成一种新的存储管理方式，即段页式存储管理。段页式系统有两种系统的优点。</p><p>段页式系统的基本原理是：</p><ol><li>将整个主存划分成大小相等的存储块（页框）。</li><li>将用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名。</li><li>将每个段划分成若干页，以页框为单位离散分配。</li></ol><p>段页式地址空间的结构：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250411010229363.png"><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><h4 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h4><p>缓冲技术可提高外设利用率，尽可能使外设处于忙状态。缓冲技术可以采用两种方式：</p><ul><li>硬件缓冲：利用专门的硬件寄存器作为缓冲；</li><li>软件缓冲：通过操作系统来管理的。</li></ul><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>单缓冲工作过程图：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250411010229304.png"><p>当第1块数据送入用户工作区后（进行数据处理），缓冲区是空闲的，可以传送第2块数据（输入）。即第1块数据的处理C1与第2块数据的输入T2是可以并行的，以此类推：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250411010229188.png">$$（前提是c要小于T）计算公式为：（T + M）* n + c$$<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><ul><li><p><strong>先来先服务</strong>（FCFS）：根据进程请求访问<strong>磁盘的先后次序</strong>进行调度。</p><ul><li>优点：公平、简单，且每个进程的请求都能依次得到处理，不会出现某进程的请求长期得不到满足的情况。</li><li>缺点：此算法由于未对寻道进行优化，致使平均寻道时间可能较长。</li></ul></li><li><p><strong>最短寻道时间优先</strong>（SSTF，最短移臂算法）：该算法选择这样的进程，其要求访问的磁道与<strong>当前磁头所在的磁道距离最近</strong>，使得每次的寻道时间最短。</p><ul><li>优点：可能会出现饥饿现象。</li><li>缺点：不能保证平均寻道时间最短。</li></ul></li><li><p><strong>扫描算法</strong>（SCAN，电梯调度算法）：总是从磁头当前位置开始，沿磁头的移动方向去<strong>选择离当前磁头最近</strong>的那个柱面的请求。如果沿磁头的方向无请求访问时，就改变磁头的移动方向。</p><p>在这种调度方法下磁头的移动类似于电梯的调度，所以它也称为电梯调度算法。</p><ul><li>优点：避免了饥饿现象的出现。</li><li>缺点：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，再从外向里扫描完所有要访问的磁道后才处理该进程的请求，致使该进程的请求被严重地推迟。</li></ul></li><li><p><strong>单向扫描算法</strong>（CSCAN，循环扫描算法）：为了减少上述SCAN缺点中存在的这种延迟，算法规定<strong>磁头只做单向移动</strong>。</p><p>例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求访问时，<strong>磁头立即返回到最里面</strong>的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环，进行循环扫描。</p></li></ul><p>总结：</p><ol><li>先来先服务（FCFS） ：根据进程请求访问磁盘的先后次序进行调度。</li><li>最短寻道时间优先(SSTF)：该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，使得每次的寻道时间最短。</li><li>扫描算法&#x2F;电梯调度算法（SCAN）：扫描算法不仅考虑到要访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。</li><li>单向扫描调度算法（CSCAN）：为了减少这种延迟，算法规定磁头只做单向移动。</li></ol><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>双缓冲进一步加快I&#x2F;O的速度，提高了设备的利用率。其工作基本过程是在设备输入时，先将数据输入到缓冲区1，装满后便转向缓冲2。</p><p>双缓冲工作过程图：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250411010229413.png"><p>双缓冲的工作特点是，可以实现对缓冲中数据的输入T和提取M，与CPU的计算C，三者并行工作：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250411010229258.png"><h4 id="多级索引结构"><a href="#多级索引结构" class="headerlink" title="多级索引结构"></a>多级索引结构</h4>]]></content>
    
    
    <categories>
      
      <category>软件设计师</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计语言</title>
    <link href="/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    <url>/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="第二章-程序设计语言"><a href="#第二章-程序设计语言" class="headerlink" title="第二章 程序设计语言"></a>第二章 程序设计语言</h2><h3 id="程序设计语言的基本概念"><a href="#程序设计语言的基本概念" class="headerlink" title="程序设计语言的基本概念"></a>程序设计语言的基本概念</h3><ul><li><p>解释器：翻译源程序时不生产独立的目标程序。</p><ul><li>解释程序和源程序要参与到程序的运行过程中。</li></ul></li><li><p>编译器：翻译时将源程序翻译成独立保存的目标程序。</p><ul><li>机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的运行过程。</li></ul></li><li><p>许多程序设计语言规定，程序中的数据必须具有类型，其作用是：</p><ul><li><p>便于为数据合理分配存储单元</p></li><li><p>便于对参与表达式计算的数据对象进行检查</p></li><li><p>便于规定数据对象的取值范围及能够进行的运算</p></li></ul></li></ul><h3 id="程序设计语言的基本成分"><a href="#程序设计语言的基本成分" class="headerlink" title="程序设计语言的基本成分"></a>程序设计语言的基本成分</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>函数的定义包括两部分：函数首部和函数体。函数的定义描述了函数做什么和怎么做。</p><p>函数定义的一般形式为：</p><blockquote><p>返回值的类型函数名(形式参数表)&#x2F;&#x2F;函数首部函数名(实参表)；</p><p>{</p><p>​函数体；</p><p>}</p></blockquote><p>(1)值调用。若实现函数调用时将实参的值传递给相应的形参， 则称为是传值调用。在这种方式下形参不能向实参传递信息。</p><p>(2)引用调用。引用是 C++ 中引入的概念，当形式参数为引用类型时，形参名实际上是实参的别名，函数中对形参的访问和修改实际上就是针对相应实参所做的访问和改变。</p><ul><li><p>传值调用：</p><ul><li><p>将实参的值传递给形参，实参可以是变量、常量和表达式。</p></li><li><p>不可以实现形参和实参间双向传递数据的效果。</p></li></ul></li><li><p>传引用（地址）调用：</p><ul><li>将实参的地址传递给形参，形参必须有地址，实参不能是常量（值），表达式。可以实现形参和实参间双向传递数据的效果，即改变形参的值同时也改变了实参的值。</li></ul></li></ul><h3 id="编译程序基本原理"><a href="#编译程序基本原理" class="headerlink" title="编译程序基本原理"></a>编译程序基本原理</h3><ul><li><p>编译方式：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成</p></li><li><p>解释方式：词法分析、语法分析、语义分析</p></li><li><p>编译器和解释器都不可省略词法分析、语法分析、语义分析且顺序不可交换</p></li><li><p>即词法分析、语法分析、语义分析是必须的。</p></li><li><p>编译器方式中中间代码生成和代码优化不是必要，可省略。</p></li><li><p>即编译器方式可以在词法分析、语法分析、语义分析阶段后直接生成目标代码</p></li></ul><p><strong>符号表</strong>：不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入符号表中。记录源程序中各个字符的必要信息，以辅助语义的正确性检查和代码生成。</p><p>1）词法分析</p><p>输入：源程序</p><p>输出：记号流</p><p>词法分析阶段的主要作用是：分析构成程序的<strong>字符及由字符按照构造规则构成的符号，是否符合程序语言的规定</strong>。</p><p>2）语法分析</p><p>输入：记号流</p><p>输出：语法树（分析树）</p><p>语法分析阶段的主要作用是：对各条<strong>语句的结构进行合法性分析</strong>，分析程序中的句子结构是否正确。</p><p>3）语义分析</p><p>输入：语法树（分析树）</p><p>语义分析阶段的主要作用是进行<strong>类型分析和检查</strong></p><p>语义分析阶段可以发现程序中<strong>所有的语法错误</strong></p><p><strong>语义分析阶段不能发现程序中所有的语义错误</strong></p><p>语义分析阶段可以<strong>发现静态语义错误</strong>，不能发现动态语义错误，动态语义错误运行时才能发现（eg：除数为0时只能在运行阶段检查出来）</p><p>4）中间代码生成</p><p>常见的中间代码有：后缀式、三地址码、三元式、四元式和树（图）等形式。</p><p><strong>中间代码与具体的机器无关</strong>（不依赖具体的机器）,可以将不同的高级程序语言翻译成同一种中间代码。</p><p>中间代码可以跨平台。</p><p>因为与具体的机器无关，使用中间代码有利于进行与机器无关的优化处理和提高编译程序的可移植性。</p><p>6）目标代码生成</p><p>目标代码生成阶段的工作与具体的机器密切相关</p><p>寄存器的分配工作处于目标代码生成阶段</p><h3 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h3><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250411003412232.png"><p>###有限自动机</p><ul><li><strong>有限自动机是词法分析</strong>的一个工具，它能正确地识别正规集</li><li>确定的有限自动机（ DFA )：对每一个状态来说识别字符后转移的状态是唯一的</li><li>不确定的有限自动机（ NFA )：对每一个状态来说识别字符后转移的状态是不唯一的</li></ul><h3 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h3><ul><li><p>程序设计语言的绝大多数<strong>语法规则</strong>可以采用<strong>上下文无关文法</strong>进行描述。</p></li><li><p>上下文无关文法属于乔姆斯基定义的2型文法。</p></li></ul><h3 id="中缀后缀表达式"><a href="#中缀后缀表达式" class="headerlink" title="中缀后缀表达式"></a>中缀后缀表达式</h3><p>中缀式：a  ？ b   &#x3D;&#x3D;&#x3D;&gt;后缀式：ab？ 后缀式转中缀式可以用：栈</p><p>中间代码有多种形式，其中树与后缀表示形式适用于解释器，而编译器多采用与机器指令格式较接近的四元式形式。</p><p>根据生成的语法树，按照不同的方式遍历即可生成形式不同的表达式：</p><ul><li>中缀表达式：中序遍历（左-根-右）；</li><li>后缀表达式：后序便利（左-右-根）。</li></ul><blockquote><p>逆波兰式其实就是后缀式。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>软件设计师</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件化</title>
    <link href="/%E7%BB%84%E4%BB%B6%E5%8C%96-1/"/>
    <url>/%E7%BB%84%E4%BB%B6%E5%8C%96-1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><font color="red" size="6"><strong>组件化是大型App的标配</strong></font></p><h2 id="1-为什么需要组件化？"><a href="#1-为什么需要组件化？" class="headerlink" title="1.为什么需要组件化？"></a>1.为什么需要组件化？</h2><ol><li>代码耦合:项目增大后易失去层次感,容易出现不同业务间的代码马互相调用,高度耦合。组件化则可以实现各模块间不相互依赖,但可以互相交互、任意组合,高度<br>解耦。</li><li>编译时间长:项目代码越多编译时间越长。而组件化可以分模块打包进行编译测试。<br>代码复用率低:不同业务间可能会出现重复的基础代码,但是并没有有被抽离出来进行复用。组件化可以将基础组件或功能抽离出来进行复用(到新项目)。</li><li>团队开发效率低:多人协作开发时,可能会由于代码风格不同而互互相影响,也可能会增加代码版本管理成本或沟通成本。组件化将功能按照模块划分后可以一定程度上减轻以上问题从而提高效率。</li></ol><p><font color="green">所有的module都平起平坐,他们之间不会直接通信，而是通过公共的基础库进行信息传递。</font></p><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250329224827614.png" alt="组件化示例图"></p><h2 id="2-组件化需要掌握哪些技术？"><a href="#2-组件化需要掌握哪些技术？" class="headerlink" title="2.组件化需要掌握哪些技术？"></a>2.组件化需要掌握哪些技术？</h2>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统知识</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="计算机系统基础知识"><a href="#计算机系统基础知识" class="headerlink" title="计算机系统基础知识"></a>计算机系统基础知识</h3><h4 id="计算机系统硬件基本组成"><a href="#计算机系统硬件基本组成" class="headerlink" title="计算机系统硬件基本组成"></a>计算机系统硬件基本组成</h4><p>计算器的基本硬件系统由<font color="red">运算器、控制器、存储器、输入设备、输出设备</font>的5大部件组成。</p><ol><li><p><strong>中央处理单元</strong>（CPU）：作为计算机的核心部件，负责执行指令集中的指令，包括算术运算、逻辑运算以及控制操作。现代的CPU通常包含了运算器和控制器两个主要部分。</p><ol><li><p>运算器：是CPU的一部分，专门用于执行算术和逻辑运算，如加法、减法、乘法、除法以及比较等操作。</p></li><li><p>控制器：也是CPU的一个组成部分，负责协调和指挥计算机系统的各个部分工作，包括从内存中取出指令、解析指令并执行相应的操作。</p></li></ol></li><li><p><strong>存储器</strong>：</p><ol><li>内部存储器（主存）：通常指的是RAM（随机访问存储器），它提供了快速的数据访问速度，但数据是非永久性的，即断电后数据会丢失。</li><li>外部存储器（辅存）：例如硬盘、SSD（固态硬盘）、光盘等，它们提供较大的存储容量，可以长期保存数据，但访问速度相对较慢。</li></ol></li><li><p><strong>输入设备</strong>：用于向计算机输入原始数据或命令，常见的输入设备有键盘、鼠标、扫描仪、麦克风等</p></li><li><p><strong>输出设备</strong>：用于显示或输出计算机处理的结果，常见的输出设备包括显示器、打印机、音箱等。</p></li></ol><h4 id="中央处理单元-CPU"><a href="#中央处理单元-CPU" class="headerlink" title="中央处理单元 CPU"></a>中央处理单元 CPU</h4><p>中央处理单元（CPU）是计算机系统的核心部件，它负责获取程序指令、对指令进行译码并加以执行。</p><h5 id="1-CPU的功能"><a href="#1-CPU的功能" class="headerlink" title="1. CPU的功能"></a>1. CPU的功能</h5><ul><li>程序控制（控制器）</li><li>操作控制（控制器）</li><li>时间控制（控制器）</li><li>数据处理（运算器）</li></ul><h5 id="2-CPU的组成"><a href="#2-CPU的组成" class="headerlink" title="2. CPU的组成"></a>2. CPU的组成</h5><p>CPU主要由<font color="green">运算器、控制器、寄存器组和内部总线</font>等部件组成，如图1-1所示。</p><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250327004008137.png" alt="image-20250327004008074"></p><ol><li><p>运算器：运算器只能完成运算。</p><ul><li>算术逻辑单元（ALU ，Arithmetic and Logic Unit）:负责处理数据，实现对数据的算数运算和逻辑运算</li><li>累加寄存器（AC）：<strong>通用寄存器</strong>。运算器的算数逻辑单元执行算数或逻辑运算时，为ALU提供一个工作区，运算的结果存储在AC中。</li><li>数据缓冲寄存器（DR）：作为CPU和内存、外部设备之间的中转站。</li><li>状态条件寄存器（PSW，Program Status Word ）：保存各种条件码内容。</li></ul></li><li><p>控制器：控制器用于控制整个 CPU 的工作，它决定了计算机运行过程的自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。</p><ul><li>指令寄存器（IR，Instruction Register）：当CPU执行指令时，先把它从内存存储器取到缓冲寄存器中，在送入IR暂存。对用户完全透明</li><li><strong>程序计数器（指令计数器）（PC ，Program Counter）</strong>：跟踪指令的地址。PC在顺序执行的时候加1，在转移执行的时候加上一个位移量</li><li>地址寄存器（AR，Address Register ）：保存当前CPU所访问的内存单元的地址</li><li>指令译码器（ID，Instruction Decoder ）：指令包含操作码和地址码。对指令中的操作码进行分析解释</li></ul></li></ol><p><strong>补充：指令 &#x3D;&#x3D; 操作码 + 地址码</strong></p><h4 id="计算机基本单位"><a href="#计算机基本单位" class="headerlink" title="计算机基本单位"></a>计算机基本单位</h4><table><thead><tr><th align="center">位（比特） 最小数据单位</th><th align="center"><strong>bit、b</strong></th><th align="center">8b&#x3D;1B</th></tr></thead><tbody><tr><td align="center">字节 最小存储单位</td><td align="center">byte、B</td><td align="center">1B &#x3D; 8b</td></tr><tr><td align="center">千字节</td><td align="center">KB</td><td align="center">1KB &#x3D; 1024B</td></tr><tr><td align="center">兆字节</td><td align="center">MB</td><td align="center">1MB &#x3D; 1024KB</td></tr><tr><td align="center">吉字节</td><td align="center">GB</td><td align="center">1GB &#x3D; 1024MB</td></tr><tr><td align="center">太字节</td><td align="center">TB</td><td align="center">1TB &#x3D; 1024GB</td></tr></tbody></table><h4 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h4><table><thead><tr><th align="center">进制</th><th align="center">英文简写</th></tr></thead><tbody><tr><td align="center">二进制</td><td align="center">B</td></tr><tr><td align="center">八进制</td><td align="center">O</td></tr><tr><td align="center">十进制</td><td align="center">D</td></tr><tr><td align="center">十六进制</td><td align="center">H</td></tr></tbody></table><ul><li><p><strong>按权展开求和</strong>：n进制   ————&gt; 十进制　　每一位八进制数与三位二进制数对应</p></li><li><p><strong>除n取余法</strong>：十进制   ————&gt; n进制　　     每一位十六进制数与四位二进制数对应</p></li><li><p><strong>进制加减法</strong>：加法：逢n进制进一      减法：借一当n</p></li><li><p><strong>原码</strong>：总共有n位。最高位是符号位，0表示正号，1表示负号。其余n - 1为位表示数值的绝对值。</p></li><li><p><strong>反码</strong>：正数的反码与原码相同，负数的反码则是其绝对值按位求反。</p></li><li><p><strong>补码</strong>：正数的补码与其原码和反码相同，负数的补码则是等于其反码的末位加1。补码可以简化计算机运算部件的设计</p></li><li><p><strong>移码</strong>：在补码的基础上取反符号位。</p><p><font color="red">原码、反码、补码和移码的特点：</font></p><table><thead><tr><th>数制表示</th><th>定义</th><th>特点</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>原码</td><td>最高位是符号位（0正1负），其余位是数的绝对值。</td><td>零有两个编码：[+0] &#x3D; 00000000 和 [-0] &#x3D; 10000000。</td><td>数的真值和它的原码表示之间的对应关系简单，相互转换容易，用原码实现乘、除运算的规则简单。</td><td>用原码实现加、减运算很不方便。</td></tr><tr><td>反码</td><td>最高位是符号位（0正1负），正数直接表示，负数按位取反。</td><td>零有两个编码：[+0] &#x3D; 00000000 和 [-0] &#x3D; 11111111。</td><td>在某些情况下可以简化运算过程。</td><td>零有两个不同的编码，这可能会导致一些问题。</td></tr><tr><td>补码</td><td>最高位是符号位（0正1负），正数直接表示，负数按位取反后加1。</td><td>零有唯一的编码：[+0] &#x3D; [-0] &#x3D; 00000000。</td><td>补码表示的两个数在进行加法运算时，只要结果不超出机器所能表示的数值范围，可以把符号位与数值位同等处理，运算后的结果按2取模后，得到的新结果就是本次加法运算的结果。</td><td>虽然解决了零的唯一表示问题，但在某些特殊情况下，运算过程可能需要额外处理。</td></tr><tr><td>移码</td><td>在数X上增加一个偏移量来定义，常用于表示浮点数中的阶码。如果机器字长为n，规定偏移量为 (2^{n-1})。</td><td>若 (X) 是纯整数，则 ([X]<em>{移} &#x3D; 2^{n-1} + X (-2^{n-1} \leq X &lt; 2^{n-1}))；若 (X) 是纯小数，则 ([X]</em>{移} &#x3D; 1 + X (-1 \leq X &lt; 1))。</td><td>适用于浮点数的阶码表示，简化了浮点数的处理。</td><td>主要用于特定场景，如浮点数运算，对整数运算不太适用。</td></tr></tbody></table><p>补充</p><ul><li>正数的原码补码和反码都相同</li><li>补码再取补码等于原码</li><li>±0的补码、移码相同</li></ul></li></ul><p>各种码制带符号数的范围</p><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250406220142345.png" alt="带符号数的范围"></p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数使用两个定点数来分别表示实数的尾数（F）和阶码（E）。其一般形式为：N &#x3D; 2^E * F</p><ul><li><p>阶码为带符号的纯整数，尾数为带符号的纯小数。</p></li><li><p>一个数的浮点表示不是唯一的。小数点位置改变，阶码也随着相应改变。</p></li><li><p>浮点数所能表示的数值范围主要由阶码决定，所表示数值的精度则由尾数决定。</p></li><li><p>阶数不一样，先对阶小阶向大阶对，浮点数右移</p></li><li><p>规格化就是将尾数的绝对值限定在区间[0.5,1]</p></li><li><p>一般浮点数阶码用R位的移码表示，尾数用M位的补码表示。这种表示的数值范围为：</p></li></ul><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250406220627760.png" alt="image-20231012202107431"></p><h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><ul><li><strong>立即寻址</strong>：操作数就包含在指令中。（最快）</li><li><strong>寄存器寻址</strong>：操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名。</li><li><strong>直接寻址</strong>：操作数存放在内存单元中，指令中直接给出操作数所在存储单元的地址。</li><li><strong>寄存器间接寻址</strong>：操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中。</li><li><strong>间接寻址</strong>：指令中给出操作数地址的地址。（最慢）</li><li>相对寻址：指令地址码给出的是一个偏移量（可正可负)，操作数地址等于本条指令的地址加上该偏移量。</li><li>变址寻址：操作数地址等于变址寄存器的内容加偏移量。</li><li>补充<ul><li>指令系统中采用不同的寻址方式的目的是：扩大寻址空间并提高编程灵活性</li></ul></li></ul><h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><ol><li><p>奇偶校验码</p><ul><li>只能检错，不能纠错，码距 &#x3D; 2。</li><li>只能检测出奇数个数据位出错，不能检测偶数个数据位出错</li><li>水平奇偶校验码、垂直奇偶校验码、水平垂直奇偶校验码。</li></ul></li><li><p>海明码</p><ul><li>海明码可以检错也可以纠错。</li><li>码距 &#x3D; 2 ，检错能力     码距 &gt;&#x3D; 3，才有可能有纠错能力</li><li>数据位是n，校验位是k，则n和k必须满足一下关系： 2^<em>k</em> − 1≥ <em>n</em>+k</li></ul></li><li><p>循环冗余校验码（CRC）</p><ul><li>可以检错，但不能纠错,码距 &#x3D; 2。</li><li>k个数据位后跟r个校验位</li><li>校验位r采用模2运算</li></ul></li></ol><h3 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h3><h4 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h4><table><thead><tr><th align="center"></th><th align="center">RISC精简指令集计算机</th><th align="center">CISC复杂指令集计算机</th></tr></thead><tbody><tr><td align="center">指令种类</td><td align="center">少、精简</td><td align="center">多、丰富</td></tr><tr><td align="center">指令复杂度</td><td align="center">低（简单）</td><td align="center">高（复杂）</td></tr><tr><td align="center">指令长度</td><td align="center">固定</td><td align="center">变化</td></tr><tr><td align="center">寻址方式</td><td align="center">少</td><td align="center">复杂多样</td></tr><tr><td align="center">实现（译码）方式</td><td align="center">硬布线控制逻辑（组合逻辑控制器）</td><td align="center">微程序控制技术</td></tr><tr><td align="center">通用寄存器数量</td><td align="center">多、大量</td><td align="center">一般</td></tr><tr><td align="center">流水线技术</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>计算机中的流水线技术是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行。</p><p>若要执行n条指令：</p><ul><li><p>顺序执行总时间：顺序执行总时间  &#x3D;  单条指令执行的时间  ×  n</p></li><li><p>流水线执行总时间：</p><ul><li>流水线执行总时间  &#x3D;  一条指令执行的时间  +  流水线周期  ×   (<em>n</em>−1)</li><li>流水线（操作）周期为执行时间最长的一段操作的时间。</li></ul></li><li><p>连续输入<em>n</em>条指令的吞吐率：</p><ul><li>吞吐率  &#x3D;  n  ÷  总执行时间</li><li>如果是流水线的吞吐率，则总执行时间为流水线执行总时间。 <strong>流水线的吞吐率是最长流水段操作时间的倒数</strong>。即：最长流水段操作时间  &#x3D;  流水线执行总时间  ÷  n</li></ul></li><li><p>加速比：</p><p>加速比  &#x3D;  顺序执行总时间 ÷ 流水线执行总时间</p></li></ul><h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><ol><li>SRAM（静态随机存储器）：构成Cache（缓存）</li><li>DRAM（动态随机存储器）：构成主存 DRAM需要周期性地刷新保持信息。</li><li>RAM（读&#x2F;写存储器）</li><li>ROM（只读存储器）</li><li>PROM（可编程的只读存储器）</li></ol><ul><li><p>按存储器所处位置可分为：</p><ul><li><p>内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。</p></li><li><p>外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。</p></li></ul></li><li><p>按存储器的构成材料分类：</p><ul><li><p>磁存储器</p></li><li><p>半导体存储器</p></li><li><p>光存储器</p></li></ul></li><li><p>按存储器工作方式：</p><ul><li><p>读&#x2F;写存储器（RAM）。</p></li><li><p>只读存储器：ROM、PROM、EPROM、EEPROM等。</p><ul><li>固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。</li><li>可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。</li><li>EPROM、EEPROM是指带电可擦可编程只读存储器。</li></ul></li></ul></li><li><p>按访问方式：</p><ul><li><p>按地址访问：</p><ul><li>随机存储器（RAM）</li><li>顺序存储器（SAM）</li><li>直接存储器（DAM）</li></ul></li><li><p>按内容访问：例如相联存储器。</p></li></ul></li><li><p>高速缓存（Cache）用来存放当前最活跃的程序和数据，其特点是：</p><ul><li><p>位于CPU与主存之间；容量一般在几千字节到几兆字节之间；</p></li><li><p>速度一般比主存快5~10倍，由快速半导体存储器构成；</p></li><li><p>其内容是主存局部域的副本，<strong>对程序员来说是透明的。</strong></p></li></ul></li></ul><p>Cache存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到Cache存储器的哪一块里。</p><ul><li>补充内容<ul><li>虚拟存储器由主存与辅存组成。</li><li>闪存（flsah）类似U盘，掉电后信息不会丢失。以块为单位进行删除。闪存是EPROM的一种类型，可以代替ROM存储器。闪存不可以代替主存。</li><li><font color="green" size="4"><strong>Cache 与主存地址的映射是由硬件自动完成的</strong></font></li><li>数据总线：<strong>数地控</strong>即数据总线、地址总线和控制总线</li><li>发生块冲突从多到少的顺序：直接映像 &gt; 组相联映像 &gt; 全相联映像。</li></ul></li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序，转去执行有关服务程序，处理完后自动返回源程序，这个过程称为<font color="green">中断。</font></p><p>与程序控制方式相比,<strong>中断方式因为CPU无须等待而提高了效率</strong>。</p><ul><li><p><strong>中断向量</strong>：提供中断服务程序的入口地址</p></li><li><p><strong>中断响应时间</strong>：发出中断请求开始，到进入中断服务程序</p></li><li><p>保存现场：返回执行源程序</p></li><li><p>多级中断使用堆栈来保护现场最有效</p><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250408001350391.png" alt="image-20250408001350336"></p></li></ul><h4 id="输入输出-I-x2F-O-控制方式"><a href="#输入输出-I-x2F-O-控制方式" class="headerlink" title="输入输出(I&#x2F;O)控制方式"></a>输入输出(I&#x2F;O)控制方式</h4><ol><li><p>程序查询方式</p><ul><li><p><font color="red" size="4">CPU和 I&#x2F;O（外设）只能串行工作 ，</font>CPU需要一直轮询检查，长期处于忙等状态。CPU 利用率低 </p><ul><li><p>一次只能读&#x2F;写一个字</p></li><li><p>由 CPU 将数放入内存</p></li></ul></li></ul></li></ol><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250406221044766.png" alt="image-20230319101734993"></p><ol start="2"><li><p>中断驱动方式</p><ul><li><p>I&#x2F;O 设备通过中断信号主动向 CPU 报告 I&#x2F;O 操作已完成</p><ul><li><p><font color="red" size="4">CPU 和 I&#x2F;O（外设）可并行工作</font></p></li><li><p>CPU 利用率得到提升</p></li><li><p>一次只能 读&#x2F;写 一个字</p></li><li><p>由 CPU 将数据放入内存</p></li></ul></li></ul></li></ol><p>​<img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250411001823082.png" alt="image-20230319101818583"></p><ol start="2"><li><p>直接存储器方式（DMA）</p><ul><li>CPU 和 I&#x2F;O（外设）可并行工作 </li><li>仅在传送数据块的开始和结束时才需要 CPU 的干预 </li><li>由外设直接将数据放入内存 </li><li>一次读写的单位为”块“而不是字</li></ul></li></ol><p></p><p>​<img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250407235316994.png" style="zoom:50%;"></p><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。</p><p>采用总线结构主要有以下优点：</p><ul><li>简化系统结构，便于系统设计制造；</li><li>大大减少了连线数目，便于布线，减小体积，提高系统的可靠性；</li><li>便于接口设计，所有与总线连接的设备均采用类似的接口；</li><li>便于系统的扩充、更新与灵活配置，易于实现系统的模块化；</li><li>便于设备的软件设计；</li><li>便于故障诊断和维修，同时也降低了成本。</li></ul><p>在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以减少信息传输线的数量。</p><p>微机中的总线分为：</p><ul><li>数据总线</li><li>地址总线</li><li>控制总线</li></ul><p>常见总线：</p><ul><li>ISA总线。</li><li>EISA总线。</li><li>PCI总线：PCI总线是目前微型机上广泛采用的<strong>并行内总线。</strong></li><li>PCI Express 总线。</li><li>前端总线。</li><li>RS-232C。</li><li>SCSI总线：小型计算机系统接口（SCSI）是一条<strong>并行外总线</strong>。</li><li>SATA。</li><li>USB。</li><li>IEEE-1394。</li><li>IEEE-488总线。</li></ul><h4 id="加密技术和认证技术"><a href="#加密技术和认证技术" class="headerlink" title="加密技术和认证技术"></a>加密技术和认证技术</h4><ul><li><p>加密技术： </p><ol><li>对称加密（私有密钥加密）<br>加密和解密是同一把密钥，只有一把密钥<br>密钥分发有缺陷     1. 加密解密速度很快 2. 适合加密大量明文数据 </li><li>非对称密钥（公开密钥加密）<br>加密和解密不是同一把密钥，一共有两把密钥 分别是公钥和私钥<br>用公钥加密只能用私钥解密用私钥加密只能用公钥解密<br>不能通过一把推出另一把 用接收方的公钥加密明文，可以实现防止窃听的效果<br>密钥分发没有缺陷1.加密解密速度很慢 </li><li>混合加密</li></ol></li><li><p>认证技术： </p><ol><li>摘要：将发送的明文进行Hash算法后得到的摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的Hash算法得到的摘要进行对比，如果一致，则没有篡改，否则有篡改。 </li><li>数字签名：<font color="red" size="4">发送方用自己的私钥对摘要进行签名（加密）得到数字签名放在密文后一起发送过去。接收方用发送方的公钥对数字签名进行验证（解密）</font>如果验证成功则该消息没有被假冒且不能否认，否则该消息的真实性为假冒发送。</li></ol><ul><li>使用数字签名确保消息不可否认</li></ul><ol start="3"><li>数字证书：用户向CA（权威机构）机构申请数字证书，将个人信息和公钥发给CA机构，CA机构颁给用户数字证书，数字证书用CA的私钥进行签名（加密）用CA的公钥验证（解密）数字证书得到用户的公钥。<ul><li>使用数字整数确保用户身份</li><li>用户通过CA的公钥验证CA的签名，确定网站的真伪</li></ul></li></ol></li></ul><h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><table><thead><tr><th align="center">对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）</th><th align="center">非对称密钥（公钥、公开密钥加密）算法</th></tr></thead><tbody><tr><td align="center">DES (Data Encryption Standard): 一种早期的数据加密标准，使用56位密钥。由于其较短的密钥长度，现在被认为不安全。</td><td align="center">RSA (Rivest–Shamir–Adleman): 最早提出的非对称加密算法之一，基于大整数分解问题，广泛应用在数据加密和数字签名中。</td></tr><tr><td align="center">3DES (Triple DES): 是DES的一种改进形式，通过应用DES三次来增加安全性。</td><td align="center">ECC (Elliptic Curve Cryptography): 基于椭圆曲线离散对数问题的加密技术，相比RSA可以在提供相同安全级别的条件下使用更短的密钥长度，因此更加高效。</td></tr><tr><td align="center">RC-5 (Rivest Cipher 5): 由Ron Rivest设计的一种对称密钥分组密码算法，允许用户选择块大小、密钥大小和轮数。</td><td align="center">DSA (Digital Signature Algorithm): 主要用于数字签名，不是用来加密数据。它与RSA类似，但专门为数字签名设计。</td></tr><tr><td align="center">IDEA (International Data Encryption Algorithm): 一种128位密钥的对称加密算法，最初为PGP加密软件开发。</td><td align="center"></td></tr><tr><td align="center">AES (Advanced Encryption Standard): 目前最常用的对称加密标准之一，支持128, 192, 和256位密钥长度。AES因其高效性和安全性被广泛应用于各种场合。</td><td align="center"></td></tr><tr><td align="center">RC4: 一种流加密算法，曾广泛应用于SSL&#x2F;TLS协议中，但由于发现了一些漏洞，逐渐被弃用或替换。</td><td align="center"></td></tr></tbody></table><p>Hash函数</p><p>MD5 摘要算法（128位散列值）</p><p>SHA-1 安全散列算法</p><p><strong>认证是处理主动攻击</strong></p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ol><li>串联系统。假设一个系统由N个子系统组成，当且仅当所有子系统都能正常工作时系统才能正常工作，这样的系统称为串联系统。<ul><li><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250407235317054.png"></li><li>系统可靠性  R &#x3D; R₁R₂···Rn</li></ul></li><li>并联系统。假设一个系统由N个子系统组成，只要有一个子系统正常工作，系统就能正常工作，这样的系统称为并联系统。</li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250411002400531.png"><p>系统可靠性  R &#x3D; 1 -  (1-R₁)(1-R₂)···(1-Rn)</p><h3 id="补充列题说明"><a href="#补充列题说明" class="headerlink" title="补充列题说明"></a>补充列题说明</h3><ul><li>指令寄存器的位数取决于**<u>指令字长</u>**</li><li>逻辑同或：<strong>相同为一，不同为零</strong></li><li>逻辑异或：<strong>相同为零，不同为一</strong></li><li>计算机采用分层存储体系的主要目的是为了解决：**<u>存储容量、成本和速度之间的矛盾</u>**</li><li>被动攻击：流量分析、会话拦截。                       主动攻击：重放、IP地址欺骗、拒绝服务、系统干涉、修改数据命令</li><li>CPU依据 <u><strong>指令周期的不同阶段</strong></u>来区分内存中以二进制编码形式存放的指令和数据</li></ul><table><thead><tr><th align="center">X</th><th align="center">Y</th><th align="center">逻辑与</th><th align="center">逻辑或</th><th align="center">逻辑异或</th><th align="center">逻辑同或</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>软件设计师</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建图床</title>
    <link href="/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>网上有很多教程，这里主要列出踩到坑的地方</p><p><a href="https://blog.csdn.net/duleilewuhen/article/details/139478827">利用 PicGo 搭建基于 gitee 的个人图床，详细攻略！_picgo gitee-CSDN博客</a></p><p>我使用gitee存放图片，PicGo是默认不支持的，需要安装插件。需要下载最新的PicGo才能直接访问插件市场，</p><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250325175926838.png" alt="image-20250325175926780"></p><p>其次是在PicGo中关于gitee里面的配置：</p><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250325180351091.png" alt="image-20250325180351035"></p>]]></content>
    
    
    
    <tags>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown语法</title>
    <link href="/markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><font color="red">红色字体</font></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">font</span> <span class="hljs-keyword">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;红色字体&lt;/<span class="hljs-keyword">font</span>&gt;<br></code></pre></td></tr></table></figure><p><font color="green">绿色字体</font></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">font</span> <span class="hljs-keyword">color</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;绿色字体&lt;/<span class="hljs-keyword">font</span>&gt;<br></code></pre></td></tr></table></figure><p><font color="blue">蓝色字体</font></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">font</span> <span class="hljs-keyword">color</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;蓝色字体&lt;/<span class="hljs-keyword">font</span>&gt;<br></code></pre></td></tr></table></figure><p><font color="red" face="黑体" size="5">别犹豫了！点赞吧！</font></p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml">&lt;<span class="hljs-built_in">font</span> <span class="hljs-built_in">color</span>=<span class="hljs-string">&quot;red&quot;</span> face=<span class="hljs-string">&quot;黑体&quot;</span> <span class="hljs-built_in">size</span>=<span class="hljs-number">5</span>&gt;别犹豫了！点赞吧！&lt;/<span class="hljs-built_in">font</span>&gt;<br></code></pre></td></tr></table></figure><p><mark>高亮显示</mark></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span>&gt;</span>高亮显示<span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span><br></code></pre></td></tr></table></figure><table><tr><td bgcolor="yellow">搞点颜色</td></tr></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;yellow&quot;</span>&gt;</span>搞点颜色<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font size="5">5号字</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">5</span>&gt;</span>5号字<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font face="黑体">黑体字</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;黑体&quot;</span>&gt;</span>黑体字<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><p><ruby>饕餮 <rt>tāo tiè</rt></ruby></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ruby</span>&gt;</span>饕餮 <span class="hljs-tag">&lt;<span class="hljs-name">rt</span>&gt;</span>tāo tiè<span class="hljs-tag">&lt;/<span class="hljs-name">rt</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ruby</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>hello World</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br><br></code></pre></td></tr></table></figure><img src="https://i-blog.csdnimg.cn/blog_migrate/20d6af58735197e7dbe45daf0793feb3.png" width="400" height="192" div align="center">]]></content>
    
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础查找算法</title>
    <link href="/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。在这里主要会介绍<font color="red"><strong>顺序查找</strong>、<strong>二分查找</strong>、<strong>哈希查找</strong></font>三种基础查找算法。</p><ul><li><p><input checked disabled type="checkbox"> <strong>查找定义：</strong>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p></li><li><p><input checked disabled type="checkbox"> <strong>查找算法分类：</strong></p></li></ul><p>　　1）静态查找和动态查找；</p><p>　　　　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</p><p>　　2）无序查找和有序查找。</p><p>　　　　无序查找：被查找数列有序无序均可；</p><p>　　　　有序查找：被查找数列必须为有序数列。</p><p><strong>平均查找长度（Average Search Length，ASL）：</strong>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p><h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h3><p><strong>说明</strong>：<font color="green">顺序查找适合于存储结构为顺序存储或链接存储的线性表。</font></p><p><strong>基本思想：</strong>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p><strong>复杂度分析：</strong>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL &#x3D; 1&#x2F;n(1+2+3+…+n) &#x3D; (n+1)&#x2F;2 ;  当查找不成功时，需要n+1次比较，时间复杂度为O(n);</p><h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><strong>说明</strong>：<font color="green">元素必须是有序的，如果是无序的则要先进行排序操作。</font></p><p><strong>基本思想：</strong>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p><p><strong>复杂度分析：</strong>最坏情况下，关键词比较次数为log2(n+1)，且**期望时间复杂度为O(log2n)**；</p><p>怎么去求<strong>折半查找</strong>平均查找长度呢？</p><ul><li><strong>例：给11个数据元素有序表（2,3,10,15,20,25,28,29,30,35,40）采用折半查找。则ASL成功和不成功分别是多少？</strong></li></ul><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250325174740033.jpeg" alt="判定树"></p><p>查找成功时总会找到途中某个内部结点，所以成功时的平均查找长度为:</p><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250325180803950.png" alt="image-20250325180803912"></p><p>不成功的平均查找长度为:</p><p><img src="https://gitee.com/silent-learner/imgs/raw/master/2025%E5%9B%BE%E7%89%87/20250325181201100.png" alt="image-20250325181201056"></p><p><a href="https://b23.tv/lgEygt3">【折半查找判定树画法与ASL-哔哩哔哩】</a></p><h3 id="3-哈希查找"><a href="#3-哈希查找" class="headerlink" title="3. 哈希查找"></a>3. 哈希查找</h3><p>哈希查找是一种快速查找算法，该<font color="red">算法不需要对关键字进行比较，而是以关键字为自变量，以该关键字在存储空间中的地址为因变量，建立某种函数关系，称为哈希函数</font>，这样在查找某一关键字的时候，就可以通过哈希函数直接得到其地址，有效的提高了查找效率。</p><p>选取哈希函数及基本原则主要有：计算函数所需时间、关键字的长度、哈希表长度（哈希地址范围）、关键字分布情况、记录的查找频率等。</p><p>哈希函数的构造有多种，常见的有“直接定址法”、“数字分析法”、“平方取中法”、“折叠法”、“除留余数法”、“随机数法”等。</p><p>哈希函数构造的一个基本原则就是尽量避免冲突，也就是尽量避免因变量地址的冲突。一旦发生冲突，就需要重新定址。常见的处理地址冲突的方法有：“开放定址法”、“再哈希法”、“链地址法”、“建立公共溢出区”等。</p>]]></content>
    
    
    <categories>
      
      <category>软件设计师</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java序列化</title>
    <link href="/java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/java%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Java和Android序列化总结"><a href="#Java和Android序列化总结" class="headerlink" title="Java和Android序列化总结"></a>Java和Android序列化总结</h1><h2 id="1-序列化概述"><a href="#1-序列化概述" class="headerlink" title="1. 序列化概述"></a>1. 序列化概述</h2><h3 id="1-1-什么是序列化？"><a href="#1-1-什么是序列化？" class="headerlink" title="1.1 什么是序列化？"></a>1.1 什么是序列化？</h3><p>序列化是指将对象的状态信息转换为可以存储或传输的形式的过程。反序列化则是将存储或传输的数据重新转换为对象的过程。序列化主要用于对象的持久化、对象的远程传输等场景。</p><h3 id="1-2-为什么需要序列化？"><a href="#1-2-为什么需要序列化？" class="headerlink" title="1.2 为什么需要序列化？"></a>1.2 为什么需要序列化？</h3><ul><li><strong>持久化</strong>：将对象保存到文件或数据库中，以便后续使用。</li><li><strong>网络传输</strong>：将对象通过网络传输到其他系统或设备。</li><li><strong>共享对象</strong>：在多个进程中共享对象。</li></ul><h2 id="2-Java序列化"><a href="#2-Java序列化" class="headerlink" title="2. Java序列化"></a>2. Java序列化</h2><h3 id="2-1-Serializable-接口"><a href="#2-1-Serializable-接口" class="headerlink" title="2.1 Serializable 接口"></a>2.1 <code>Serializable</code> 接口</h3><p>Java 提供了 <code>Serializable</code> 接口来实现对象的序列化。任何实现了 <code>Serializable</code> 接口的类都可以被序列化。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// Getters and Setters</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-序列化和反序列化"><a href="#2-2-序列化和反序列化" class="headerlink" title="2.2 序列化和反序列化"></a>2.2 序列化和反序列化</h3><p>使用 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 进行序列化和反序列化。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializationExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John Doe&quot;</span>, <span class="hljs-number">30</span>);<br><br>        <span class="hljs-comment">// 序列化</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;user.ser&quot;</span>))) &#123;<br>            oos.writeObject(user);<br>            System.out.println(<span class="hljs-string">&quot;User object serialized.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;user.ser&quot;</span>))) &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">deserializedUser</span> <span class="hljs-operator">=</span> (User) ois.readObject();<br>            System.out.println(<span class="hljs-string">&quot;User object deserialized: &quot;</span> + deserializedUser.getName() + <span class="hljs-string">&quot;, &quot;</span> + deserializedUser.getAge());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-transient-关键字"><a href="#2-3-transient-关键字" class="headerlink" title="2.3 transient 关键字"></a>2.3 <code>transient</code> 关键字</h3><p>使用 <code>transient</code> 关键字可以标记不希望被序列化的字段。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// Getters and Setters</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-自定义序列化"><a href="#2-4-自定义序列化" class="headerlink" title="2.4 自定义序列化"></a>2.4 自定义序列化</h3><p>通过实现 <code>writeObject</code> 和 <code>readObject</code> 方法来自定义序列化过程。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(ObjectOutputStream oos)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        oos.defaultWriteObject();<br>        oos.writeInt(age * <span class="hljs-number">2</span>); <span class="hljs-comment">// 自定义序列化</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream ois)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        ois.defaultReadObject();<br>        age = ois.readInt() / <span class="hljs-number">2</span>; <span class="hljs-comment">// 自定义反序列化</span><br>    &#125;<br><br>    <span class="hljs-comment">// Getters and Setters</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Android序列化"><a href="#3-Android序列化" class="headerlink" title="3. Android序列化"></a>3. Android序列化</h2><h3 id="3-1-Parcelable-接口"><a href="#3-1-Parcelable-接口" class="headerlink" title="3.1 Parcelable 接口"></a>3.1 <code>Parcelable</code> 接口</h3><p>Android 提供了 <code>Parcelable</code> 接口来实现更高效的序列化。<code>Parcelable</code> 比 <code>Serializable</code> 更轻量级，性能更好。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.os.Parcel;<br><span class="hljs-keyword">import</span> android.os.Parcelable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">User</span><span class="hljs-params">(Parcel in)</span> &#123;<br>        name = in.readString();<br>        age = in.readInt();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Creator</span>&lt;User&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> User <span class="hljs-title function_">createFromParcel</span><span class="hljs-params">(Parcel in)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(in);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> User[] newArray(<span class="hljs-type">int</span> size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>[size];<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">describeContents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToParcel</span><span class="hljs-params">(Parcel dest, <span class="hljs-type">int</span> flags)</span> &#123;<br>        dest.writeString(name);<br>        dest.writeInt(age);<br>    &#125;<br><br>    <span class="hljs-comment">// Getters and Setters</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-使用-Bundle-传递-Parcelable-对象"><a href="#3-2-使用-Bundle-传递-Parcelable-对象" class="headerlink" title="3.2 使用 Bundle 传递 Parcelable 对象"></a>3.2 使用 <code>Bundle</code> 传递 <code>Parcelable</code> 对象</h3><p>在 Android 中，可以使用 <code>Bundle</code> 将 <code>Parcelable</code> 对象传递给其他组件。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 User 对象</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John Doe&quot;</span>, <span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// 将 User 对象放入 Bundle</span><br><span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>bundle.putParcelable(<span class="hljs-string">&quot;user&quot;</span>, user);<br><br><span class="hljs-comment">// 通过 Intent 传递 Bundle</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, NextActivity.class);<br>intent.putExtras(bundle);<br>startActivity(intent);<br><br><span class="hljs-comment">// 在 NextActivity 中获取 User 对象</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> getIntent().getExtras().getParcelable(<span class="hljs-string">&quot;user&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-3-Serializable-vs-Parcelable"><a href="#3-3-Serializable-vs-Parcelable" class="headerlink" title="3.3 Serializable vs Parcelable"></a>3.3 <code>Serializable</code> vs <code>Parcelable</code></h3><ul><li><strong>性能</strong>：<code>Parcelable</code> 性能更好，因为它不涉及反射。</li><li><strong>复杂性</strong>：<code>Serializable</code> 更简单，但 <code>Parcelable</code> 需要更多的代码。</li><li><strong>使用场景</strong>：<code>Serializable</code> 适用于简单的对象，<code>Parcelable</code> 适用于复杂的对象和频繁的序列化操作。</li></ul><h2 id="4-序列化的优缺点"><a href="#4-序列化的优缺点" class="headerlink" title="4. 序列化的优缺点"></a>4. 序列化的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><ul><li><strong>持久化</strong>：可以将对象状态保存到文件或数据库中。</li><li><strong>网络传输</strong>：可以将对象通过网络传输到其他系统或设备。</li><li><strong>共享对象</strong>：可以在多个进程中共享对象。</li></ul><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><ul><li><strong>性能</strong>：<code>Serializable</code> 性能较差，涉及反射和大量的 I&#x2F;O 操作。</li><li><strong>安全性</strong>：序列化后的数据容易被篡改，需要额外的安全措施。</li><li><strong>版本兼容性</strong>：对象的序列化格式可能会随类的变更而变化，导致反序列化失败。</li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>序列化是将对象状态转换为可存储或传输形式的重要技术。Java 提供了 <code>Serializable</code> 接口，而 Android 提供了 <code>Parcelable</code> 接口来实现序列化。<code>Serializable</code> 简单易用，但性能较差；<code>Parcelable</code> 性能更好，但需要编写更多的代码。根据具体需求选择合适的序列化方式，可以有效提升应用的性能和可靠性。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的引用类型</title>
    <link href="/Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <url>/Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，引用类型主要分为四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。每种引用类型都有其特定的用途和应用场景。了解这些引用类型对于理解和优化 Java 内存管理非常重要，也是面试中常见的考点。</p><h3 id="1-强引用（Strong-Reference）"><a href="#1-强引用（Strong-Reference）" class="headerlink" title="1. 强引用（Strong Reference）"></a>1. 强引用（Strong Reference）</h3><p><strong>定义</strong>：</p><ul><li>强引用是最常见的引用类型，类似于我们平时使用的对象引用。</li><li>只要强引用还存在，垃圾回收器就不会回收被引用的对象。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li>大多数情况下，对象都需要使用强引用来确保其在内存中的存活。</li><li>适用于需要长期存在的对象，如业务逻辑中的实体对象。</li></ul><p><strong>面试重点</strong>：</p><ul><li>强引用是最基本的引用类型，理解其行为是基础。</li><li>问：什么是强引用？答：强引用是最常见的引用类型，只要强引用还存在，垃圾回收器就不会回收被引用的对象。</li></ul><h3 id="2-软引用（Soft-Reference）"><a href="#2-软引用（Soft-Reference）" class="headerlink" title="2. 软引用（Soft Reference）"></a>2. 软引用（Soft Reference）</h3><p><strong>定义</strong>：</p><ul><li>软引用用于描述一些还有用但非必需的对象。</li><li>当系统内存不足时，垃圾回收器会回收这些对象。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>SoftReference&lt;Object&gt; softRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 释放强引用</span><br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li>适用于缓存场景，如图片缓存、数据缓存等。</li><li>当内存紧张时，可以释放这些缓存对象，保证应用程序的正常运行。</li></ul><p><strong>面试重点</strong>：</p><ul><li>问：什么是软引用？答：软引用用于描述一些还有用但非必需的对象，当系统内存不足时，垃圾回收器会回收这些对象。</li><li>问：软引用的典型应用场景是什么？答：软引用常用于缓存场景，如图片缓存、数据缓存等。</li></ul><h3 id="3-弱引用（Weak-Reference）"><a href="#3-弱引用（Weak-Reference）" class="headerlink" title="3. 弱引用（Weak Reference）"></a>3. 弱引用（Weak Reference）</h3><p><strong>定义</strong>：</p><ul><li>弱引用也是用于描述非必需的对象，但比软引用更弱。</li><li>无论内存是否充足，垃圾回收器都会回收被弱引用关联的对象。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.WeakReference;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>WeakReference&lt;Object&gt; weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 释放强引用</span><br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li>适用于不需要长期存在的临时对象，如缓存、事件处理器等。</li><li>适用于需要在对象被垃圾回收时进行某些清理操作的场景。</li></ul><p><strong>面试重点</strong>：</p><ul><li>问：什么是弱引用？答：弱引用也是用于描述非必需的对象，但比软引用更弱，无论内存是否充足，垃圾回收器都会回收被弱引用关联的对象。</li><li>问：弱引用的典型应用场景是什么？答：弱引用常用于不需要长期存在的临时对象，如缓存、事件处理器等。</li></ul><h3 id="4-虚引用（Phantom-Reference）"><a href="#4-虚引用（Phantom-Reference）" class="headerlink" title="4. 虚引用（Phantom Reference）"></a>4. 虚引用（Phantom Reference）</h3><p><strong>定义</strong>：</p><ul><li>虚引用是最弱的一种引用关系，一个对象是否有虚引用完全不会对其生存时间构成影响。</li><li>虚引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.PhantomReference;<br><span class="hljs-keyword">import</span> java.lang.ref.ReferenceQueue;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>ReferenceQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>PhantomReference&lt;Object&gt; phantomRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, queue);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 释放强引用</span><br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li>适用于需要在对象被垃圾回收时进行某些清理操作的场景，如资源释放、日志记录等。</li><li>适用于需要跟踪对象的生命周期，但又不想影响对象的垃圾回收的场景。</li></ul><p><strong>面试重点</strong>：</p><ul><li>问：什么是虚引用？答：虚引用是最弱的一种引用关系，一个对象是否有虚引用完全不会对其生存时间构成影响，必须和引用队列联合使用。</li><li>问：虚引用的典型应用场景是什么？答：虚引用常用于需要在对象被垃圾回收时进行某些清理操作的场景，如资源释放、日志记录等。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>强引用</strong>：最常见的引用类型，确保对象在内存中的存活。</li><li><strong>软引用</strong>：用于描述还有用但非必需的对象，当内存不足时会被回收，适用于缓存场景。</li><li><strong>弱引用</strong>：比软引用更弱，无论内存是否充足都会被回收，适用于不需要长期存在的临时对象。</li><li><strong>虚引用</strong>：最弱的引用关系，用于跟踪对象的生命周期，但不影响对象的垃圾回收，适用于需要在对象被垃圾回收时进行清理操作的场景。</li></ul><h3 id="面试中可能问到的重点"><a href="#面试中可能问到的重点" class="headerlink" title="面试中可能问到的重点"></a>面试中可能问到的重点</h3><p><strong>引用类型的分类</strong>：</p><ul><li>问：Java 中有哪些引用类型？答：Java 中有四种引用类型：强引用、软引用、弱引用和虚引用。</li></ul><p><strong>引用类型的行为</strong>：</p><ul><li>问：不同引用类型的行为有何不同？答：强引用确保对象在内存中的存活；软引用在内存不足时会被回收；弱引用无论内存是否充足都会被回收；虚引用用于跟踪对象的生命周期，但不影响垃圾回收。</li></ul><p><strong>应用场景</strong>：</p><ul><li>问：软引用的典型应用场景是什么？答：软引用常用于缓存场景，如图片缓存、数据缓存等。</li><li>问：虚引用的典型应用场景是什么？答：虚引用常用于需要在对象被垃圾回收时进行某些清理操作的场景，如资源释放、日志记录等。</li></ul><p><strong>引用队列</strong>：</p><ul><li>问：虚引用必须和什么联合使用？答：虚引用必须和引用队列（ReferenceQueue）联合使用。</li></ul><p><strong>内存管理</strong>：</p><ul><li>问：如何通过引用类型优化内存管理？答：通过使用软引用和弱引用，可以在内存紧张时自动释放缓存对象，减少内存占用；通过使用虚引用，可以在对象被垃圾回收时进行必要的清理操作，避免资源泄漏。</li></ul><p><strong>虚引用</strong></p><ul><li>问：释放强引用时候调用方法释放资源不行吗，或者在对象的销毁方法里面执行，为什么要使用虚引用的方式释放资源？答：使用虚引用，<strong>自动管理</strong>：不需要开发者显式地调用释放资源的方法，由垃圾回收器自动触发。<strong>处理意外情况</strong>：即使对象被意外地垃圾回收，也可以通过引用队列捕获并执行清理操作。<strong>灵活性</strong>：可以在多个地方注册相同的虚引用，实现更复杂的资源管理逻辑。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java字符串</title>
    <link href="/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，<code>String</code>、<code>StringBuffer</code> 和 <code>StringBuilder</code> 都是用于处理字符串的类，但它们在性能、线程安全和使用场景上有所不同。下面详细介绍它们的区别和使用场景：</p><h3 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. <code>String</code></h3><ul><li><strong>不可变性</strong>：<code>String</code> 是不可变的，一旦创建，其值就不能改变。每次对 <code>String</code> 进行修改操作（如拼接、替换等），都会创建一个新的 <code>String</code> 对象。</li><li><strong>线程安全</strong>：由于不可变性，<code>String</code> 是线程安全的。</li><li><strong>性能</strong>：由于每次修改都会创建新的对象，频繁的字符串操作会导致性能下降和内存开销增加。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str1 + <span class="hljs-string">&quot; World&quot;</span>; <span class="hljs-comment">// 创建了一个新的 String 对象</span><br>System.out.println(str2); <span class="hljs-comment">// 输出 &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>不可变字符串</strong>：适用于不需要修改的字符串，如常量字符串。</li><li><strong>多线程环境</strong>：由于线程安全，适合在多线程环境中使用。</li></ul><h3 id="2-StringBuffer"><a href="#2-StringBuffer" class="headerlink" title="2. StringBuffer"></a>2. <code>StringBuffer</code></h3><ul><li><strong>可变性</strong>：<code>StringBuffer</code> 是可变的，可以在不创建新对象的情况下修改字符串内容。</li><li><strong>线程安全</strong>：<code>StringBuffer</code> 的所有方法都是同步的（即线程安全的），这使得它在多线程环境中可以安全使用。</li><li><strong>性能</strong>：由于同步机制，<code>StringBuffer</code> 在单线程环境下的性能不如 <code>StringBuilder</code>。</li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.append(<span class="hljs-string">&quot; World&quot;</span>); <span class="hljs-comment">// 不会创建新的对象</span><br>System.out.println(sb); <span class="hljs-comment">// 输出 &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>多线程环境</strong>：适用于需要在多线程环境中进行字符串操作的场景。</li><li><strong>频繁修改字符串</strong>：适用于需要频繁修改字符串内容的场景，但注意在单线程环境下性能不如 <code>StringBuilder</code>。</li></ul><h3 id="3-StringBuilder"><a href="#3-StringBuilder" class="headerlink" title="3. StringBuilder"></a>3. <code>StringBuilder</code></h3><ul><li><strong>可变性</strong>：<code>StringBuilder</code> 是可变的，可以在不创建新对象的情况下修改字符串内容。</li><li><strong>线程不安全</strong>：<code>StringBuilder</code> 的方法不是同步的，因此在多线程环境中使用时需要注意线程安全问题。</li><li><strong>性能</strong>：由于没有同步开销，<code>StringBuilder</code> 在单线程环境下的性能优于 <code>StringBuffer</code>。</li></ul><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.append(<span class="hljs-string">&quot; World&quot;</span>); <span class="hljs-comment">// 不会创建新的对象</span><br>System.out.println(sb); <span class="hljs-comment">// 输出 &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>单线程环境</strong>：适用于在单线程环境中进行字符串操作的场景。</li><li><strong>频繁修改字符串</strong>：适用于需要频繁修改字符串内容的场景，性能优于 <code>StringBuffer</code>。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性&#x2F;类</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td><strong>可变性</strong></td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td><strong>线程安全</strong></td><td>是</td><td>是</td><td>否</td></tr><tr><td><strong>性能</strong></td><td>较低</td><td>中等</td><td>高</td></tr><tr><td><strong>使用场景</strong></td><td>不需要修改的字符串，多线程环境</td><td>需要在多线程环境中修改字符串</td><td>单线程环境，频繁修改字符串</td></tr></tbody></table><h3 id="选择指南"><a href="#选择指南" class="headerlink" title="选择指南"></a>选择指南</h3><ol><li><strong>不可变字符串</strong>：使用 <code>String</code>。</li><li><strong>多线程环境</strong>：使用 <code>StringBuffer</code>。</li><li><strong>单线程环境，频繁修改字符串</strong>：使用 <code>StringBuilder</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中文件的查找</title>
    <link href="/Linux%E6%96%87%E4%BB%B6%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/Linux%E6%96%87%E4%BB%B6%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>在使用linux时，经常需要进行文件查找。其中查找的命令主要有<code>find</code>和<code>grep</code>。他们都具有查找功能，但是查找的方向不一致。</p><h2 id="find-查找"><a href="#find-查找" class="headerlink" title="find 查找"></a>find 查找</h2><ul><li>主要用于查找文件和目录。</li><li>可以根据多种条件（如文件名、大小、修改时间等）来查找文件。</li><li>适用于文件系统的搜索</li></ul><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">find [路径] [表达式]<br></code></pre></td></tr></table></figure><ul><li><strong>路径</strong>：指定要搜索的目录或文件路径。</li><li><strong>表达式</strong>：指定查找条件，如 <code>-name</code>、<code>-type</code>、<code>-mtime</code> 等。</li></ul><p>按文件名查找</p><p>**<code>-name</code>**：按文件名查找，支持通配符 <code>*</code> 和 <code>?</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">find /path/to/search -name <span class="hljs-string">&quot;filename.txt&quot;</span><br><span class="hljs-comment">## 查找当前目录及其子目录中所有扩展名为 .txt 的文件</span><br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span><br></code></pre></td></tr></table></figure><h4 id="按文件类型查找"><a href="#按文件类型查找" class="headerlink" title="按文件类型查找"></a>按文件类型查找</h4><ul><li><code>f</code>：普通文件</li><li><code>d</code>：目录</li><li><code>l</code>：符号链接</li><li><code>c</code>：字符设备</li><li><code>b</code>：块设备</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## 查找当前目录及其子目录中的所有目录</span><br>find . -<span class="hljs-built_in">type</span> d<br></code></pre></td></tr></table></figure><h4 id="按修改时间查找"><a href="#按修改时间查找" class="headerlink" title="按修改时间查找"></a>按修改时间查找</h4><p>**<code>-mtime</code>**：按文件的最后修改时间查找。</p><ul><li><code>+n</code>：超过 n 天</li><li><code>-n</code>：少于 n 天</li><li><code>n</code>：正好 n 天</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## 查找当前目录及其子目录中最后 7 天内修改过的文件</span><br>find . -mtime -7<br><span class="hljs-comment">## 查找当前目录及其子目录中超过 30 天未修改的文件</span><br>find . -mtime +30<br></code></pre></td></tr></table></figure><h4 id="按访问时间查找"><a href="#按访问时间查找" class="headerlink" title="按访问时间查找"></a>按访问时间查找</h4><p>**<code>-atime</code>**：按文件的最后访问时间查找。</p><ul><li><code>+n</code>：超过 n 天</li><li><code>-n</code>：少于 n 天</li><li><code>n</code>：正好 n 天</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## 查找当前目录及其子目录中最后 7 天内访问过的文件</span><br>find . -atime -7<br></code></pre></td></tr></table></figure><h4 id="按文件大小查找"><a href="#按文件大小查找" class="headerlink" title="按文件大小查找"></a>按文件大小查找</h4><p>**<code>-size</code>**：按文件大小查找。</p><ul><li><code>+n</code>：大于 n</li><li><code>-n</code>：小于 n</li><li><code>n</code>：正好 n</li></ul><p>单位可以是 <code>c</code>（字节）、<code>k</code>（千字节）、<code>M</code>（兆字节）、<code>G</code>（吉字节）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## 查找当前目录及其子目录中大于 100MB 的文件</span><br>find . -size +100M<br></code></pre></td></tr></table></figure><h4 id="按权限查找"><a href="#按权限查找" class="headerlink" title="按权限查找"></a>按权限查找</h4><p>**<code>-perm</code>**：按文件权限查找。</p><ul><li><code>-mode</code>：权限完全匹配</li><li><code>+mode</code>：权限部分匹配</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## 查找当前目录及其子目录中权限为 755 的文件</span><br>find . -perm 755<br><span class="hljs-comment">## 查找当前目录及其子目录中具有可执行权限的文件</span><br>find . -perm +111<br></code></pre></td></tr></table></figure><h4 id="按用户和组查找"><a href="#按用户和组查找" class="headerlink" title="按用户和组查找"></a>按用户和组查找</h4><ul><li>**<code>-user</code>**：按文件的所有者查找。</li><li>**<code>-group</code>**：按文件的所属组查找。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">##查找当前目录及其子目录中属于用户 `john` 的文件：</span><br>find . -user john<br></code></pre></td></tr></table></figure><h4 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h4><ul><li>**<code>-and</code>**：逻辑与（默认）</li><li>**<code>-or</code>**：逻辑或</li><li>**<code>!</code>**：逻辑非</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">##查找当前目录及其子目录中扩展名为 .txt 且大小大于 1MB 的文件</span><br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> -size +1M<br><span class="hljs-comment">##查找当前目录及其子目录中扩展名为 .txt 或 .log 的文件</span><br>find . $ -name <span class="hljs-string">&quot;*.txt&quot;</span> -or -name <span class="hljs-string">&quot;*.log&quot;</span> $<br><span class="hljs-comment">##查找当前目录及其子目录中不属于用户 john 的文件</span><br>find . ! -user john<br></code></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>**<code>-exec</code>**：对找到的每个文件执行指定的命令。</p><ul><li><code>&#123;&#125;</code>：占位符，表示当前找到的文件。</li><li><code>\;</code>：表示 <code>-exec</code> 命令结束。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">##查找当前目录及其子目录中所有 .txt 文件并打印其内容</span><br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">cat</span> &#123;&#125; \;<br><br><span class="hljs-comment">##查找当前目录及其子目录中所有 .txt 文件并删除它们：</span><br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br><span class="hljs-comment">## -ok：与 -exec 类似，但在执行命令前会提示用户确认</span><br>find . -name <span class="hljs-string">&quot;*.txt&quot;</span> -ok <span class="hljs-built_in">rm</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure><h2 id="grep-查找"><a href="#grep-查找" class="headerlink" title="grep 查找"></a>grep 查找</h2><ul><li>主要用于在文件内容中查找特定的文本模式。</li><li>可以在文件中搜索匹配的行。</li><li>适用于文本内容的搜索。</li></ul><h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep [选项] 模式 [文件...]<br></code></pre></td></tr></table></figure><ul><li><strong>模式</strong>：要搜索的文本模式。</li><li><strong>文件</strong>：指定要搜索的文件列表。</li></ul><h4 id="基本搜索"><a href="#基本搜索" class="headerlink" title="基本搜索"></a>基本搜索</h4><p>**<code>-i</code>**：忽略大小写。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -i <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure><p>**<code>-w</code>**：匹配整个单词</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -w <span class="hljs-string">&quot;word&quot;</span> file.txt<br></code></pre></td></tr></table></figure><p>**<code>-x</code>**：匹配整行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -x <span class="hljs-string">&quot;line&quot;</span> file.txt<br></code></pre></td></tr></table></figure><h4 id="显示上下文"><a href="#显示上下文" class="headerlink" title="显示上下文"></a>显示上下文</h4><ul><li><p>**<code>-A n</code>**：显示匹配行及其后的 n 行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -A 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p>**<code>-B n</code>**：显示匹配行及其前的 n 行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -B 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p>**<code>-C n</code>**：显示匹配行及其前后的 n 行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -C 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h4><ul><li><p>**<code>-r</code> 或 <code>-R</code>**：递归搜索目录中的文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -r <span class="hljs-string">&quot;pattern&quot;</span> /path/to/directory<br></code></pre></td></tr></table></figure></li><li><p>**<code>-l</code>**：只输出包含匹配行的文件名。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -l <span class="hljs-string">&quot;pattern&quot;</span> *.txt<br></code></pre></td></tr></table></figure></li><li><p>**<code>-L</code>**：只输出不包含匹配行的文件名。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -L <span class="hljs-string">&quot;pattern&quot;</span> *.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="行号和计数"><a href="#行号和计数" class="headerlink" title="行号和计数"></a>行号和计数</h4><ul><li><p>**<code>-n</code>**：显示匹配行的行号。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -n <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p>**<code>-c</code>**：显示匹配行的数量。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -c <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="反向匹配"><a href="#反向匹配" class="headerlink" title="反向匹配"></a>反向匹配</h4><ul><li><p><code>-v</code></p><p>：反向匹配，显示不包含匹配项的行。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -v <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul><li><p>**<code>-E</code>**：使用扩展正则表达式。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -E <span class="hljs-string">&quot;pattern1|pattern2&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p>**<code>-P</code>**：使用 Perl 兼容正则表达式（PCRE）。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -P <span class="hljs-string">&quot;\d+&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h4><ul><li><p>**<code>--color</code>**：高亮显示匹配的文本。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep --color <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p>**<code>-q</code>**：安静模式，不输出任何内容，只返回状态码。</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -q <span class="hljs-string">&quot;pattern&quot;</span> file.txt &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Pattern found&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><ol><li><p><strong>查找包含特定字符串的行</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep <span class="hljs-string">&quot;hello&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>忽略大小写查找</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -i <span class="hljs-string">&quot;hello&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>递归搜索目录中的文件</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -r <span class="hljs-string">&quot;hello&quot;</span> /path/to/directory<br></code></pre></td></tr></table></figure></li><li><p><strong>显示匹配行的行号</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -n <span class="hljs-string">&quot;hello&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>查找包含多个模式的行</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -E <span class="hljs-string">&quot;pattern1|pattern2&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>查找不包含特定字符串的行</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -v <span class="hljs-string">&quot;hello&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>查找包含特定模式的文件名</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -l <span class="hljs-string">&quot;hello&quot;</span> *.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>查找包含数字的行</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -P <span class="hljs-string">&quot;\d+&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>查找并替换文件中的内容</strong>：</p><p>bash深色版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grep -l <span class="hljs-string">&quot;oldtext&quot;</span> *.txt | xargs sed -i <span class="hljs-string">&#x27;s/oldtext/newtext/g&#x27;</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>常见命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux压缩和解压缩命令</title>
    <link href="/Linux%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <url>/Linux%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>在Linux操作系统中，压缩文件夹是一种非常常见且有用的操作。通过压缩文件夹，可以将多个文件和子文件夹打包成一个压缩文件，从而方便传输、存储和备份。本文将详细介绍如何在Linux中使用不同的命令和工具来压缩文件文件夹。</p><h2 id="2-使用tar命令压缩文件-x2F-文件夹"><a href="#2-使用tar命令压缩文件-x2F-文件夹" class="headerlink" title="2. 使用tar命令压缩文件&#x2F;文件夹"></a>2. 使用tar命令压缩文件&#x2F;文件夹</h2><h3 id="2-1-使用tar命令压缩"><a href="#2-1-使用tar命令压缩" class="headerlink" title="2.1 使用tar命令压缩"></a>2.1 使用tar命令压缩</h3><p>在Linux中，tar命令是一个用于打包文件和目录的常用工具。它可以将多个文件和目录打包成一个压缩文件，并保留文件和目录的层次结构。</p><p>以下是使用tar命令打包文件夹的基本语法：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">tar -cvf 压缩文件名.tar 目录名/<br></code></pre></td></tr></table></figure><ul><li><code>-c</code>：创建一个新的归档文件。</li><li><code>-v</code>：显示处理过程中的详细信息（verbose 模式）。</li><li><code>-f</code>：指定归档文件的名称。</li></ul><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>打包单个文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -cvf myarchive.tar myfile.txt<br></code></pre></td></tr></table></figure><p>打包多个文件和目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -cvf myarchive.tar file1.txt file2.txt directory1/<br></code></pre></td></tr></table></figure><p>打包整个目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -cvf myarchive.tar /path/to/directory<br></code></pre></td></tr></table></figure><p>上面打包后的压缩包都是<code>.tar</code>后缀，不同的后缀表示压缩时候采用了不同的压缩算法。除了<code>.tar</code>后缀，常见的还有<code>tar.gz</code>、<code>.gz</code>、<code>bz2</code>。</p><h4 id="其他常用选项参数"><a href="#其他常用选项参数" class="headerlink" title="其他常用选项参数"></a>其他常用选项参数</h4><ul><li><code>-z</code>：使用gzip压缩归档文件。</li><li><code>-j</code>：使用bzip2压缩归档文件。</li><li><code>-J</code>：使用xz压缩归档文件。</li></ul><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>创建gzip压缩的归档文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -cvzf myarchive.tar.gz file1.txt file2.txt  /path/to/directory<br></code></pre></td></tr></table></figure><p>创建bzip2压缩的归档文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -cjvf myarchive.tar.bz2 file1.txt file2.txt directory1/<br></code></pre></td></tr></table></figure><p>创建xz压缩的归档文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tar -cJvf myarchive<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.xz</span> file1<span class="hljs-selector-class">.txt</span> file2<span class="hljs-selector-class">.txt</span> directory1/<br></code></pre></td></tr></table></figure><h3 id="2-2使用tar命令解压缩"><a href="#2-2使用tar命令解压缩" class="headerlink" title="2.2使用tar命令解压缩"></a>2.2使用tar命令解压缩</h3><h4 id="解压选项参数"><a href="#解压选项参数" class="headerlink" title="解压选项参数"></a>解压选项参数</h4><ul><li><code>-x</code>：解压归档文件。</li></ul><ol><li><p><strong>解压普通的tar文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf myarchive.tar<br></code></pre></td></tr></table></figure></li><li><p><strong>解压gzip压缩的tar文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzvf myarchive.tar.gz<br></code></pre></td></tr></table></figure></li><li><p><strong>解压bzip2压缩的tar文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xjvf myarchive.tar.bz2<br></code></pre></td></tr></table></figure></li><li><p><strong>解压xz压缩的tar文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xJvf myarchive.tar.xz<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3列出归档文件内容"><a href="#2-3列出归档文件内容" class="headerlink" title="2.3列出归档文件内容"></a>2.3列出归档文件内容</h3><ul><li><code>-t</code>：列出归档文件中的内容。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tar</span> -tvf myarchive.tar<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>常见命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-传输层</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="1-传输层的定义"><a href="#1-传输层的定义" class="headerlink" title="1 传输层的定义"></a>1 传输层的定义</h2><p>TCP&#x2F;IP中有两个具有代表性的传输层协议,它们分别是TCP和UDP。TCP在传输层提供<strong>可靠的通信传输</strong>,而UDP在传输层不提供可靠传输，而是尽<strong>最大能力传输</strong>，常被用于让广播和细节控制交给应用的通信传输。总之,根据通信的具体特征,选择合适的传输层协议是非常重要的。</p><p>在网络层提到在IP的首部有一个协议字段，来标识网络层上一层采用的是哪一种传输层协议，这里我们使用WireShark抓取网络数据包，可以看到Protocol：UDP（17），说明这个数据包是使用UDP协议传输。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241109155406.png"><p>TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构,你可以把它想象成排水管道中的水流。当应用程序采用TCP发送消息时,虽然可以保证发送的顺序,但还是犹如没有任何间隔的数据流发送给接收端TCP为提供可靠性传输,实行”顺序控制”或”重发控制”机制。此外还具备”流控制(流量控制)”、”拥塞控制”、提高网络利用率等众多功能。</p><p>UDP是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDP的情况下,虽然可以确保发送消息的大小,却不能保证消息一定会到达。因此,应用有时会根据自己的需要进行重发处理。</p><h3 id="1-1-端口的定义"><a href="#1-1-端口的定义" class="headerlink" title="1.1 端口的定义"></a>1.1 端口的定义</h3><p>在网络层是主机到主机的通信传输，那么到了传输层就是端到端的通信传输，这个端可以可以理解为“逻辑端口”，这个端口并不实际存在，而是我们给主机里面的进程赋予的一段数字，通过端口号，可以准确的找到发送和接收数据的应用（进程）。</p><p>数据链路和IP中的地址,分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机,后者用来识别TCP&#x2F;IP网络中互连的主机和路由器。在传输层中这种类似于地址的概念,那就是端口号。<strong>端口号用来识别同一台计算机中进行通信的不同应用程序。因此,它也被称为程序地址。</strong></p><p>当然仅仅有端口是不够的，我们还需要更加详细的“位置信息”。通常来说，会使用5个信息来识别一个通信，“源IP地址”、”目标IP地址”、”协议号”、”源端口号”、”目标端口号”，5个信息都一致，才认为是同一个通信。</p><p>端口号的长度为16bit，最大可以表示65536个不同的端口号。</p><h3 id="1-2-端口号的区分"><a href="#1-2-端口号的区分" class="headerlink" title="1.2 端口号的区分"></a>1.2 端口号的区分</h3><p>服务端使用的端口号范围：0<del>49151 ，其中0</del>1023属于知名端口号，固定下来给应用协议使用，知名端口号一般由0到1023的数字分配，应用程序应该避免使用知名端口号进行既定目的之外的通信,以免产生冲突。1024~49151就是我们可以给自己的服务进程注册的端口号了。</p><p>客户端使用的端口号范围：49152~65535。和服务端不同，客户端采用了动态分配法，由于这类端口号<strong>仅在客户进程运行时</strong>才动态地选择，因此又称<strong>短暂端口号</strong>（也称临时端口）。通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程以后使用。</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td></tr></tbody></table><h2 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2.UDP"></a>2.UDP</h2><h3 id="2-1-UDP的特点和目的"><a href="#2-1-UDP的特点和目的" class="headerlink" title="2.1 UDP的特点和目的"></a>2.1 UDP的特点和目的</h3><p>UDP是UserDatagramProtocol的缩写。</p><p>UDP不提供复杂的控制机制,利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻,立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下,UDP也<strong>无法进行流量控制等避免网络拥塞</strong>的行为。此外,传输途中即使出现丢包,UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制,那么不得不交由采用UDP的应用程序去处理。UDP有点类似于用户说什么听什么的机制,但是需要用户充分考虑好上层协议类型并制作相应的应用程序。因同此,也可以说,UDP按照”制作程序的那些用户的指示行事”。</p><p>由于UDP<strong>面向无连接</strong>,它可以随时发送数据。再加上UDP本身的处理既简单又高效,因此经常用于以下几个方面:</p><ol><li>包总量较少的通信(DNS、SNMP等)</li><li>视频、音频等多媒体通信(即时通信)</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信(广播、多播)</li></ol><p>总结一下：UDP具有如下特点：</p><ol><li>UDP是无连接的，减少开销和发送数据之前的时延。</li><li>UDP使用最大努力交付，即不保证可靠交付。</li><li>UDP是面向报文的，适合一次性传输少量数据的网络应用，</li><li>UDP无拥塞控制，适合很多实时应用。</li><li>分组首部开销小。TCP有20B的首部开销，而UDP仅有8B的开销。</li><li>UDP支持一对一、一对多、多对一和多对多的交互通信。</li></ol><h3 id="2-2-UDP报文格式"><a href="#2-2-UDP报文格式" class="headerlink" title="2.2 UDP报文格式"></a>2.2 UDP报文格式</h3><p>UDP数据报包含两部分：UDP首部和用户数据。UDP首部和用户数据。UDP首部有8B，由4个字段组成，每个字段的长度都是2B。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241109164105.png"><p><strong>源端口：</strong>源端口号。在需要对方回信时选用，不需要时可用全0。<br><strong>目的端口：</strong>目的端口号。这在终点交付报文时必须使用到。<br><strong>长度：</strong>单位字节，UDP数据报的长度（包括首部和数据），其最小值是8（仅有首部）。<br><strong>校验和：</strong>检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0。</p><p>在计算校检和时，要在UDP用户数据报之前增加12字节的****伪首部****。校检和就是按照这个临时的UDP用户数据报来计算的。这个伪首部的作用就是计算校验和，它既向上传递也不向下封装。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241109165435.png"><h4 id="扩展：UDP的校验和计算"><a href="#扩展：UDP的校验和计算" class="headerlink" title="扩展：UDP的校验和计算"></a>扩展：UDP的校验和计算</h4><p>UDP校验和的计算方法和IP数据报首部校验和的计算方法相似。但不同的是，IP数据报的校验和<strong>只检验IP数据报的首部</strong>，但UDP的校验和则<strong>检查首部和数据部分</strong>。</p><p>发送方首先把全零放入校验和字段并添加伪首部，然后把UDP数据报视为许多16位的字串接起来。<br>若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾填入一个全零字节（但此字节不发送）。<br>然后按二进制反码计算出这些16位字的和，将此和的二进制反码写入校验和字段，并发送。<br>接收方把收到的UDP数据报加上伪首部（如果不为偶数个字节，那么还需要补上全零字节）后，按二进制反码求这些16位字的和。<br>当无差错时其结果应为全1，否则就表明有差错出现，接收方就应该丢弃这个UDP数据报。</p><blockquote><p>计算UDP检验和的例子：</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241109170924.png"><p>二进制反码运算求和：将所有的字相加，如果相加过程中最高位产生了进位，就将进位加到最低位上，这叫做回卷。</p></blockquote><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3.TCP"></a>3.TCP</h2><h3 id="3-1TCP协议的特点和目的"><a href="#3-1TCP协议的特点和目的" class="headerlink" title="3.1TCP协议的特点和目的"></a>3.1TCP协议的特点和目的</h3><p>为了通过IP数据报实现可靠性传输,需要考虑很多事情,例如数据的破坏丢包、重复以及分片顺序混乱等问题。如不能解决这些问题,也就无从谈起可靠传输。<br>TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><p>TCP的任务是在IP层不可靠的、尽力而为服务的基础上建立一种可靠数据传输服务。</p><p>主要特点如下：</p><ol><li><p>TCP是面向连接（虚连接）的传输层协议</p></li><li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</p></li><li><p>TCP 提供可靠交付的服务，保证传送的数据无差错、不丢失、不重复且有序</p></li><li><p>TCP提供全双工通信，两端都有发送缓存和接受缓存。</p><p>发送缓存用来暂时存放以下数据：①发送应用程序传送给发送方TCP准备发送的数据；②TCP已发送但尚未收到确认的数据。</p><p>接收缓存用来暂时存放以下数据：①按序到达但尚未被接收应用程序读取的数据；②不按序到达的数据。</p></li><li><p>TCP是面向字节流的。虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p></li></ol><h3 id="3-2TCP的报文段"><a href="#3-2TCP的报文段" class="headerlink" title="3.2TCP的报文段"></a>3.2TCP的报文段</h3><p>TCP传送的数据单元称为<strong>报文段</strong>。TCP报文段既可以用来<strong>运载数据</strong>，又可以用来<strong>建立连接</strong>、<strong>释放连接</strong>和<strong>应答</strong>。</p><p>一个TCP报文段分为<strong>首部和数据</strong>两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中，其首部的前20B是固定的。TCP首部最短为20B，后面有4N字节是根据需要而增加的选项，长度为4B的整数倍。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241109171601.png"><ol><li><p>源端口和目的端口：各占2字节，分别写入源端口号和目的端口号</p></li><li><p>序号：占4个字节，TCP是面向字节流的传输，里面的每一个字节都会进行编号，该字段表示本报文段所发送数据的第一个字节的序号。</p></li><li><p>确认号：占4个字节，期望收到对方下一个报文段的第一个数据字节的序号，若确认号为N，则表示到N-1为止的所有的数据都已经正确收到。</p></li><li><p>数据偏移：也就是首部长度。占4个bit，TCP报文段的数据的起始位置距离TCP报文段的起始位置由多远，一个数值的单位是4B，4位二进制数能够表示的最大十进制数字是15，那么数据偏移的最大值为60字节。<strong>TCP首部的最大长度</strong>：60字节。<strong>选项部分的最大长度</strong>：40字节。</p></li><li><p>保留：占6位，保留为今后使用，但目前应置为0。</p></li><li><p>控制位：占6位。</p><ol><li>紧急位URG：URG&#x3D;1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</li><li>确认位ACK：ACK&#x3D;1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li><li>推送位PSH：PSH&#x3D;1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li>复位RST：RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li>同步位SYN：SYN&#x3D;1时，表明是一个连接请求&#x2F;连接接受报文。</li><li>终止位FIN：FIN&#x3D;1时，表明此报文段发送方数据已发完，要求释放连接</li></ol></li><li><p>窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。</p></li><li><p>检验和：检验首部+数据，检验时要加上12B伪首部，第四个字段为6。（UDP是17）</p></li><li><p>紧急指针：URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数（紧急数据在报文段数据的最前面）。</p></li><li><p>选项：长度可变。最大报文段长度MSS、窗口扩大、时间戳、选择确认。</p></li><li><p>填充：这是为了使整个首部长度是4B的整数倍。</p></li></ol><h3 id="3-3-TCP可靠传输"><a href="#3-3-TCP可靠传输" class="headerlink" title="3.3 TCP可靠传输"></a>3.3 TCP可靠传输</h3><p>什么是可靠？</p><p><strong>可靠</strong>，指的是保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。</p><h4 id="3-3-1-通过序列号与确认应答提高可靠性"><a href="#3-3-1-通过序列号与确认应答提高可靠性" class="headerlink" title="3.3.1 通过序列号与确认应答提高可靠性"></a>3.3.1 通过序列号与确认应答提高可靠性</h4><p>在TCP中,当发送端的数据到达接收主机时,接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答(ACK）。在一定时间内没有等到确认应答,发送端就可以认为数据已经丢失,并进行重发。由此,即使产生了丢包,仍然能够保证数据能够到达对端,实现可靠传输。</p><p><strong>通过ACK确认的方式，保证服务端能收到客户端发送的每一个报文段。</strong></p><p>TCP通过肯定的确认应答(ACK)实现可靠的数据传输。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答,说明数据已经成功到达对端。反之,则数据丢失的可能性很大。</p><p>为什么是可能是数据丢失？因为存在服务端已经收到了数据并且发送了ACK，但是客户端没有收到，这时候客户端会误认为丢失，重新发送相同的数据。也有可能因为通信问题导致ACK延迟到达，在源主机重发数次之后才姗姗来迟，这种情况对于目标主机来说，简直是一场灾难，因为要对上层应用提供可靠的传输,必须得放弃重复的数据包，这造成了资源的极大浪费。</p><p>为了解决上述的问题，TCP再次引入了序列号的机制。<strong>给每一字节的数据都进行编号</strong>。接收端查询接收数据TCP首部中的序列号和数据的长度,将自己下一步应该接收的序号作为确认应答返送回去。就这样,通过序列号和确认应答号,TCP可以实现可靠传输。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241108232020.png"><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241109115755.png"><h4 id="3-3-2重发超时如何确定"><a href="#3-3-2重发超时如何确定" class="headerlink" title="3.3.2重发超时如何确定"></a>3.3.2重发超时如何确定</h4><p>有两种事件会导致TCP对报文段进行重传：超时和冗余ACK。</p><ol><li>超时重传</li></ol><p>​TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。TCP采用自适应算法，动态改变重传时间RTTs（加权平均往返时间）</p><ol start="2"><li>冗余ACK（冗余确认）</li></ol><p>​TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。当发送方收到对同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报丈段之后的报文段已经丢失。</p><p>​发送方已发送1，2，3，4，5报文段</p><blockquote><p>接收方收到1，返回给1的确认（确认号为2的第一个字节）<br>接收方收到3，仍返回给1的确认（确认号为2的第一个字节）<br>接收方收到4，仍返回给1的确认（确认号为2的第一个字节）<br>接收方收到5，仍返回给1的确认（确认号为2的第一个字节）<br>发送方收到3个对于报文段1的冗余ACK，认为2报文段丢失，重传2号报文段。</p></blockquote><h3 id="3-4TCP的连接管理"><a href="#3-4TCP的连接管理" class="headerlink" title="3.4TCP的连接管理"></a>3.4TCP的连接管理</h3><p>TCP是面向连接的协议，因此每个TCP连接都有三个阶段：连接建立、数据传送和连接释放。可以使用TCP首部用于控制的字段来管理TCP连接 。一个连接的建立与断开,正常过程至少需要来回发送7个包才能完成。</p><h4 id="3-4-1三次握手建立连接"><a href="#3-4-1三次握手建立连接" class="headerlink" title="3.4.1三次握手建立连接"></a>3.4.1三次握手建立连接</h4><ol><li><p>客户向服务器发送连接请求段，建立连接请求控制段（SYN&#x3D;1），表示传输的报文段的第一个数据字节的序列号是x，此序列号代表整个报文段的序号（seq&#x3D;x）；客户端进入 SYN_SEND （同步发送状态）；</p></li><li><p>服务器发回确认报文段，同意建立新连接的确认段（SYN&#x3D;1），确认序号字段有效（ACK&#x3D;1），服务器告诉客户端报文段序号是y（seq&#x3D;y），表示服务器已经收到客户端序号为x的报文段，准备接受客户端序列号为x+1的报文段（ack_seq&#x3D;x+1）；服务器由LISTEN进入SYN_RCVD （同步收到状态）;</p></li><li><p>客户对服务器的同一连接进行确认.确认序号字段有效(ACK&#x3D;1),客户此次的报文段的序列号是x+1(seq&#x3D;x+1),客户期望接受服务器序列号为y+1的报文段(ack_seq&#x3D;y+1);当客户发送ack时，客户端进入ESTABLISHED 状态;当服务收到客户发送的ack后，也进入ESTABLISHED状态;第三次握手可携带数据;</p></li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241110022427.png"><h5 id="细节问题："><a href="#细节问题：" class="headerlink" title="细节问题："></a>细节问题：</h5><ol><li><p>为什么要第三次确认？</p><p>是为了防止失效的连接请求又传送到了服务端，导致出现错误。防止第一次发送的连接请求报文段滞后到达，A在接收到B的确认就开始传送数据，而B确以为建立了新的连接而无法接收，导致数据丢失。</p></li><li><p>什么是SYN洪范攻击？</p><p>SYN洪泛攻击的原理和过程如下：</p><ol><li>攻击者向服务器发送大量的SYN数据包，请求建立连接，但是故意伪造或随机生成源IP地址，使服务器无法回复。</li><li>服务器收到SYN数据包后，回复SYN-ACK数据包，并为每个连接分配一个缓冲区，等待客户端的ACK数据包，进入SYN-RCVD状态。</li><li>由于源IP地址是伪造或随机的，服务器无法收到客户端的ACK数据包，导致缓冲区被占用，无法处理其他的连接请求。</li><li>当缓冲区满了后，服务器就无法接受新的连接请求，从而拒绝服务。</li></ol><p>解决办法：设置SYN cookie，即在回复SYN-ACK数据包时，不分配缓冲区，而是将一些信息编码在序列号中，等到收到ACK数据包时再解码恢复。</p></li></ol><h4 id="3-4-2四次挥手断开连接"><a href="#3-4-2四次挥手断开连接" class="headerlink" title="3.4.2四次挥手断开连接"></a>3.4.2四次挥手断开连接</h4><ol><li><p>客户向服务器发送释放连接报文段，发送端数据发送完毕，请求释放连接（FIN&#x3D;1），传输的第一个数据字节的序号是x（seq&#x3D;x，它等于前面已传送过的数据的最后一个字节的序号加1）；客户端状态由ESTABLISHED进入FIN_WAIT_1（终止等待1状态）；</p></li><li><p>服务器向客户发送确认段，确认字号段有效（ACK&#x3D;1），服务器传输的数据序号是y（seq&#x3D;y），服务器期望接收客户数据序号为x+1（ack_seq&#x3D;x+1）;服务器状态由ESTABLISHED进入CLOSE_WAIT（关闭等待）； 客户端收到ACK段后，由FIN_WAIT_1进入FIN_WAIT_2；</p><blockquote><p><strong>服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。</strong></p></blockquote></li><li><p>服务器向客户发送释放连接报文段，请求释放连接（FIN&#x3D;1），确认字号段有效（ACK&#x3D;1），表示服务器期望接收客户数据序号为x+1（ack_seq&#x3D;x+1）;表示自己传输的第一个字节序号是y+1（seq&#x3D;y+1）；服务器状态由CLOSE_WAIT 进入 LAST_ACK （最后确认状态）；</p></li><li><p>客户向服务器发送确认段，确认字号段有效（ACK&#x3D;1），表示客户传输的数据序号是x+1（seq&#x3D;x+1），表示客户期望接收服务器数据序号为y+1+1（ack_seq&#x3D;y+1+1）；客户端状态由FIN_WAIT_2进入TIME_WAIT，等待2MSL时间，进入CLOSED状态；服务器在收到最后一次ACK后，由LAST_ACK进入CLOSED；</p></li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241110023931.png"><h5 id="细节问题：-1"><a href="#细节问题：-1" class="headerlink" title="细节问题："></a>细节问题：</h5><ol><li><p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？</p><ul><li><p>第一，为了保证A发送的最后一个ACK报文段能够到达B。</p></li><li><p>第二，防止“已失效的连接请求报文段”出现在本连接中。</p></li></ul></li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241110025351.png"><h3 id="3-5-TCP的流量控制"><a href="#3-5-TCP的流量控制" class="headerlink" title="3.5 TCP的流量控制"></a>3.5 TCP的流量控制</h3><p>TCP提供<strong>流量控制</strong>服务来消除<strong>发送方（发送速率太快）使接收方缓存区溢出</strong>的可能性。TCP提供一种<strong>基于滑动窗口协议</strong>的流量控制机制。</p><p><strong>滑动窗口</strong>：</p><ul><li><strong>接收窗口rwnd</strong>：接收端维护，接收端当前的<strong>接收缓存大小</strong>。</li><li><strong>拥塞窗口cwnd</strong>：发送端维护，发送端根据当前网络的<strong>拥塞程度</strong>而确定的<strong>窗口值</strong>。</li><li><strong>发送窗口</strong>：由发送端维护，发送端在接收到下一个确认前能够发送的最大字节数。</li><li>发送窗口&#x3D;min（接收窗口，拥塞窗口）</li></ul><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），</p><p>发送方的<strong>发送窗口</strong>取接收窗口rwnd和拥塞窗口cwnd的最小值。TCP的窗口单位是<strong>字节</strong>，不是报文段。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241111212346.png"><p>如上图所示，设A向B发送数据。在连接建立时，B的接收窗口rwnd&#x3D;400。接收方主机B进行了三次流量控制，这三个报文段都设置了ACK&#x3D;1，只有在ACK&#x3D;1时确认号字段才有意义。第一次把窗口减小到rwnd&#x3D;300，第二次又减到rwnd&#x3D;100，最后减到rwnd&#x3D;0，即不允许发送方再发送数据。这使得发送方暂停发送的状态将持续到B重新发出一个新的窗口值为止。</p><p>传输层和数据链路层的流量控制的区别是：</p><p>传输层定义端到端用户之间的流量控制，数据链路层定义两个中间的相邻结点的流量控制。<br>数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的则可以动态变化。</p><h3 id="3-6TCP的拥塞控制"><a href="#3-6TCP的拥塞控制" class="headerlink" title="3.6TCP的拥塞控制"></a>3.6TCP的拥塞控制</h3><p>拥塞控制是指<strong>防止过多的数据注入网络</strong>，保证网络中的路由器或链路不致过载，是全局性过程。出现拥塞时，端点并不了解拥塞发生的细节，对通信连接的端点来说，<strong>拥塞往往表现为通信时延的增加</strong>。<br>$$<br>发送窗口的上限值&#x3D;min[rwnd，cwnd]<br>$$<br>因特网建议标准定义了进行拥塞控制的4种算法：慢开始、拥塞避免、快重传和快恢复。</p><h4 id="3-6-1-慢开始和拥塞避免"><a href="#3-6-1-慢开始和拥塞避免" class="headerlink" title="3.6.1.慢开始和拥塞避免"></a>3.6.1.慢开始和拥塞避免</h4><p><strong>慢开始：</strong></p><ol><li>先令拥塞窗口cwnd&#x3D;1（即一个<strong>最大报文段长度MSS</strong>）。</li><li>在<strong>每收到一个对新的报文段的确认</strong>后，将cwnd加1，即增大一个MSS（<strong>拥塞窗口加倍</strong>）。</li></ol><p><strong>拥塞避免</strong>：</p><ol><li>发送端的<strong>拥塞窗口cwnd</strong>每经过一个往返时延RTT就<strong>增加一个MSS</strong>的大小，而不是加倍，使cwnd按<strong>线性规律缓慢增长</strong>（即加法增大）</li><li>当出现一次超时（网络拥塞）时，则令<strong>慢开始门限ssthresh</strong>等于<strong>当前cwnd的一半</strong>（即乘法减小）</li></ol><p>根据cwnd的大小执行不同的算法，可归纳如下：</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当cwnd&#x3D;ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法（通常做法）。</li></ul><p>网络拥塞处理</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241111213353.png"><p>① 执行慢开始算法，拥塞窗口cwnd置为1，每收到一个ACK，cwnd加1，即每个轮次拥塞窗口翻倍。</p><p>② 达到ssthresh初始值16，执行拥塞避免算法，每个轮次拥塞窗口加1。</p><p>③ 在cwnd达到24时，出现超时，发送方判断网络拥塞；调整门限ssthresh为12，cwnd置1，重新慢开始。当拥塞窗口到达12时，开始执行拥塞避免。</p><p> 当网络出现拥塞时，无论在什么阶段，只要发送方检测到超时事件的发生（没有按时收到确认。重传计时器超时），就要把慢开始门限ssthresh设置为出现拥塞时的发送方cwnd值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p><h4 id="3-6-2-快重传和快恢复"><a href="#3-6-2-快重传和快恢复" class="headerlink" title="3.6.2 快重传和快恢复"></a>3.6.2 快重传和快恢复</h4><p>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p><ul><li><strong>快重传</strong>：收到3个重复的确认执行快重传算法。</li><li><strong>快恢复</strong>：当发送端收到连续三个冗余ACK时，就执行“乘法减小”算法，把慢开始门限ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始（将拥塞窗口cwnd设置为1）不同之处是它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法（加法增大），使拥塞窗口缓慢地线性增大。</li></ul><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241111213649.png"><p>在流量控制中，发送方发送数据的量由<strong>接收方</strong>决定，而在拥塞控制中，则由发送方自己通过<strong>检测网络状况来决定</strong>。实际上，慢开始、拥塞避免、快重传和快恢复几种算法是<strong>同时应用在拥塞控制机制</strong>中。</p><p>四种算法使用的<strong>总结</strong>：</p><ul><li>在TCP连接建立和网络出现超时时，采用慢开始和拥塞避免算法；</li><li>当发送方接收到冗余ACK时，采用快重传和快恢复算法。</li></ul><h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><p><a href="https://blog.csdn.net/weixin_43871760/article/details/90446494">UDP协议抓包分析</a></p><p>[Wireshark 分析用户数据报UDP](<a href="https://blog.csdn.net/dengjili/article/details/108549620">Wireshark 分析用户数据报UDP_wiresharkudp报文分析-CSDN博客</a>)</p><p><a href="https://blog.csdn.net/wb1046329430/article/details/115211645">Windows 系统下查找进程号和端口号</a></p><p><a href="https://wiki.wireshark.org/SampleCaptures?action=AttachFile&do=get&target=tpncp_udp.pcap#udp-lite">SampleCaptures （样本捕获）</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RemoteCallbackList分析</title>
    <link href="/RemoteCallbackList%E5%88%86%E6%9E%90/"/>
    <url>/RemoteCallbackList%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>对于<code>RemoteCallbackList</code>的使用，本博客不再介绍。网上很多博客都有相关的描述。本文主要是对我们为什么要这样或者那样去使用<code>RemoteCallbackList</code>做一个分析，学习一下源码时怎么封装的</p><p>首先带着几个问题去学习会更加深刻：</p><ol><li>为什么<code>beginBroadcast</code>和<code>finishBroadcast</code>要成对使用？</li><li>为什么我们使用<code>RemoteCallbackList</code>中的<code>unregister</code>能移除监听，我们自己写的普通的ArrayList存放监听回调后，移除没有效果？</li><li>怎么更好的使用<code>RemoteCallbackList</code>，有哪些需要注意的地方吗？</li></ol><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><p>为什么我们使用<code>RemoteCallbackList</code>中的<code>unregister</code>能移除监听，我们自己写的普通的ArrayList存放监听回调后，移除没有效果，就需要去看<code>RemoteCallbackList</code>是怎么管理监听回调的</p><p>首先看一下里面定义的全局变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayMap&lt;IBinder, Callback&gt; mCallbacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;IBinder, Callback&gt;();<span class="hljs-comment">//来维护每个IBinder与Callback的对应,</span><br><span class="hljs-keyword">private</span> Object[] mActiveBroadcast;<span class="hljs-comment">//一个数组对象？</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mBroadcastCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//广播数量？   </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">mKilled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">private</span> StringBuilder mRecentCallers;<br></code></pre></td></tr></table></figure><p>下面就是我们使用的<code>register</code>方法,可以选择传一或两个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">register</span><span class="hljs-params">(E callback)</span> &#123;<br>    <span class="hljs-keyword">return</span> register(callback, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">register</span><span class="hljs-params">(E callback, Object cookie)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mCallbacks) &#123;<br>        <span class="hljs-keyword">if</span> (mKilled) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// Flag unusual case that could be caused by a leak. b/36778087</span><br>        logExcessiveCallbacks();<br>        <span class="hljs-type">IBinder</span> <span class="hljs-variable">binder</span> <span class="hljs-operator">=</span> callback.asBinder();<span class="hljs-comment">//取到了Binder对象</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Callback</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>(callback, cookie);<span class="hljs-comment">//将传入的信息封装进Callback对象</span><br>            unregister(callback);<span class="hljs-comment">//避免重复注册</span><br>            binder.linkToDeath(cb, <span class="hljs-number">0</span>);<span class="hljs-comment">//注册一个死亡监听器</span><br>            mCallbacks.put(binder, cb);<span class="hljs-comment">//将我们封装的Callback对象和binder存放进ArrayMap</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里一个需要关注的点是<code>Callback</code>类，下面的注释很清晰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Callback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBinder</span>.DeathRecipient &#123;<br>    <span class="hljs-keyword">final</span> E mCallback;<span class="hljs-comment">//回调</span><br>    <span class="hljs-keyword">final</span> Object mCookie;<span class="hljs-comment">//回调的关联信息</span><br><br>    Callback(E callback, Object cookie) &#123;<br>        mCallback = callback;<br>        mCookie = cookie;<br>    &#125;<br>    <span class="hljs-comment">//实现了binderDied方法，当binder死亡时，会ArratMap中移除mCallback.asBinder()对应的键值对。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">binderDied</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (mCallbacks) &#123;<br>            mCallbacks.remove(mCallback.asBinder());<br>        &#125;<br>        onCallbackDied(mCallback, mCookie);<span class="hljs-comment">//当我们继承RemoteCallbackList时，可以重写这个方法，对死亡的监听进行处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unregister</code>的实现逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unregister</span><span class="hljs-params">(E callback)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mCallbacks) &#123;<br>        <span class="hljs-type">Callback</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> mCallbacks.remove(callback.asBinder());<span class="hljs-comment">//ArratMap中移除mCallback.asBinder()对应的键值对</span><br>        <span class="hljs-keyword">if</span> (cb != <span class="hljs-literal">null</span>) &#123;<br>            cb.mCallback.asBinder().unlinkToDeath(cb, <span class="hljs-number">0</span>);<span class="hljs-comment">//解除Binder死亡监听</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>在客户端调用unregister方法，如果我们是使用普通的<code>ArrayList</code>存放，大概率会使用<code>list.remove(listener)</code>,当然这种方式并不能移除监听，思考一个问题：客户端传过来的listener还是原来的listener对象吗？IPC通信是有一个序列化的过程的，序列化前和序列化后的对象并不是同一个对象。</p><p>那么<code>RemoteCallbackList</code>是怎么解决这个问题的呢？是Binder对象。<code>IBinder binder = callback.asBinder();</code>虽然回调对象都是新生成的，但是他们底层的binder对象还是同一个，利用这个特性，<code>RemoteCallbackList</code>再自身维护的ArrayMap中移除我们指定的对象。</p><p>当然可以看到存放进ArrayMap中的每一个对象里都注册了死亡监听，当Binder失效的时候，会帮我们自动移除listener。</p><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><p>为什么<code>beginBroadcast</code>和<code>finishBroadcast</code>要成对使用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">beginBroadcast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mCallbacks) &#123;<br>        <span class="hljs-comment">// 检查是否已经在广播过程中，如果是，抛出异常</span><br>        <span class="hljs-keyword">if</span> (mBroadcastCount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    <span class="hljs-string">&quot;beginBroadcast() called while already in a broadcast&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置当前广播计数，并获取回调对象的数量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> mBroadcastCount = mCallbacks.size();<br>        <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 检查并更新当前激活的广播数组</span><br>        Object[] active = mActiveBroadcast;<br>        <span class="hljs-keyword">if</span> (active == <span class="hljs-literal">null</span> || active.length &lt; N) &#123;<br>            mActiveBroadcast = active = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[N];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>            active[i] = mCallbacks.valueAt(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> N;<br>  <br></code></pre></td></tr></table></figure><p>可以看到在开始广播后，将所有的回调都存放进了一个数组，我们最后是去取数组中的listener对象进行通知，这样的原因是：</p><p>数组的访问速度比 ArrayMap 更快，特别是在频繁访问的情况下。这里通过将 ArrayMap 中的值复制到数组中，可以减少在广播过程中对 ArrayMap 的多次访问，提高性能。</p><p>其次在我们开始广播后，就确定了要通知的listener对象，避免在多线程环境下对 ArrayMap 的并发修改问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishBroadcast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mCallbacks) &#123;<br>        <span class="hljs-keyword">if</span> (mBroadcastCount &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    <span class="hljs-string">&quot;finishBroadcast() called outside of a broadcast&quot;</span>);<br>        &#125;<br>        Object[] active = mActiveBroadcast;<br>        <span class="hljs-keyword">if</span> (active != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> mBroadcastCount;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>                active[i] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//重置</span><br>            &#125;<br>        &#125;<br>        mBroadcastCount = -<span class="hljs-number">1</span>;<span class="hljs-comment">//重置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看了上面的源码，也就明白为什么要成对使用<code>beginBroadcast</code>和<code>finishBroadcast</code>了。为了确保线程安全，当确定要IPC通信时，会把要通知的对象放到数组里面，那么当我们通信结束，自然也得清空数组里面的数据。</p><h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h2><p>怎么更好的使用<code>RemoteCallbackList</code>，有哪些需要注意的地方吗？</p><p>总结以下几点：</p><ol><li>可以继承<code>RemoteCallbackList</code>，比如实现<code>onCallbackDied</code>方法，处理Binder死亡情况进一步处理。</li><li>一次只能有一对<code>beginBroadcast</code>和<code>finishBroadcast</code>，所以要避免通知调用，或者加锁</li><li>register(E callback, Object cookie) 可以携带一些关键信息，比如客户端的包名，方便我们定位</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>IPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler分析(转载)</title>
    <link href="/Handler%E5%88%86%E6%9E%90-%E8%BD%AC%E8%BD%BD/"/>
    <url>/Handler%E5%88%86%E6%9E%90-%E8%BD%AC%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做 Android 开发肯定离不开跟 Handler 打交道，它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。</p><p>可以说<strong>只要有异步线程与主线程通信的地方就一定会有 Handler</strong>。</p><p>那么，Handler 的通信机制的背后的原理是什么？</p><p>本文带你揭晓。</p><p><strong>注意：本文所展示的系统源码基于 Android-27 ，并有所删减。</strong></p><h3 id="1-重识-Handler"><a href="#1-重识-Handler" class="headerlink" title="1. 重识 Handler"></a>1. 重识 Handler</h3><p>我们可以使用 Handler <strong>发送并处理</strong>与一个线程关联的 Message 和 Runnable 。（注意：<strong>Runnable 会被封装进一个 Message，所以它本质上还是一个 Message</strong> ）</p><p>每个 Handler 都会跟一个线程绑定，并与该线程的 MessageQueue 关联在一起，从而实现消息的管理以及线程间通信。</p><h4 id="1-1-Handler-的基本用法"><a href="#1-1-Handler-的基本用法" class="headerlink" title="1.1 Handler 的基本用法"></a>1.1 Handler 的基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">android.os.<span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>()&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Message msg)</span> &#123;<br>    <span class="hljs-comment">//这里接受并处理消息</span><br>  &#125;<br>&#125;;<br><span class="hljs-comment">//发送消息</span><br>handler.sendMessage(message);<br>handler.post(runnable);<br></code></pre></td></tr></table></figure><p>实例化一个 Handler 重写 <code>handleMessage</code> 方法 ，然后在需要的时候调用它的 <code>send</code> 以及 <code>post</code> <strong>系列方法</strong>就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档）</p><p>但是奇怪，<strong>我们并没有看到任何 MessageQueue 的身影，也没看到它与线程绑定的逻辑，这是怎么回事</strong>？</p><h3 id="2-Handler-原理解析"><a href="#2-Handler-原理解析" class="headerlink" title="2. Handler 原理解析"></a>2. Handler 原理解析</h3><p>相信大家早就听说过了 Looper 以及 MessageQueue 了，我就不多绕弯子了。</p><p>不过在开始分析原理之前，先<strong>明确我们的问题</strong>：</p><ol><li><strong>Handler 是如何与线程关联的？</strong></li><li><strong>Handler 发出去的消息是谁管理的？</strong></li><li><strong>消息又是怎么回到 handleMessage() 方法的？</strong></li><li><strong>线程的切换是怎么回事？</strong></li></ol><h4 id="2-1-Handler-与-Looper-的关联"><a href="#2-1-Handler-与-Looper-的关联" class="headerlink" title="2.1 Handler 与 Looper 的关联"></a>2.1 Handler 与 Looper 的关联</h4><p>实际上我们在实例化 Handler 的时候 Handler 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说<strong>在创建 Handler 之前一定需要先创建 Looper</strong> 。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>        <span class="hljs-comment">//检查当前的线程是否有 Looper</span><br>        mLooper = Looper.myLooper();<br>        <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                <span class="hljs-string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//Looper 持有一个 MessageQueue</span><br>        mQueue = mLooper.mQueue;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个异常相信很多同学遇到过，而我们平时直接使用感受不到这个异常是因为主线程已经为我们创建好了 Looper，先记住，后面会讲。</p><p>一个完整的 Handler 使用例子其实是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LooperThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> Handler mHandler;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        Looper.prepare();<br>        mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>                <span class="hljs-comment">// process incoming messages here</span><br>            &#125;<br>        &#125;;<br>        Looper.loop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Looper.prepare() :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Looper</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>  <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>  &#125;<br>  sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>Looper 提供了 <code>Looper.prepare()</code> 方法来创建 Looper ，并且会<strong>借助 ThreadLocal 来实现与当前线程的绑定</strong>功能。<strong>Looper.loop() 则会开始不断尝试从 MessageQueue 中获取 Message , 并分发给对应的 Handler（见【2.3】）</strong>。</p><p><strong>也就是说 Handler 跟线程的关联是靠 Looper 来实现的。</strong></p><h4 id="2-2-Message-的存储与管理"><a href="#2-2-Message-的存储与管理" class="headerlink" title="2.2 Message 的存储与管理"></a>2.2 Message 的存储与管理</h4><p>Handler 提供了一些列的方法让我们来发送消息，如 send()系列 post()系列 。</p><p>不过不管我们调用什么方法，最终都会走到 <code>MessageQueue.enqueueMessage(Message,long)</code> 方法。</p><p>以 <code>sendEmptyMessage(int)</code> 方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Handler</span><br>sendEmptyMessage(<span class="hljs-type">int</span>)<br>  -&gt; sendEmptyMessageDelayed(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)<br>    -&gt; sendMessageAtTime(Message,<span class="hljs-type">long</span>)<br>      -&gt; enqueueMessage(MessageQueue,Message,<span class="hljs-type">long</span>)<br>              -&gt; queue.enqueueMessage(Message, <span class="hljs-type">long</span>);<br></code></pre></td></tr></table></figure><p><strong>到了这里，消息的管理者 MessageQueue 也就露出了水面</strong>。<br>MessageQueue 顾明思议，就是个队列，负责消息的入队出队。</p><h4 id="2-3-Message-的分发与处理"><a href="#2-3-Message-的分发与处理" class="headerlink" title="2.3 Message 的分发与处理"></a>2.3 Message 的分发与处理</h4><p>了解清楚 Message 的发送与存储管理后，就该揭开分发与处理的面纱了。</p><p>前面说到了 <code>Looper.loop()</code> 负责对消息的分发，本章节进行分析。</p><p>先来看看所涉及到的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Looper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>       <span class="hljs-comment">// 不断从 MessageQueue 获取 消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>        <span class="hljs-comment">//退出 Looper </span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            msg.target.dispatchMessage(msg);<br>            end = (slowDispatchThresholdMs == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : SystemClock.uptimeMillis();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//...</span><br>        &#125;<br>        <span class="hljs-comment">//...</span><br>                <span class="hljs-comment">//回收 message, 见【3.5】</span><br>        msg.recycleUnchecked();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>loop()</code> 里调用了 <code>MessageQueue.next()</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MessageQueue</span><br>Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//...</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-comment">//...</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Got a message.</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// No more messages.</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Run the idle handlers. 关于 IdleHandler 自行了解</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还调用了 <code>msg.target.dispatchMessage(msg)</code> ，msg.target 就是发送该消息的 Handler，这样就回调到了 Handler 那边去了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Handler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>  <span class="hljs-comment">//msg.callback 是 Runnable ，如果是 post方法则会走这个 if</span><br>  <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>    handleCallback(msg);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//callback 见【3.4】</span><br>    <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//回调到 Handler 的 handleMessage 方法</span><br>    handleMessage(msg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：dispatchMessage() 方法针对 Runnable 的方法做了特殊处理，如果是 ，则会直接执行 <code>Runnable.run()</code> 。</strong></p><p><strong>分析：</strong>Looper.loop() 是个死循环，会<strong>不断调用 MessageQueue.next() 获取 Message ，并调用 <code>msg.target.dispatchMessage(msg)</code> 回到了 Handler 来分发消息，以此来完成消息的回调</strong>。</p><p><strong>注意：loop()方法并不会卡死主线程，见【6】。</strong></p><p>那么<strong>线程的切换又是怎么回事</strong>呢？<br>很多人搞不懂这个原理，但是其实非常简单，我们将所涉及的方法调用栈画出来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.foo()&#123;<br>    Looper.loop()<br>     -&gt; MessageQueue.next()<br>       -&gt; Message.target.dispatchMessage()<br>        -&gt; Handler.handleMessage()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。</strong></p><p>平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 <code>handleMessage()</code> 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。</p><h4 id="2-3-图解原理"><a href="#2-3-图解原理" class="headerlink" title="2.3 图解原理"></a>2.3 图解原理</h4><p>文字版的原理解析到这里就结束了，如果你看到这里还是没有懂，没关系，我特意给你们准备了些图，配合着前面几个章节，再多看几遍，一定可以吃透。</p><p><img src="/2024/10/22/Handler%E5%88%86%E6%9E%90-%E8%BD%AC%E8%BD%BD/1460000040926513.jpeg" alt="handler-looper-mq.jpg"></p><p><img src="/2024/10/22/Handler%E5%88%86%E6%9E%90-%E8%BD%AC%E8%BD%BD/1460000040926514.jpeg" alt="handler_java.jpg"></p><h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>Handler 的背后有着 Looper 以及 MessageQueue 的协助，三者通力合作，分工明确。</p><p>尝试小结一下它们的职责，如下：</p><ul><li>Looper ：<strong>负责关联线程以及消息的分发</strong>在该线程下**从 MessageQueue 获取 Message，分发给 Handler ；</li><li>MessageQueue ：<strong>是个队列，负责消息的存储与管理</strong>，负责管理由 Handler 发送过来的 Message ；</li><li>Handler : <strong>负责发送并处理消息</strong>，面向开发者，提供 API，并隐藏背后实现的细节。</li></ul><p>对【2】章节提出的问题用一句话总结：</p><p><strong>Handler 发送的消息由 MessageQueue 存储管理，并由 Loopler 负责回调消息到 handleMessage()。</strong></p><p><strong>线程的转换由 Looper 完成，handleMessage() 所在线程由 Looper.loop() 调用者所在线程决定。</strong></p><h3 id="Handler-的延伸"><a href="#Handler-的延伸" class="headerlink" title=". Handler 的延伸"></a>. Handler 的延伸</h3><p>Handler 虽然简单易用，但是要用好它还是需要注意一点，另外 Handler相关 还有些鲜为人知的知识技巧，比如 IdleHandler。</p><p>由于 Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等。</p><p>这些我会讲解一些，我没讲到的可以自行搜索相关内容进行了解。</p><h4 id="3-1-Handler-引起的内存泄露原因以及最佳解决方案"><a href="#3-1-Handler-引起的内存泄露原因以及最佳解决方案" class="headerlink" title="3.1 Handler 引起的内存泄露原因以及最佳解决方案"></a>3.1 Handler 引起的内存泄露原因以及最佳解决方案</h4><p>Handler 允许我们发送<strong>延时消息</strong>，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。</p><p>这个泄露是因为 Message 会持有 Handler，而又因为 <strong>Java 的特性，内部类会持有外部类</strong>，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。</p><p>解决该问题的最有效的方法是：<strong>将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息</strong>。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> WeakReference&lt;HandlerActivity&gt; ref;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeHandler</span><span class="hljs-params">(HandlerActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>(activity);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Message msg)</span> &#123;<br>        <span class="hljs-type">HandlerActivity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> ref.get();<br>        <span class="hljs-keyword">if</span> (activity != <span class="hljs-literal">null</span>) &#123;<br>            activity.handleMessage(msg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>且再在 <code>Activity.onDestroy()</code> 前移除消息，加一层保障：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>  safeHandler.removeCallbacksAndMessages(<span class="hljs-literal">null</span>);<br>  <span class="hljs-built_in">super</span>.onDestroy();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样双重保障，就能完全避免内存泄露了。</p><p><strong>注意：单纯的在 <code>onDestroy</code> 移除消息并不保险，因为 <code>onDestroy</code> 并不一定执行。</strong></p><h4 id="3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？"><a href="#3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？" class="headerlink" title="3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？"></a>3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？</h4><p>前面我们提到了每个Handler 的线程都有一个 Looper ，主线程当然也不例外，但是我们不曾准备过主线程的 Looper 而可以直接使用，这是为何？</p><p><strong>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以吧，我觉得把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</strong></p><p>在 ActivityThread.main() 方法中有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//android.app.ActivityThread</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  Looper.prepareMainLooper();<br><br>  <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>  thread.attach(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>    sMainThreadHandler = thread.getHandler();<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  Looper.loop();<br><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Looper.prepareMainLooper(); 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initialize the current thread as a looper, marking it as an</span><br><span class="hljs-comment"> * application&#x27;s main looper. The main looper for your application</span><br><span class="hljs-comment"> * is created by the Android environment, so you should never need</span><br><span class="hljs-comment"> * to call this function yourself.  See also: &#123;<span class="hljs-doctag">@link</span> #prepare()&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMainLooper</span><span class="hljs-params">()</span> &#123;<br>    prepare(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>        <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The main Looper has already been prepared.&quot;</span>);<br>        &#125;<br>        sMainLooper = myLooper();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<strong>在 ActivityThread 里 调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper ,并且调用了 loop() 方法</strong>，所以我们就可以直接使用 Handler 了。</p><p><strong>注意：<code>Looper.loop()</code> 是个死循环，后面的代码正常情况不会执行。</strong></p><h4 id="3-3-主线程的-Looper-不允许退出"><a href="#3-3-主线程的-Looper-不允许退出" class="headerlink" title="3.3 主线程的 Looper 不允许退出"></a>3.3 主线程的 Looper 不允许退出</h4><p>如果你尝试退出 Looper ，你会得到以下错误信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.<br>  at android.os.MessageQueue.quit(MessageQueue.java:415)<br>  at android.os.Looper.quit(Looper.java:240)<br></code></pre></td></tr></table></figure><p>why? 其实原因很简单，<strong>主线程不允许退出</strong>，退出就意味 APP 要挂。</p><h4 id="3-4-Handler-里藏着的-Callback-能干什么？"><a href="#3-4-Handler-里藏着的-Callback-能干什么？" class="headerlink" title="3.4 Handler 里藏着的 Callback 能干什么？"></a>3.4 Handler 里藏着的 Callback 能干什么？</h4><p>在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？</p><p>来看看 <code>Handler.dispatchMessage(msg)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>  <span class="hljs-comment">//这里的 callback 是 Runnable</span><br>  <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>    handleCallback(msg);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span><br>    <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>    handleMessage(msg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Handler.Callback 有<strong>优先处理消息的权利</strong> ，当一条消息被 Callback 处理<strong>并拦截（返回 true）</strong>，那么 Handler 的 <code>handleMessage(msg)</code> 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着<strong>一个消息可以同时被 Callback 以及 Handler 处理</strong>。</p><p>这个就很有意思了，这有什么作用呢？</p><p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p><p>场景：Hook <a href="https://link.segmentfault.com/?enc=1asGDCdCV3T5y65Pk2kuDQ==.Uhp2mo4W90sTQwzH1d9e15WY22mc9OtQVRXzDS422P/zew1NCYkLyzcLEjHDNPtf03Mf8b+z4w0PN4POicVIcQ==">ActivityThread.mH</a> ， 在 ActivityThread 中有个成员变量 <code>mH</code> ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p><h4 id="3-5-创建-Message-实例的最佳方式"><a href="#3-5-创建-Message-实例的最佳方式" class="headerlink" title="3.5 创建 Message 实例的最佳方式"></a>3.5 创建 Message 实例的最佳方式</h4><p>由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。</p><p>方法有二：</p><ol><li>通过 Message 的静态方法 <code>Message.obtain();</code>  获取；</li><li>通过 Handler 的公有方法 <code>handler.obtainMessage();</code> 。</li></ol><h4 id="3-6-子线程里弹-Toast-的正确姿势"><a href="#3-6-子线程里弹-Toast-的正确姿势" class="headerlink" title="3.6 子线程里弹 Toast 的正确姿势"></a>3.6 子线程里弹 Toast 的正确姿势</h4><p>当我们尝试在子线程里直接去弹 Toast 的时候，会 crash ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.RuntimeException: Can<span class="hljs-string">&#x27;t create handler inside thread that has not called Looper.prepare()</span><br></code></pre></td></tr></table></figure><p><strong>本质上是因为 Toast 的实现依赖于 Handler</strong>，按子线程使用 Handler 的要求修改即可（见【2.1】），同理的还有 Dialog。</p><p>正确示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    Looper.prepare();<br>    Toast.makeText(HandlerActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;不会崩溃啦！&quot;</span>, Toast.LENGTH_SHORT).show();<br>    Looper.loop();<br>  &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><h4 id="3-7-妙用-Looper-机制"><a href="#3-7-妙用-Looper-机制" class="headerlink" title="3.7 妙用 Looper 机制"></a>3.7 妙用 Looper 机制</h4><p>我们可以利用 Looper 的机制来帮助我们做一些事情：</p><ol><li>将 Runnable post 到主线程执行；</li><li>利用 Looper 判断当前线程是否是主线程。</li></ol><p>完整示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainThread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MainThread</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable runnable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isMainThread()) &#123;<br>            runnable.run();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            HANDLER.post(runnable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMainThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Looper.myLooper() == Looper.getMainLooper();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>能够省去不少样板代码。</p><h3 id="4-知识点汇总"><a href="#4-知识点汇总" class="headerlink" title="4. 知识点汇总"></a>4. 知识点汇总</h3><p>由前文可得出一些知识点，汇总一下，方便记忆。</p><ol><li>Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理；</li><li>在创建 Handler 之前一定需要先创建 Looper；</li><li>Looper 有退出的功能，但是主线程的 Looper 不允许退出；</li><li>异步线程的 Looper 需要自己调用 <code>Looper.myLooper().quit();</code> 退出；</li><li>Runnable 被封装进了 Message，可以说是一个特殊的 Message；</li><li><code>Handler.handleMessage()</code> 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成 Looper 所在的线程，并不是创建 Handler 的线程；</li><li>使用内部类的方式使用 Handler 可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类；</li></ol><p>文章转自 <a href="https://link.segmentfault.com/?enc=adCrDbIqN/onceBEbK7siQ==.Mu7v30P+VcsfAMTo30k3ZSRBO+cof6bAasrjOCCVbP2792wlRq/278s2X6O3s9IJ">https://juejin.cn/post/684490...</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>Android 进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler 常见问题分析</title>
    <link href="/Handler-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/Handler-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1-一个线程有几个-Handler？"><a href="#1-一个线程有几个-Handler？" class="headerlink" title="1. 一个线程有几个 Handler？"></a>1. 一个线程有几个 Handler？</h2><p>一个线程可以有无数个handler。</p><h2 id="2-一个线程有几个-Looper？如何保证？"><a href="#2-一个线程有几个-Looper？如何保证？" class="headerlink" title="2. 一个线程有几个 Looper？如何保证？"></a>2. 一个线程有几个 Looper？如何保证？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>    &#125;<br>    sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到线程相关信息都由ThreadLocal管理，在ThreadLocal中存放了线程的唯一信息，它是线程唯一的标识。</p><h2 id="3-Handler内存泄漏原因？-为什么其他的内部类没有说过有这个问题？-（为什么Handler要使用static修饰？）"><a href="#3-Handler内存泄漏原因？-为什么其他的内部类没有说过有这个问题？-（为什么Handler要使用static修饰？）" class="headerlink" title="3. Handler内存泄漏原因？ 为什么其他的内部类没有说过有这个问题？ （为什么Handler要使用static修饰？）"></a>3. Handler内存泄漏原因？ 为什么其他的内部类没有说过有这个问题？ （为什么Handler要使用static修饰？）</h2><p>内部类默认持有外部类实例。当我们在Activity里面创建内部类MyHandler（继承Handler），那么在MyHandler内部是默认持有Activity.this，那么如果现在如果使用该handler发送了一个延迟5min时候执行的message，但是3min时候，activity执行了finish，结果因为Message中存在handler的引用，而handler又存在activity的引用，导致内存无法释放（内存泄漏）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    msg.target = <span class="hljs-built_in">this</span>; <span class="hljs-comment">//message持有handler引用</span><br>    msg.workSourceUid = ThreadLocalWorkSource.getUid();<br>    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>        msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="5-为何主线程可以new-Handler？如果想要在子线程中new-Handler-要做些什么准备？"><a href="#5-为何主线程可以new-Handler？如果想要在子线程中new-Handler-要做些什么准备？" class="headerlink" title="5. 为何主线程可以new Handler？如果想要在子线程中new Handler 要做些什么准备？"></a>5. 为何主线程可以new Handler？如果想要在子线程中new Handler 要做些什么准备？</h2><p>首先我们需要知道我们使用handler发送和处理消息需要哪些东西，MessageQueue、Handler 、Looper。MessageQueue是一个优先级队列，他的本质是一个单向链表。存放我们使用handler发送的消息，Handler则是我们消息的处理者，我们发送的消息会调用enqueueMessage方法将消息放到MessageQueue中，然后Looper会不断的去遍历MessageQueue中的消息，最后调用next方法取出消息，在Handler的handleMessage方法里面进行处理。这就是Handler的大致流程。我们在主线程里面通过new Handler创建了handler实例，那么还需要MessageQueue和Looper。既然我们在主线程中的handler能正常使用，说明Looper。MessageQueue肯定是存在的，当然是系统帮我们完成了创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//Base\core\java\android\app\ActivityThread.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;ActivityThreadMain&quot;</span>);<br>        <span class="hljs-comment">// Install selective syscall interception</span><br>        AndroidOs.install();<br>......<br>        Looper.prepareMainLooper();<span class="hljs-comment">//创建Looper</span><br>        ......<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>     mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<span class="hljs-comment">//创建和线程绑定的MessageQueue</span><br>     mThread = Thread.currentThread();<br> &#125;<br></code></pre></td></tr></table></figure><p>满足了上述的条件，我们在主线程里面就能正常使用handler发送消息了。那么在子线程里面，这些操作就需要我们自己完成，初始化Looper，</p><p>创建handler，使Looper启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Looper.prepare();<br>Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;子线程: &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;,looper = &quot;</span> + Looper.myLooper() + <span class="hljs-string">&quot;,MessagesQueue = &quot;</span> + Looper.myQueue());<br>mSub_handler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Objects.requireNonNull(Looper.myLooper()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>.Callback() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;mSub_handler : msg.what =&quot;</span> + msg.what);<br>        Log.d(TAG, <span class="hljs-string">&quot;mSub_handler : msg.obj =&quot;</span> + msg.obj);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>        <span class="hljs-built_in">super</span>.handleMessage(msg);<br>        Log.d(TAG, <span class="hljs-string">&quot;mSub_handler，线程 ：&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 处理消息 : msg.what =&quot;</span> + msg.what);<br>        Log.d(TAG, <span class="hljs-string">&quot;mSub_handler，线程 ：&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 处理消息 : msg.obj =&quot;</span> + msg.obj);<br>    &#125;<br>&#125;;<br>Looper.loop();<br></code></pre></td></tr></table></figure><p>当然我们也可以使用HandlerThread，也可以创建子线程的handler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HandlerThread</span> <span class="hljs-variable">handlerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span>(<span class="hljs-string">&quot;HandlerThread&quot;</span>);<br>handlerThread.start();<br><span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(handlerThread.getLooper(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>.Callback() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;mSub_handler，线程 ：&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 处理消息 : msg.what =&quot;</span> + msg.what);<br>        Log.d(TAG, <span class="hljs-string">&quot;mSub_handler，线程 ：&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 处理消息 : msg.obj =&quot;</span> + msg.obj);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="6-为什么使用Message-obtain创建消息，有什么好处？"><a href="#6-为什么使用Message-obtain创建消息，有什么好处？" class="headerlink" title="6.为什么使用Message.obtain创建消息，有什么好处？"></a>6.为什么使用Message.obtain创建消息，有什么好处？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg1</span> <span class="hljs-operator">=</span> Message.obtain();<span class="hljs-comment">//方式1</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<span class="hljs-comment">//方式2</span><br></code></pre></td></tr></table></figure><p>这两种方式都是允许的，区别在方式1是内存复用，它并没有去新创建一个Message对象，而是使用已经创建好的空的Message对象。这样会避免大量的message创建导致内存抖动，最后OOM。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>.......<br>         <span class="hljs-keyword">try</span> &#123;<br>           msg.target.dispatchMessage(msg);<span class="hljs-comment">//消息分发给适合的handler处理</span><br>           <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>               observer.messageDispatched(token, msg);<br>           &#125;<br>           dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>       &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;<br>           <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>               observer.dispatchingThrewException(token, msg, exception);<br>           &#125;<br>           <span class="hljs-keyword">throw</span> exception;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           ThreadLocalWorkSource.restore(origWorkSource);<br>           <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>               Trace.traceEnd(traceTag);<br>           &#125;<br>       &#125;<br>       ........<br>       <br>       msg.recycleUnchecked();<span class="hljs-comment">//这里并没有销毁message，而是回收消息</span><br><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在下面的方法中，将message中下内容清空后，将该message放到了消息链表的头部。这里MAX_POOL_SIZE&#x3D;50，最多维护的消息链表最长为50，如果链表已经满了，那么该message就会被垃圾回收机制处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">recycleUnchecked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Mark the message as in use while it remains in the recycled object pool.</span><br>    <span class="hljs-comment">// Clear out all other details.</span><br>    flags = FLAG_IN_USE;<br>    what = <span class="hljs-number">0</span>;<br>    arg1 = <span class="hljs-number">0</span>;<br>    arg2 = <span class="hljs-number">0</span>;<br>    obj = <span class="hljs-literal">null</span>;<br>    replyTo = <span class="hljs-literal">null</span>;<br>    sendingUid = UID_NONE;<br>    workSourceUid = UID_NONE;<br>    when = <span class="hljs-number">0</span>;<br>    target = <span class="hljs-literal">null</span>;<br>    callback = <span class="hljs-literal">null</span>;<br>    data = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<br>            next = sPool;<span class="hljs-comment">//将next指向消息链表头部的message</span><br>            sPool = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//当前的message成为链表第一个message</span><br>            sPoolSize++;<span class="hljs-comment">//链表变长</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是obtaion方法的具体实现，可以看到取出了消息链表头部的消息，并断开与消息池中其他message的链接。将链表中第二个message作为链表的头部消息。如果消息池中不存在消息，就new一个新的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<span class="hljs-comment">//加锁，避免执取message实例的过程中，有新的message插入到消息链表中</span><br>        <span class="hljs-keyword">if</span> (sPool != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-literal">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码可以看到，Message内部是维护了一个消息池，这个消息池本质是一个单链表。我们使用Message.obtaion()获取消息会优先从消息池中获取，消息池中没有可用的消息才会取new消息。当消息被处理完之后，也并不会直接被GC回收，而且放到消息池中，消息池最大容量是50个message。这样的好处是避免了大量message的创建，然后回收，遗留的内存碎片，过多的内存碎片会导致虚拟机中没有大容量连续的内存地址，这样当我们想要申请一块连续的内存空间时候，就可能会出现OOM，这是我们应该极力避免的情况。这种对message的复用本质是享元设计模式，设计模式的思想应该融入我们的每一部分代码。</p><h2 id="7-Handler源码中，为什么不少构造方法都废弃了？原因是什么？"><a href="#7-Handler源码中，为什么不少构造方法都废弃了？原因是什么？" class="headerlink" title="7.Handler源码中，为什么不少构造方法都废弃了？原因是什么？"></a>7.Handler源码中，为什么不少构造方法都废弃了？原因是什么？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback)</span> &#123;<br>    <span class="hljs-built_in">this</span>(callback, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-Looper死循环为什么不会导致应用卡死？"><a href="#8-Looper死循环为什么不会导致应用卡死？" class="headerlink" title="8.Looper死循环为什么不会导致应用卡死？"></a>8.Looper死循环为什么不会导致应用卡死？</h2><p>loop无限循环用于取出消息并将消息分发出去，没有消息时会阻塞在queue.next()里的nativePollOnce()方法里，并释放CPU资源进入休眠。Android的绝大部分操作都是通过Handler机制来完成的，如果没有消息，则不需要程序去响应，就不会有ANR。ANR一般是消息的处理过程中耗时太长导致没有及时响应用户操作。</p><h2 id="9-Handler-loop-休眠为什么不会导致ANR？"><a href="#9-Handler-loop-休眠为什么不会导致ANR？" class="headerlink" title="9. Handler loop 休眠为什么不会导致ANR？"></a>9. Handler loop 休眠为什么不会导致ANR？</h2><p>往Looper里面添加消息的时候，它会唤醒这个Looper。Looper 阻塞等待：queue.next() 方法会阻塞，直到有新的消息到达消息队列。这意味着如果没有新的消息，Looper 会进入休眠状态，不会占用 CPU 资源。Looper 非阻塞处理：一旦有新的消息到达，queue.next() 会立即返回，Looper 会继续处理消息。处理完消息后，Looper 会再次调用 queue.next()，进入下一次循环。所有的事件都能够及时响应，当然就不会ANR了。</p><h2 id="10-同步屏障的原理和意义？"><a href="#10-同步屏障的原理和意义？" class="headerlink" title="10.同步屏障的原理和意义？"></a>10.同步屏障的原理和意义？</h2><p>首先明确几个概念，同步消息，异步消息。我们日常使用handler发送的消息都是同步消息，顾名思义，同步屏障就是拦截同步消息的。为什么要拦截同步消息呢？当然是要给异步消息让步，让handler优先处理异步消息。我们先看看同步屏障是怎么实现的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>.......<br> <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>    <span class="hljs-keyword">do</span> &#123;<br>     prevMsg = msg;<br>     msg = msg.next;<br>     &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<span class="hljs-comment">//如果是异步消息就跳出循环</span><br> &#125;<br> ......<br>    <span class="hljs-keyword">return</span> msg;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到同步屏障本质也是一个消息，但是是一个没有target的消息，也就是没有handler处理的消息，那么他是怎么出现在messageQueue里面的呢？这时候当然不能使用handler发送message，而是直接插入进去的。这是一个隐藏的方法。通过这个方法就会给MessageQueue中插入同步屏障，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-meta">@TestApi</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">postSyncBarrier</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-comment">// Enqueue a new sync barrier token.</span><br>    <span class="hljs-comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> mNextBarrierToken++;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>        msg.markInUse();<br>        msg.when = when;<br>        msg.arg1 = token;<br>   <span class="hljs-comment">//就是这里！！！初始化Message对象的时候，并没有给target赋值，因此 target==null</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>        <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p.when &lt;= when) &#123;<br>                <span class="hljs-comment">//如果开启同步屏障的时间（假设记为T）T不为0，且当前的同步消息里有时间小于T，则prev也不为null</span><br>                prev = p;<br>                p = p.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//根据prev是不是为null，将 msg 按照时间顺序插入到 消息队列（链表）的合适位置</span><br>        <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// invariant: p == prev.next</span><br>            msg.next = p;<br>            prev.next = msg;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>        &#125;<br>        <span class="hljs-keyword">return</span> token;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>怎么设置消息成为异步消息呢？异步消息就我们想要立刻执行的消息，一般UI相关的消息应该是立刻执行的，所以我们可以在View相关的类可以看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//core\java\android\view\ViewRootImpl.java</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleProcessInputEvents</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (!mProcessInputEventsScheduled) &#123;<br>           mProcessInputEventsScheduled = <span class="hljs-literal">true</span>;<br>           <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mHandler.obtainMessage(MSG_PROCESS_INPUT_EVENTS);<br>           msg.setAsynchronous(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置异步消息</span><br>           mHandler.sendMessage(msg);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>为了让消息尽快执行，为什么不直接将消息插入到MessagQueue头部呢？这是因为保证消息顺序：如果直接将消息插入队列的最头部，会破坏消息的顺序。在很多应用场景中，消息的处理顺序是非常重要的，特别是涉及到状态管理和依赖关系时。同步屏障的目的是在特定时间点前阻止其他消息的处理，而不是完全改变消息的处理顺序。同步屏障的作用：同步屏障的作用是在某个时间点前阻止其他消息的处理，确保在这个时间点之前的所有消息都已经被处理完毕。如果将同步屏障直接插入队列的最头部，可能会导致后续的消息被无条件地延迟处理，这与同步屏障的设计初衷不符直接将消息插入队列的最头部可能会导致频繁的队列重组，增加不必要的性能开销。同步屏障通过在合适的位置插入，可以更高效地管理消息队列，减少不必要的资源消耗。</p>]]></content>
    
    
    <categories>
      
      <category>Android 进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="1-内存的基础知识"><a href="#1-内存的基础知识" class="headerlink" title="1.内存的基础知识"></a>1.内存的基础知识</h2><h3 id="1-1存储单元"><a href="#1-1存储单元" class="headerlink" title="1.1存储单元"></a>1.1存储单元</h3><p>内存的作用：存放数据。程序执行前需要先放到内存中才能被CFPU处理。</p><p>意义：缓和CPU与硬盘之间的速度矛盾。</p><p>存储单元：内存中的最小存储单位。可以理解成内存中的一个个的小房间。</p><p>内存地址从0开始（逻辑地址），每个地址对应一个存储单元。</p><p>计算机分为“字节编码”和“字长编码”</p><p>如果是字节编码的计算机，每个存储单元的大小是1B（byte），也就是8个二进制位（bit）</p><p>如果是字长位16位的计算机“按字编码”，则每个存储单元大小是1字。也就是16个二进制位（bit）</p><h3 id="1-2指令运行的基本原理"><a href="#1-2指令运行的基本原理" class="headerlink" title="1.2指令运行的基本原理"></a>1.2指令运行的基本原理</h3><h4 id="1-2-1指令的工作原理—操作码-若干参数（可能包含地址参数）"><a href="#1-2-1指令的工作原理—操作码-若干参数（可能包含地址参数）" class="headerlink" title="1.2.1指令的工作原理—操作码+若干参数（可能包含地址参数）"></a>1.2.1指令的工作原理—操作码+若干参数（可能包含地址参数）</h4><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241023222733.png"><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241023222812.png"><p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241023222827.png">可见,我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读&#x2F;写数据,这个数据应该做什么样的处理。</p><p>在这个例子中,我们默认让这个进程的相关内容从地址#0开始连续存放,指令中的地址参数直接给出了变量x的实际存放地址(物理地址)。</p><p>程序经过编译、链接后生成的指令中指明的是逻辑地址(相对地址),  即:相对于进程的起始地址而言的地址。</p><h4 id="1-1-2逻辑地址（相对地址）vs-物理地址（绝对地址）"><a href="#1-1-2逻辑地址（相对地址）vs-物理地址（绝对地址）" class="headerlink" title="1.1.2逻辑地址（相对地址）vs 物理地址（绝对地址）"></a>1.1.2逻辑地址（相对地址）vs 物理地址（绝对地址）</h4><p>物理地址是指在计算机内存中的实际位置，逻辑地址是指相对于进程申请内存的起始地址的位置。</p><h4 id="1-1-3从写程序到程序运行—编译、链接、装入"><a href="#1-1-3从写程序到程序运行—编译、链接、装入" class="headerlink" title="1.1.3从写程序到程序运行—编译、链接、装入"></a>1.1.3从写程序到程序运行—编译、链接、装入</h4><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241023222842.png"><p>编译:由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译为机器语言</p><p>链接:由链接程序将编译后形成的一组目标模块,以及所需需库函数链接在一起,形成一个完整的装入模块</p><p>装入(装载):由装入程序将装入模块装入内存运行。   *.exe文件也就是装入模块</p><h4 id="1-1-4三种装入方式"><a href="#1-1-4三种装入方式" class="headerlink" title="1.1.4三种装入方式"></a>1.1.4三种装入方式</h4><ol><li><p>绝对装入</p><p>绝对装入:在编译时,如果知道程序将放到内存中的哪个位置,编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址,将程序和数据装入内存。</p><p><strong>绝对装入只适用于单道程序环境</strong>。程序中使用的绝对地址,可在编译或汇编时给出,也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对时地址。</p><p>缺点：对程序员不透明，而且程序只能在固定电脑运行。</p></li><li><p>静态重定位</p><p>静态重定位:又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的,指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。。可根据内存的当前情况,将装入模块装入到内存的适当位置。装入时对地址进行**”重定位**”,将逻辑地址变变换为物理地址(地址变换是在装入时一次完成的)。</p><p>缺点：静态重定位的特点是在一个作业装入内存时,必须<strong>分配其要求的全部内存空间</strong>,如果没有足够的内存,就不能装入该作业一旦进入内存后,在<strong>运行期间就不能再移动</strong>,也不能<strong>再申请内存空间</strong>。</p></li><li><p>动态重定位</p><p>动态重定位:又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后,并不会立即把逻辑地址转换为物理地址,而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p><p>重定位寄存器:存放装入模块存放的起始位置</p></li></ol><h2 id="2-内存管理的概念"><a href="#2-内存管理的概念" class="headerlink" title="2.内存管理的概念"></a>2.内存管理的概念</h2><h2 id="3-覆盖与交换"><a href="#3-覆盖与交换" class="headerlink" title="3.覆盖与交换"></a>3.覆盖与交换</h2><h2 id="4-连续分配管理方式"><a href="#4-连续分配管理方式" class="headerlink" title="4.连续分配管理方式"></a>4.连续分配管理方式</h2>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android 源码的编译-1</title>
    <link href="/android-%E6%BA%90%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91-1/"/>
    <url>/android-%E6%BA%90%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91-1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>我们顺利的将AOSP下载了下来后,很多时候我们不仅仅需要去查看源码,还有以下的几个需求:</p><ol><li>定制Android系统</li><li>将最新版本的Android系统刷入到自己的Android设备中</li><li>将整个系统源码导入到Android Studio中</li><li>动态调试Android系统源码 （不一定需要导入全部的源码，部分源码也可以调试）</li></ol><h2 id="源码编译相关名词："><a href="#源码编译相关名词：" class="headerlink" title="源码编译相关名词："></a>源码编译相关名词：</h2><ol><li><p>Makefile：</p><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</p><p>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：<br>1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。<br>2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。<br>3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。<br>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p><p>原文链接：<a href="https://blog.csdn.net/haoel/article/details/2886">跟我一起写 Makefile（一）</a></p></li><li><p>Android.mk</p><p>属于Android编译环境下一个特殊的makefile文件，Android.mk中定义了一个模块的必要的参数，使模块跟着平台编译，通俗的讲就是告诉编译系统应该以什么样的规则来编译你的源代码，并生成对应的目标文件。</p><p><a href="https://zhuanlan.zhihu.com/p/680173022">Android.mk解析与使用</a></p></li><li><p>Ninja</p><p>在Android编译环境中，Ninja 是一个快速、小巧且采用无依赖规则的构建系统。相比于传统的 Make 或其他构建工具，Ninja 专注于执行速度，尤其擅长处理大型项目和多线程编译任务。</p><p>在Android源码编译流程中，Ninja 被用来作为最终的构建工具执行阶段。CMake 或其他前端构建工具（例如Google之前使用的Soong）生成 Ninja 构建文件（通常扩展名为 <code>.ninja</code>），这些文件包含了编译项目的详细指令和依赖关系图。当工程配置发生更改时，Ninja 可以迅速确定哪些目标需要重新构建，并高效地调度多个编译任务进行并行执行，从而极大地加速了整个编译过程。</p></li><li><p>Soong</p><p><a href="https://android.googlesource.com/platform/build/soong/+/refs/heads/master/README.md">Soong 构建系统</a>是在 Android 7.0 (Nougat) 中引入的，旨在取代 Make。它利用 <a href="https://github.com/google/kati/blob/master/README.md">Kati</a> GNU Make 克隆工具和 <a href="https://ninja-build.org/">Ninja</a> 构建系统组件来加速 Android 的构建。Soong 使用的是 Go 语言编写，它提供了一种声明式的、模块化的配置和构建框架，使得 Android 源码树的构建过程更为灵活和高效。</p></li><li><p>Blueprint</p><p>Blueprint是Android系统中的一种构建系统，它是Soong的一部分，用于定义和构建Android系统中的各种组件。Blueprint使用一种声明式的方法来定义组件的构建规则，包括组件的依赖关系、编译选项、生成规则等。</p><p>Blueprint是生成、解析Android.bp的工具，是Soong的一部分。翻译成Ninja语法。</p><p>Soong则是专为Android编译而设计的工具，Blueprint只是解析文件的形式，而Soong则解释内容的含义。</p></li><li><p>kati </p><p>在Android编译系统的历史发展中，Kati 是一个过渡性的构建工具，由 Google 开发，旨在提高 Android 源码树的编译性能。在 Soong 构建系统完全取代旧有的 Makefile 构建流程之前，Kati 起到了关键的作用。</p><p>Kati 主要设计目的是为了加速基于 Makefile 的 Android 编译过程。它通过解析 Makefile 并将其转换为更高效的内部表示形式，然后生成 Ninja 构建文件，利用 Ninja 的高性能特性来进行并行编译，从而提升 Android 源码编译的速度。</p><p>尽管 Kati 曾经在一段时间内被用于优化 Android 编译流程，但随着 Soong 构建系统的成熟和完善，Google 已逐步淘汰 Kati，转而全面采用 Soong 和 Ninja 的组合来构建 Android 系统，以获得更好的构建性能和灵活性。</p></li><li><p>Android.bp</p><p>Android.bp文件首先是Android系统的一种编译配置文件，是用来代替原来的Android.mk文件的</p></li></ol><h3 id="概念之间的联系为"><a href="#概念之间的联系为" class="headerlink" title="概念之间的联系为:"></a>概念之间的联系为:</h3><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240320000939.png"><h3 id="Android-mk-和Android-bp-的区别"><a href="#Android-mk-和Android-bp-的区别" class="headerlink" title="Android.mk 和Android.bp 的区别"></a>Android.mk 和Android.bp 的区别</h3><p>Android.mk 是 Makefile 的一种形式，同样采用的是 DSL(Domain Specific Language)，包括不同的规则、条件、分支、循环等复杂的控制等等。详细看另一篇《Makefile (一)之 简介》<br>Android.bp 是在 android 7.0 之后使用，是一种简单的配置文件，并不像makefile 有条件、分支、循环等控制，也没有运算、逻辑等操作<br>Android.mk 文件通常具有多个具有相同名称的模块（如：库的静态和共享版本，或主机和设备版本）<br>Android.bp文件需要每个模块有唯一的名称，但是可以在多个变体中构建单个模块，如通过添加 host_supported: true。androidmk转换器会生成多个冲突的模块，必须通过处理单个模块的target: { android: { }, host: { } }块里的差异来手动解决</p><p>原文链接：<a href="https://blog.csdn.net/shift_wwx/article/details/84790429">Android中的Android.bp、Blueprint 和Soong简介</a></p><p><a href="https://gityuan.com/2018/06/02/android-bp/">理解Android.bp - Gityuan博客 | 袁辉辉的技术博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Android 进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>framework初识</title>
    <link href="/framework%E5%88%9D%E8%AF%86/"/>
    <url>/framework%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Framework初识"><a href="#Framework初识" class="headerlink" title="Framework初识"></a>Framework初识</h1><p>什么是 <code>Android Framework</code>开发？</p><p> Android Framework开发是指针对Android操作系统框架层进行的软件开发工作。这一层次是Android平台的核心部分，它为应用程序开发者提供了APIs和系统服务，并定义了应用程序如何与系统交互的标准机制。</p><p>在Android Framework开发中，开发者可能涉及的工作内容包括但不限于：</p><ol><li><strong>系统服务开发</strong>：设计和实现Android系统中的关键服务组件，如Activity Manager Service、Window Manager Service、Package Manager Service等，这些服务对上层应用提供支持，确保整个系统的正常运行。</li><li><strong>API设计与实现</strong>：创建新的API接口或者扩展现有的API，以便于应用程序开发者能够更加方便地访问和控制设备资源，比如添加新的权限控制、硬件驱动接口调用或功能模块。</li><li><strong>系统组件定制</strong>：根据需求修改或自定义Android的内置组件，例如Activity、Service、Broadcast Receiver、Content Provider等，以适应特定设备或业务场景的需求。</li><li><strong>系统性能优化</strong>：对Framework层的代码进行性能分析和优化，减少内存消耗、提高响应速度，提升整体用户体验。</li><li><strong>兼容性与稳定性改进</strong>：处理不同版本间以及不同设备间的兼容性问题，保证框架层代码的稳定性和健壮性。</li><li><strong>安全机制强化</strong>：设计和实施安全策略，加强权限管理、数据加密、漏洞修复等方面的开发工作，保障用户隐私和系统安全性。</li></ol><h2 id="1、Android系统架构"><a href="#1、Android系统架构" class="headerlink" title="1、Android系统架构"></a>1、Android系统架构</h2><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240229215348.png"><h3 id="1-1-内核层（kernel）"><a href="#1-1-内核层（kernel）" class="headerlink" title="1.1 内核层（kernel）"></a>1.1 内核层（kernel）</h3><p>它的主要功能和职责包括：</p><ol><li><strong>硬件抽象</strong>：Linux Kernel为上层系统提供了统一的硬件访问接口，通过驱动程序实现了对处理器、内存、I&#x2F;O设备等硬件资源的管理和控制。这使得Android无需关心具体的硬件细节，可以跨不同类型的硬件平台运行。</li><li><strong>进程管理</strong>：负责创建和销毁进程，调度CPU时间片给各个进程，实现多任务处理环境。</li><li><strong>内存管理</strong>：内核负责整个系统的内存分配与回收，维护虚拟内存空间，支持交换空间以扩大可用内存，并确保进程间的内存隔离。</li><li><strong>文件系统支持</strong>：提供多种文件系统支持，如ext4、F2FS等，用于数据存储和交换。</li><li><strong>网络通信</strong>：实现TCP&#x2F;IP协议栈，以及对各种网络硬件的支持，如WiFi、蓝牙、移动网络等。</li><li><strong>安全机制</strong>：内核提供了权限控制、SELinux强制访问控制等安全机制，保证系统及应用的安全性。</li><li><strong>电源管理</strong>：针对移动设备特性，内核还承担了电池电量监控、设备休眠唤醒策略等电源管理功能。</li><li><strong>设备驱动</strong>：为不同的硬件设备编写并加载相应的驱动程序，这些驱动遵循特定的接口规范与上层进行交互，确保硬件设备能够正常工作。</li></ol><h3 id="1-2-硬件抽象层（HAL层）"><a href="#1-2-硬件抽象层（HAL层）" class="headerlink" title="1.2 硬件抽象层（HAL层）"></a>1.2 硬件抽象层（HAL层）</h3><p> Android的硬件驱动与Linux不同，传统的Liunx内核驱动完全 存在于内核空间中。但是Android在内核外部增加了一个硬件抽象 层(HAL-Hardware Abstraction Layer)，把一部分硬件驱动放到了 HAL层。</p><p>为什么存在HAL层？</p><p>Linux内核采用了GPL协议，如果硬件厂商需要支持Linux系统，就需要遵照GPL协议公开硬件驱动的源代码，这势必会影响到硬件厂家的核心利益。 Android的HAL层运行在用户空间，HAL是一个“空壳”，Android会 根据不同的需要，加载不同的动态库。这些动态库由硬件厂家提供。硬件厂家把相关硬件功能写入动态库，内核中只开放一些基本的读写接口操作。这样一些硬件厂家的驱动功能就由内核空间移动到了用户空间。 Android的HAL层遵循Apache协议，并不要求它的配套程序，因此厂家提供的驱动库不需要进行开放，保护了硬件厂家的核心利益。</p><p>HAL层存在的好处:</p><ol><li><strong>硬件无关性</strong>：<ul><li>HAL的主要目标是提供一个与具体硬件平台无关的接口层。通过HAL，上层的Android系统和应用程序可以调用统一的标准接口来访问底层硬件功能，而无需关心这些功能是如何在不同厂商或不同型号的硬件平台上实现的。</li></ul></li><li><strong>兼容性和可移植性</strong>：<ul><li>由于Android设备种类繁多，不同的硬件配置差异很大，HAL的存在使得Android能够运行在各种硬件平台上，且不需要针对每一种硬件编写特定的驱动程序。这极大地提高了系统的兼容性和可移植性。</li></ul></li><li><strong>模块化和解耦</strong>：<ul><li>HAL将硬件访问逻辑封装成独立的模块，每个模块负责特定的硬件功能，如相机、传感器、音频等。这种模块化设计允许硬件供应商为特定的硬件功能提供定制化的实现，同时不影响Android框架的整体结构和稳定性。</li></ul></li><li><strong>安全增强</strong>：<ul><li>HAL还可以作为隔离内核空间和用户空间之间通信的安全边界，通过HAL接口进行硬件访问可以更好地控制权限和执行安全策略。</li></ul></li><li><strong>开发便利性</strong>：<ul><li>对于应用开发者来说，他们可以通过Android SDK提供的API直接调用HAL层的接口，从而更容易地开发出兼容多种硬件平台的应用程序，而无需处理复杂的硬件驱动细节。</li></ul></li></ol><h3 id="1-3-native层（也称为C-x2F-C-层）"><a href="#1-3-native层（也称为C-x2F-C-层）" class="headerlink" title="1.3 native层（也称为C&#x2F;C++层）"></a>1.3 native层（也称为C&#x2F;C++层）</h3><p>指那些使用C和&#x2F;或C++编写的、运行在Linux内核之上的底层代码部分。这部分代码直接与硬件交互，提供了对操作系统核心功能的访问，以及优化过的高性能服务。</p><p>主要包括：系统Native库 和 Android运行时环境</p><h3 id="1-4-Java框架层"><a href="#1-4-Java框架层" class="headerlink" title="1.4 Java框架层"></a>1.4 Java框架层</h3><p>Android的Java框架层是整个Android应用开发架构中的核心部分，它主要负责构建和运行基于Java的应用程序，并且提供了丰富的API来实现各种功能。以下是Java框架层的主要作用：</p><ol><li><strong>应用程序组件</strong>：Java框架层定义了四大基本组件——Activity、Service、BroadcastReceiver和ContentProvider。这些组件构成了Android应用程序的基本结构，分别对应用户界面交互、后台服务、系统广播事件处理以及数据存储和共享等功能。</li><li><strong>用户界面</strong>：通过使用Android SDK提供的View体系（包括布局XML文件与Java代码），开发者可以方便地构建和定制各种复杂的用户界面，如列表、按钮、文本框等，并进行触摸事件和其他UI事件的响应。</li><li><strong>资源管理</strong>：框架层提供了一套完整的资源管理机制，允许开发者以统一的方式访问和操作字符串、图片、音频、视频等各种资源，支持多语言和屏幕适配。</li><li><strong>系统服务</strong>：框架层集成了大量的系统服务，如WIFI服务、蓝牙服务、位置服务、通知服务等，通过接口暴露给上层应用调用，从而让开发者能够利用手机的各种硬件能力。</li><li>**内容提供者(Content Provider)**：提供跨应用的数据共享机制，使得不同应用程序之间可以通过标准的URI方式进行数据读写和交换。</li><li><strong>Intent系统</strong>：通过Intent机制，实现了组件间的通信和启动，使得应用程序能够在不同的组件间传递数据和执行请求。</li><li><strong>安全性</strong>：Java框架层还包含了一系列安全相关的API和策略，用于权限控制、签名验证、沙盒隔离等，确保了系统的安全性和隐私保护。</li><li><strong>兼容性支持库</strong>：为了支持旧版本设备上的新功能，Android提供了兼容性支持库，使得开发者可以在保持向后兼容的同时使用最新的API特性。</li></ol><p><code>因为Native层和Java框架层的实现代码不同，并不能直接调用native层的接口，就需要一种承接转合的工具，那就是  JNI</code></p><h3 id="1-5-应用层"><a href="#1-5-应用层" class="headerlink" title="1.5 应用层"></a>1.5 应用层</h3><p>该层中包含所有的Android应用程序，包括电话、相机、日历等， 我们自己开发的Android应用程序也被安装在这层；大部分的应用 使用JAVA开发，现在Google也开始力推kotlin进行开发</p><p>官方架构文档：<a href="https://developer.android.google.cn/guide/platform?hl=zh-cn">平台架构  | Platform  | Android Developers (google.cn)</a></p><p>大佬博客：<a href="http://gityuan.com/android/">Android 操作系统架构开篇 - Gityuan博客 | 袁辉辉的技术博客</a></p><div class="note note-success">            <p>一般来说：Framework开发包括：Java Framework + JNI +Native 。</p>          </div><h2 id="2、Android-启动流程"><a href="#2、Android-启动流程" class="headerlink" title="2、Android 启动流程"></a>2、Android 启动流程</h2><p><img src="http://gityuan.com/images/android-arch/android-boot.jpg"></p><p>Android 系统启动流程：</p><ol><li>手机开机后，引导芯片启动，引导芯片开始从固化在 ROM里的预设代码执行，加载引导程序到到RAM，bootloader检 查RAM，初始化硬件参数等功能； </li><li>硬件等参数初始化完成后，进入到Kernel层，Kernel层 主要加载一些硬件设备驱动，初始化进程管理等操作。在Kernel 中首先启动swapper进程（pid&#x3D;0），用于初始化进程管理、内管 管理、加载Driver等操作，再启动kthread进程(pid&#x3D;2),这些linux 系统的内核进程，kthread是所有内核进程的鼻祖；  </li><li>Kernel层加载完毕后，硬件设备驱动与HAL层进行交互。 初始化进程管理等操作会启动 init 进程 ，这些在Native层中；  </li><li>init进程 (pid&#x3D;1，init进程是所有进程的鼻祖，第一个启动) 启动后，会启动adbd，logd等用户守护进程，并且会启动 servicemanager(binder服务管家)等重要服务，同时孵化出 zygote进程，这里属于C++ Framework，代码为C++程序；</li><li>zygote进程是由init进程解析init.rc文件后fork生成，它会加载虚拟机，启动System Server(zygote孵化的第一个进程)； System Server负责启动和管理整个Java Framework，包含 ActivityManager，WindowManager，PackageManager， PowerManager等服务；  </li><li>zygote同时会启动相关的APP进程，它启动的第一个APP 进程为Launcher，然后启动Email，SMS等进程，所有的APP进程 都有zygote fork生成</li></ol><h3 id="从进程的角度分析架构"><a href="#从进程的角度分析架构" class="headerlink" title="从进程的角度分析架构"></a>从进程的角度分析架构</h3><p>关于Loader层：</p><ul><li>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在<code>ROM</code>里的预设代码开始执行，然后加载引导程序到<code>RAM</code>；</li><li>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。</li></ul><h4 id="2-1-Linux内核层"><a href="#2-1-Linux内核层" class="headerlink" title="2.1 Linux内核层"></a>2.1 Linux内核层</h4><p>Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能。Linux内核的安全机制为Android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。</p><ul><li>启动Kernel的swapper进程(pid&#x3D;0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；</li><li>启动kthreadd进程（pid&#x3D;2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。<code>kthreadd进程是所有内核进程的鼻祖</code>。</li></ul><h4 id="2-2-硬件抽象层-HAL"><a href="#2-2-硬件抽象层-HAL" class="headerlink" title="2.2 硬件抽象层 (HAL)"></a>2.2 硬件抽象层 (HAL)</h4><p>硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI&#x2F;蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。</p><h4 id="2-3-Android-Runtime-amp-系统库"><a href="#2-3-Android-Runtime-amp-系统库" class="headerlink" title="2.3 Android Runtime &amp; 系统库"></a>2.3 Android Runtime &amp; 系统库</h4><p>每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART通过执行DEX文件可在设备运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式文件，经过优化，使用内存很少。ART主要功能包括：预先(AOT)和即时(JIT)编译，优化的垃圾回收(GC)，以及调试相关的支持。</p><p>这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid&#x3D;1),是Linux系统的用户进程，<code>init进程是所有用户进程的鼻祖</code>。</p><ul><li>init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；</li><li>init进程还启动<code>servicemanager</code>(binder服务管家)、<code>bootanim</code>(开机动画)等重要服务</li><li>init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，<code>Zygote是所有Java进程的父进程</code>，Zygote进程本身是由init进程孵化而来的。</li></ul><h4 id="2-4-Framework层"><a href="#2-4-Framework层" class="headerlink" title="2.4 Framework层"></a>2.4 Framework层</h4><ul><li>Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含：<ul><li>加载ZygoteInit类，注册Zygote Socket服务端套接字</li><li>加载虚拟机</li><li>提前加载类preloadClasses</li><li>提前加载资源preloadResouces</li></ul></li><li>System Server进程，是由Zygote进程fork而来，<code>System Server是Zygote孵化的第一个进程</code>，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。</li><li>Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。</li></ul><h4 id="2-5-App层"><a href="#2-5-App层" class="headerlink" title="2.5 App层"></a>2.5 App层</h4><ul><li>Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；</li><li>Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。</li><li>所有的App进程都是由Zygote进程fork生成的。</li></ul><h4 id="2-6-Syscall-amp-amp-JNI"><a href="#2-6-Syscall-amp-amp-JNI" class="headerlink" title="2.6 Syscall &amp;&amp; JNI"></a>2.6 Syscall &amp;&amp; JNI</h4><ul><li>Native与Kernel之间有一层系统调用(SysCall)层，见<a href="http://gityuan.com/2016/05/21/syscall/">Linux系统调用(Syscall)原理</a>;</li><li>Java层与Native(C&#x2F;C++)层之间的纽带JNI，见<a href="http://gityuan.com/2016/05/28/android-jni/">Android JNI原理分析</a>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android 进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Audio 相关词汇</title>
    <link href="/Audio-%E7%9B%B8%E5%85%B3%E8%AF%8D%E6%B1%87/"/>
    <url>/Audio-%E7%9B%B8%E5%85%B3%E8%AF%8D%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<p><strong>ABR</strong>  </p><p>自适应比特率。ABR算法是一种在播放过程中从多个音轨中进行选择的算法，其中每个音轨以不同的比特率呈现相同的媒体。</p><p><strong>Adaptive streaming</strong>   自适应流媒体</p><p>在自适应流媒体中，可以有多个音轨以不同的比特率呈现相同的媒体。在播放过程中，使用ABR算法动态选择所选曲目。</p><p><strong>Access unit</strong> 访问单元</p><p>媒体容器中的数据项。通常指可以解码并呈现给用户的一小段压缩媒体比特流(视频图片或可播放的音频片段)。</p><p><strong>AV1</strong></p><p>AOMedia Video 1 <a href="https://exoplayer.dev/glossary.html#codec">编解码器</a>。有关更多信息，请参阅<a href="https://en.wikipedia.org/wiki/AV1">维基百科页面</a>。</p><p><strong>AVC</strong></p><p>高级视频编码，也称为 H.264 视频<a href="https://exoplayer.dev/glossary.html#codec">编解码器</a>。有关更多信息，请参阅<a href="https://en.wikipedia.org/wiki/Advanced_Video_Coding">维基百科页面</a>。</p><p><strong>Codec</strong> 编解码器</p><p>以下两个定义是最常用的：</p><ul><li>用于编码或解码<a href="https://exoplayer.dev/glossary.html#access-unit">接入单元</a>的硬件或软件组件。</li><li>音频或视频示例格式规范。</li></ul><p><strong>Container</strong>容器</p><p>一种媒体容器格式，例如 MP4 和 Matroska。这种格式称为 容器格式，因为它们包含一个或多个<a href="https://exoplayer.dev/glossary.html#track">媒体轨道</a>， 其中每个轨道使用特定的<a href="https://exoplayer.dev/glossary.html#codec">编解码器</a>（例如 AAC 音频和 H.264 MP4 文件中的视频）。请注意，某些媒体格式都是容器格式 和编解码器 （e.g. MP3）。</p><p><strong>DASH</strong></p><p>基于 HTTP 的动态<a href="https://exoplayer.dev/glossary.html#adaptive-streaming">自适应流式处理</a>。行业驱动 自适应流协议。它由 ISO&#x2F;IEC 23009 定义，可以找到 在 <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/">ISO 公开可用标准页面上</a>。</p><p><strong>DRM</strong></p><p>数字版权管理。有关更多信息，请参阅<a href="https://en.wikipedia.org/wiki/Digital_rights_management">维基百科页面</a>。</p><p><strong>Gapless playback</strong> 无缝播放</p><p>曲目结束和&#x2F;或下<a href="https://exoplayer.dev/glossary.html#track">一首曲目</a>开始的过程 跳过轨道以避免轨道之间出现静默间隙。有关更多信息，请参阅<a href="https://en.wikipedia.org/wiki/Gapless_playback">维基百科页面</a>。</p><p><strong>HEVC</strong></p><p>高效视频编码，也称为 H.265 视频<a href="https://exoplayer.dev/glossary.html#codec">编解码器</a>。</p><p><strong>HLS</strong></p><p>HTTP 实时流。Apple 的<a href="https://exoplayer.dev/glossary.html#adaptive-streaming">自适应流媒体</a>协议。有关更多信息，请参阅 <a href="https://developer.apple.com/streaming/">Apple 文档</a>。</p><p><strong>Manifest</strong></p><p>一个文件，用于定义<a href="https://exoplayer.dev/glossary.html#adaptive-streaming">自适应流协议</a>中媒体的结构和位置。示例包括 <a href="https://exoplayer.dev/glossary.html#dash">DASH</a> <a href="https://exoplayer.dev/glossary.html#mpd">MPD</a> 文件、<a href="https://exoplayer.dev/glossary.html#hls">HLS</a> 多变量播放列表文件和平<a href="https://exoplayer.dev/glossary.html#smooth-streaming">滑流式处理</a>清单文件。不要与 AndroidManifest XML 文件。</p><p><strong>MPD</strong></p><p>媒体演示说明中使用的<a href="https://exoplayer.dev/glossary.html#manifest">清单</a>文件格式 <a href="https://exoplayer.dev/glossary.html#dash">DASH</a> <a href="https://exoplayer.dev/glossary.html#adaptive-streaming">自适应流协议</a>。</p><p><strong>PCM</strong></p><p>脉冲编码调制。有关更多信息，请参阅<a href="https://en.wikipedia.org/wiki/Pulse-code_modulation">维基百科页面</a>。</p><p><strong>Smooth Streaming</strong>平滑流式处理</p><p>Microsoft 的<a href="https://exoplayer.dev/glossary.html#adaptive-streaming">自适应流式处理</a>协议。有关详细信息，请参阅 <a href="https://www.iis.net/downloads/microsoft/smooth-streaming">Microsoft 文档</a>。</p><p><strong>Track</strong></p><p>媒体中的单个音频、视频、文本或元数据流。媒体 文件通常包含多个曲目。例如，视频轨道和音频 在视频文件中跟踪，或以不同语言录制多个音轨。在<a href="https://exoplayer.dev/glossary.html#adaptive-streaming">自适应流中</a>，还有多个轨道 包含不同比特率的相同内容。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>音视频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExoPlayer的官方应用（demo）</title>
    <link href="/ExoPlayer%E7%9A%84%E5%AE%98%E6%96%B9%E5%BA%94%E7%94%A8%EF%BC%88demo%EF%BC%89/"/>
    <url>/ExoPlayer%E7%9A%84%E5%AE%98%E6%96%B9%E5%BA%94%E7%94%A8%EF%BC%88demo%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note note-success">            <p>在ExoPlayer的官方GitHub地址上的README文档上，已经更新为V2.19.0版本</p>          </div><p><a href="https://github.com/google/ExoPlayer">项目地址</a></p><h3 id="在此版本ExoPlayer更新迁移到了AndroidX的Media3框架内"><a href="#在此版本ExoPlayer更新迁移到了AndroidX的Media3框架内" class="headerlink" title="在此版本ExoPlayer更新迁移到了AndroidX的Media3框架内"></a><code>在此版本ExoPlayer更新迁移到了AndroidX的Media3框架内</code></h3><p><a href="https://github.com/androidx/media">迁移后的项目地址</a></p><h2 id="ExoPlayer-介绍"><a href="#ExoPlayer-介绍" class="headerlink" title="ExoPlayer 介绍"></a>ExoPlayer 介绍</h2><p>ExoPlayer是Android的应用程序级媒体播放器。它提供了一个 替代 Android 的 MediaPlayer API，用于播放音频和视频 本地和互联网。ExoPlayer 支持当前未支持的功能 受 Android 的 MediaPlayer API 支持，包括 DASH 和 SmoothStreaming 自适应播放。与 MediaPlayer API 不同，ExoPlayer 易于自定义 并扩展，并可以通过 Play 商店应用程序更新进行更新。</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>与 Android 内置的 MediaPlayer 相比，ExoPlayer 具有许多优势：</p><ul><li>设备特定问题更少，不同设备之间的行为差异更少 Android 的设备和版本。</li><li>能够将播放器与应用程序一起更新。因为 ExoPlayer 是一个库，您包含在应用程序 apk 中，您有 控制您使用的版本，您可以轻松地更新到更新的版本 版本作为定期应用程序更新的一部分。</li><li><a href="https://exoplayer.dev/customization.html">能够自定义和扩展播放器</a>以适合您的用例。 ExoPlayer 是专门为此而设计的，它允许许多 要替换为自定义实现的组件。</li><li>支持<a href="https://exoplayer.dev/playlists.html">播放列表</a>。</li><li>支持 <a href="https://exoplayer.dev/dash.html">DASH</a> 和 <a href="https://exoplayer.dev/smoothstreaming.html">SmoothStreaming</a>，两者都不支持 由 MediaPlayer 提供。还支持许多其他格式。查看<a href="https://exoplayer.dev/supported-formats.html">支持的 格式页面</a>了解详细信息。</li><li>支持高级 <a href="https://exoplayer.dev/hls.html">HLS</a> 功能，例如正确处理标签。<code>#EXT-X-DISCONTINUITY</code></li><li>支持 <a href="https://exoplayer.dev/drm.html">Android</a> 4.4（API 级别 19）和 高等。</li><li>能够快速与许多其他库集成，使用 官方扩展。例如，<a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/ima">IMA 扩展</a>可以很容易地 使用<a href="https://developers.google.com/interactive-media-ads">互动式媒体广告 SDK</a> 通过您的内容获利。</li></ul><p>需要注意的是，也有一些缺点：</p><ul><li>对于某些设备上的仅音频播放，ExoPlayer 可能会消耗大量 比 MediaPlayer 更多的电量。请参阅<a href="https://exoplayer.dev/battery-consumption.html">电池消耗页面</a>，了解详情。</li><li>在您的应用程序中包含 ExoPlayer 会使 APK 大小增加几百KB。 这可能只是对于极其轻量级的应用程序而言。指导收缩 ExoPlayer 可以在 <a href="https://exoplayer.dev/shrinking.html">APK 收缩页面上</a>找到。</li></ul><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>对于简单的用例，入门包括实现 步骤如下：<code>ExoPlayer</code></p><ol><li>将 ExoPlayer 作为依赖项添加到您的项目中。</li><li>创建实例。<code>ExoPlayer</code></li><li>将播放器附加到视图（用于视频输出和用户输入）。</li><li>让播放器准备好播放音源。<code>MediaItem</code></li><li>完成后释放播放器。</li></ol><h2 id="将-ExoPlayer-添加为依赖项"><a href="#将-ExoPlayer-添加为依赖项" class="headerlink" title="将 ExoPlayer 添加为依赖项"></a>将 ExoPlayer 添加为依赖项</h2><h3 id="添加-ExoPlayer-模块"><a href="#添加-ExoPlayer-模块" class="headerlink" title="添加 ExoPlayer 模块"></a>添加 ExoPlayer 模块</h3><p>开始使用 ExoPlayer 的最简单方法是将其添加为 gradle 依赖项。下面将添加 对完整库的依赖：<code>build.gradle</code></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.google.android.exoplayer:exoplayer:2.X.X&#x27;</span><br></code></pre></td></tr></table></figure><p>哪里是您的首选版本（最新版本可以通过以下方式找到 请参阅<a href="https://github.com/google/ExoPlayer/tree/release-v2/RELEASENOTES.md">发行说明</a>）。<code>2.X.X</code></p><p>作为完整库的替代方法，您可以仅依赖库 您实际需要的模块。例如，以下将添加依赖项 在 Core、DASH 和 UI 库模块上，这可能是应用所必需的 只播放 DASH 内容：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.google.android.exoplayer:exoplayer-core:2.X.X&#x27;</span><br><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.google.android.exoplayer:exoplayer-dash:2.X.X&#x27;</span><br><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.google.android.exoplayer:exoplayer-ui:2.X.X&#x27;</span><br></code></pre></td></tr></table></figure><p>当依赖于各个模块时，它们必须都是相同的版本。您可以 浏览 <a href="https://maven.google.com/web/index.html#com.google.android.exoplayer">Google Maven ExoPlayer 页面上</a>的可用模块列表。这 Full Library 包括所有以 前缀的库模块 ， 除了 .<code>exoplayer-``exoplayer-transformer</code></p><p>除了库模块之外，ExoPlayer 还具有依赖 外部库以提供其他功能。一些扩展是 可从 Maven 存储库获得，而其他存储库必须手动构建。 浏览<a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/">扩展目录</a>及其各自的自述文件以了解详细信息。</p><h3 id="启用-Java-8-支持"><a href="#启用-Java-8-支持" class="headerlink" title="启用 Java 8 支持"></a>启用 Java 8 支持</h3><p>如果尚未启用，则需要根据ExoPlayer在所有文件中打开Java 8支持，方法是将以下内容添加到该部分：<code>build.gradle``android</code></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">compileOptions </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="启用-multidex"><a href="#启用-multidex" class="headerlink" title="启用 multidex"></a>启用 multidex</h3><p>如果您的 Gradle 为 20 或更低，则应按顺序<a href="https://developer.android.com/studio/build/multidex">启用 multidex</a> 以防止生成错误。<code>minSdkVersion</code></p><h2 id="创建播放器"><a href="#创建播放器" class="headerlink" title="创建播放器"></a>创建播放器</h2><p>您可以使用 创建一个实例，它提供 一系列自定义选项。下面的代码是最简单的示例 创建实例。<code>ExoPlayer``ExoPlayer.Builder</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ExoPlayer player = <span class="hljs-keyword">new</span> ExoPlayer.<span class="hljs-constructor">Builder(<span class="hljs-params">context</span>)</span>.build<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><h2 id="将播放器附加到视图"><a href="#将播放器附加到视图" class="headerlink" title="将播放器附加到视图"></a>将播放器附加到视图</h2><p>ExoPlayer库为媒体播放提供了一系列预构建的UI组件。包括：</p><p><code>StyledPlayerView StyledPlayerControlView SubtitleView Surface StyledPlayerView</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Bind the player to the view.</span><br>playerView.set<span class="hljs-constructor">Player(<span class="hljs-params">player</span>)</span>;<br></code></pre></td></tr></table></figure><p>您也可以作为独立组件使用，即 对于纯音频用例很有用。<code>StyledPlayerControlView</code></p><p>使用 ExoPlayer 的预构建 UI 组件是可选的。</p><h2 id="填充播放列表并准备播放器"><a href="#填充播放列表并准备播放器" class="headerlink" title="填充播放列表并准备播放器"></a>填充播放列表并准备播放器</h2><p>在 ExoPlayer 中，每个媒体都用 .要播放 你需要构建一个相应的媒体，将其添加到 播放器，准备好播放器，然后调用以开始播放：<code>MediaItem``MediaItem``play</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Build the media item.</span><br><span class="hljs-type">MediaItem</span> <span class="hljs-variable">mediaItem</span> <span class="hljs-operator">=</span> MediaItem.fromUri(videoUri);<br><span class="hljs-comment">// Set the media item to be played.</span><br>player.setMediaItem(mediaItem);<br><span class="hljs-comment">// Prepare the player.</span><br>player.prepare();<br><span class="hljs-comment">// Start the playback.</span><br>player.play();<br></code></pre></td></tr></table></figure><p>ExoPlayer直接支持播放列表，因此可以准备播放器 多个媒体项目一个接一个地播放：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Build the media items.</span><br><span class="hljs-type">MediaItem</span> <span class="hljs-variable">firstItem</span> <span class="hljs-operator">=</span> MediaItem.fromUri(firstVideoUri);<br><span class="hljs-type">MediaItem</span> <span class="hljs-variable">secondItem</span> <span class="hljs-operator">=</span> MediaItem.fromUri(secondVideoUri);<br><span class="hljs-comment">// Add the media items to be played.</span><br>player.addMediaItem(firstItem);<br>player.addMediaItem(secondItem);<br><span class="hljs-comment">// Prepare the player.</span><br>player.prepare();<br><span class="hljs-comment">// Start the playback.</span><br>player.play();<br></code></pre></td></tr></table></figure><p>播放列表可以在播放过程中更新，而无需准备 再次播放。在播放列表页面上阅读有关填充和操作<a href="https://exoplayer.dev/playlists.html">播放列表</a>的详细信息。阅读更多关于以下情况下可用的不同选项的信息 在“媒体项<a href="https://exoplayer.dev/media-items.html">”页上构建媒体项</a>，例如剪辑和附加字幕文件。</p><h2 id="控制播放器"><a href="#控制播放器" class="headerlink" title="控制播放器"></a>控制播放器</h2><p>一旦准备好播放器，就可以通过调用播放器上的方法来控制播放。下面列出了一些最常用的方法。</p><ul><li><code>play</code>以及开始和暂停播放。<code>pause</code></li><li><code>seekTo</code>允许在媒体内寻求。</li><li><code>hasPrevious</code> ，并允许在 播放列表。<code>hasNext``previous``next</code></li><li><code>setRepeatMode</code>控制媒体是否循环播放以及如何循环播放。</li><li><code>setShuffleModeEnabled</code>控制播放列表随机播放。</li><li><code>setPlaybackParameters</code>调整播放速度和音频音调。</li></ul><p>如果玩家绑定到 或 ， 然后用户与这些组件的交互将导致相应的方法 要调用的播放器。<code>StyledPlayerView StyledPlayerControlView</code></p><h2 id="释放播放器"><a href="#释放播放器" class="headerlink" title="释放播放器"></a>释放播放器</h2><p>在不再需要播放器时释放播放器很重要，这样才能释放 启动有限的资源，例如供其他应用程序使用的视频解码器。这 可以通过调用 来完成。<code>ExoPlayer.release</code></p>]]></content>
    
    
    <categories>
      
      <category>音视频</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式(java版)</title>
    <link href="/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88java%E7%89%88%EF%BC%89/"/>
    <url>/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88java%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变 时改变其行为</p><h2 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h2><p>行为型（behavioral）</p><h2 id="3-介绍"><a href="#3-介绍" class="headerlink" title="3.介绍"></a>3.介绍</h2><p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p><p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p><p><strong>使用场景：</strong> </p><ul><li>行为随状态改变而改变的场景。</li><li>条件、分支语句的代替者。</li></ul><p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p><h2 id="4-结构"><a href="#4-结构" class="headerlink" title="4.结构"></a>4.结构</h2><p> 状态模式包含以下主要角色。</p><ul><li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 </li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为。</li></ul><div align="center"><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240206015312.png"></div><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5.代码"></a>5.代码</h2><h3 id="5-1-抽象状态类"><a href="#5-1-抽象状态类" class="headerlink" title="5.1  抽象状态类"></a>5.1  抽象状态类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象状态类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    <span class="hljs-comment">//定义一个环境角色，也就是封装状态的变化引起的功能变化</span><br>    <span class="hljs-keyword">protected</span> Context context;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.context = context;<br>    &#125;<br>    <span class="hljs-comment">//电梯开门动作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//电梯关门动作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//电梯运行动作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//电梯停止动作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-状态机类"><a href="#5-2-状态机类" class="headerlink" title="5.2 状态机类"></a>5.2 状态机类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> state;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateMachine</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> OpeningState openingState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClosingState closingState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> RunningState runningState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> StoppingState stoppingState;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StateMachine</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//开门状态，这时候电梯只能关闭</span><br>        openingState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpeningState</span>();<br>        <span class="hljs-comment">//关闭状态，这时候电梯可以运行、停止和开门</span><br>        closingState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClosingState</span>();<br>        <span class="hljs-comment">//运行状态，这时候电梯只能停止</span><br>        runningState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunningState</span>();<br>        <span class="hljs-comment">//停止状态，这时候电梯可以开门、运行</span><br>        stoppingState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StoppingState</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpeningState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LiftState</span> &#123;<br>        <span class="hljs-comment">//开启当然可以关闭了，我就想测试一下电梯门开关功能</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;电梯门开启...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//状态修改</span><br>            <span class="hljs-built_in">super</span>.context.setLiftState(closingState);<br>            <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>            <span class="hljs-built_in">super</span>.context.getLiftState().close();<br>        &#125;<br><br>        <span class="hljs-comment">//电梯门不能开着就跑，这里什么也不做</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//do nothing</span><br>        &#125;<br><br>        <span class="hljs-comment">//开门状态已经是停止的了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//do nothing</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//运行状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunningState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LiftState</span> &#123;<br>        <span class="hljs-comment">//运行的时候开电梯门？你疯了！电梯不会给你开的</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//do nothing</span><br>        &#125;<br><br>        <span class="hljs-comment">//电梯门关闭？这是肯定了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//虽然可以关门，但这个动作不归我执行</span><br>            <span class="hljs-comment">//do nothing</span><br>        &#125;<br><br>        <span class="hljs-comment">//这是在运行状态下要实现的方法</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;电梯正在运行...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.context.setLiftState(stoppingState);<br>            <span class="hljs-built_in">super</span>.context.stop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//停止状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StoppingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LiftState</span> &#123;<br>        <span class="hljs-comment">//停止状态，开门，那是要的！</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//状态修改</span><br>            <span class="hljs-built_in">super</span>.context.setLiftState(openingState);<br>            <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>            <span class="hljs-built_in">super</span>.context.getLiftState().open();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//虽然可以关门，但这个动作不归我执行</span><br>            <span class="hljs-comment">//状态修改</span><br>            <span class="hljs-built_in">super</span>.context.setLiftState(closingState);<br>            <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>            <span class="hljs-built_in">super</span>.context.getLiftState().close();<br>        &#125;<br><br>        <span class="hljs-comment">//停止状态再跑起来，正常的很</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//状态修改</span><br>            <span class="hljs-built_in">super</span>.context.setLiftState(runningState);<br>            <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>            <span class="hljs-built_in">super</span>.context.getLiftState().run();<br>        &#125;<br><br>        <span class="hljs-comment">//停止状态是怎么发生的呢？当然是停止方法执行了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;电梯停止了...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//关闭状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LiftState</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">//电梯门关闭，这是关闭状态要实现的动作</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;电梯门关闭...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//电梯门关了再打开，逗你玩呢，那这个允许呀</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.context.setLiftState(openingState);<br>            <span class="hljs-built_in">super</span>.context.open();<br>        &#125;<br><br>        <span class="hljs-comment">//电梯门关了就跑，这是再正常不过了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.context.setLiftState(runningState);<br>            <span class="hljs-built_in">super</span>.context.run();<br>        &#125;<br><br>        <span class="hljs-comment">//电梯门关着，我就不按楼层</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.context.setLiftState(stoppingState);<br>            <span class="hljs-built_in">super</span>.context.stop();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-3-环境类"><a href="#5-3-环境类" class="headerlink" title="5.3 环境类"></a>5.3 环境类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> state;<br><br><span class="hljs-comment">//环境角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br><br>    <span class="hljs-comment">//定义一个当前电梯状态</span><br>    <span class="hljs-keyword">private</span> LiftState liftState;<br><br>    <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">getLiftState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.liftState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLiftState</span><span class="hljs-params">(LiftState liftState)</span> &#123;<br>        <span class="hljs-comment">//当前环境改变</span><br>        <span class="hljs-built_in">this</span>.liftState = liftState;<br>        <span class="hljs-comment">//把当前的环境通知到各个实现类中</span><br>        <span class="hljs-built_in">this</span>.liftState.setContext(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.liftState.open();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.liftState.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.liftState.run();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.liftState.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-测试类"><a href="#5-4-测试类" class="headerlink" title="5.4 测试类"></a>5.4 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>        <span class="hljs-type">StateMachine</span> <span class="hljs-variable">stateMachine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateMachine</span>();<br>        context.setLiftState(stateMachine.runningState);<br>        context.open();<br>        context.close();<br>        context.run();<br>        context.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-技术要点总结"><a href="#6-技术要点总结" class="headerlink" title="6.技术要点总结"></a>6.技术要点总结</h2><ul><li>必须要有一个Context类，这个类持有State接口，负责保持并切换当前的状态。</li><li>状态模式没有定义在哪里进行状态转换，本例是在具体的State类中转换</li></ul><p><strong>当使用Context类切换状态时</strong>，状态类之间互相不认识，他们直接的依赖关系应该由客户端负责。</p><p><strong>当使用具体的State类切换时</strong>，状态直接就可能互相认识，一个状态执行完就自动切换到了另一个状态去了</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-网络层</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="1-网络层功能概述"><a href="#1-网络层功能概述" class="headerlink" title="1.网络层功能概述"></a>1.网络层功能概述</h2><p>主要任务是把分组从源端传到目的端,为分组交换网上的不同主机提供通信服务。<code>网络层传输单位是数据报</code>。</p><p>功能：</p><ol><li>路由选择与分组转发（最佳路径）</li><li>异构网络互联</li><li>拥塞控制（若所有结点都来不及接受分组,而要丢弃大量分组的话,网络就处于拥塞状态。因此要采取一定措施,缓解这种拥塞）<ul><li>开环控制——静态控制</li><li>闭环控制——动态控制</li></ul></li></ol><h2 id="2-SDN的基本概念"><a href="#2-SDN的基本概念" class="headerlink" title="2.SDN的基本概念"></a>2.SDN的基本概念</h2><h3 id="2-1-概念引入："><a href="#2-1-概念引入：" class="headerlink" title="2.1 概念引入："></a>2.1 概念引入：</h3><h4 id="2-2-网络层最基本的功能："><a href="#2-2-网络层最基本的功能：" class="headerlink" title="2.2 网络层最基本的功能："></a>2.2 网络层最基本的功能：</h4><ol><li><p>转发：</p><p>达到路由器输入链路之一的数据报如何转发到该路由器的输出链路之一。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240204002524.png"></li><li><p>路由选择：</p><p>控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240204005427.png"></li></ol><p>转发————数据平面：   数据平面对于数据处理过程中各种具体处理转发过程。</p><p>路由选择————控制平面： 控制平面用于控制和管理网络协议的运行。比如 OSPF协议、RIP协议、BGP协议。</p><h4 id="2-2-2-数据平面"><a href="#2-2-2-数据平面" class="headerlink" title="2.2.2 数据平面"></a>2.2.2 数据平面</h4><p>​数据平面执行的主要功能是根据<code>转发表</code>进行转发,这是路由器的本地动作。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240206213526.png"><h4 id="2-2-3控制平面"><a href="#2-2-3控制平面" class="headerlink" title="2.2.3控制平面"></a>2.2.3控制平面</h4><ol><li>每路由器法(传统方法)</li></ol><p>路由选择算法运行在每台路由器中,并且在每台路由器中都包含转发和路由选择两种功能。</p><p>具体方法:</p><p><code>在一台路由器中的路由选择算法与其他路由器中的路由选择算法通信(通过交换路由选择报文),计算出路由表和转发表。</code></p><ol start="2"><li>SDN法(传统方法)</li></ol><p>控制平面从路由器物理上分离。路由器仅实现转发,远程控制器计算和分发转发表以供每台路由器所使用。</p><p>具体方法：</p><p><code>路由器通过交换包含转发表和其他路由选择信息的报文与远程控制器通信。因为计算转发并与路由器交互的控制器是用软件实现的,所以网络是&quot;软件定义的&quot;。</code></p><h3 id="2-2路由选择处理器"><a href="#2-2路由选择处理器" class="headerlink" title="2.2路由选择处理器"></a>2.2路由选择处理器</h3><ul><li><p>传统方法:</p><div class="note note-success">            <p>路由选择处理器执行控制平面功能。在传统的路由器中,它执行路由选择协议,维护路由选择表于关联链路状态信息,并为该路由器计算转发表。</p>          </div></li><li><p>SDN方法:</p><div class="note note-success">            <p>在SDN路由器中,路由选择处理器负责不远程控制器通信,目的是接收远程控制器计算的转发表项。</p>          </div></li></ul><h3 id="2-3-SDN概述"><a href="#2-3-SDN概述" class="headerlink" title="2.3 SDN概述"></a>2.3 SDN概述</h3><p>SDN（Software Defined Network）软件定义网络。</p><p>2006年，以斯坦福大学教授Nike Mckewn为首的团队提出了OpenFlow的概念，并基于OpenFlow技术实现网络的可编程能力（OpenFlow只是实现SDN的一协议），是网络像软件一样灵活编程，SDN技术应运而生。<br>SDN的定义是其字面意思，控制与转发分离，管理与控制分离只是满足SDN的一种手段，OpenFlow只是满足SDN的一种协议。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git基本命令-2</title>
    <link href="/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/"/>
    <url>/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="一、Git-基本概念"><a href="#一、Git-基本概念" class="headerlink" title="一、Git 基本概念"></a>一、Git 基本概念</h2><p>在介绍如何进行git版本回退前，我们需要先了解下git中的4个区：</p><ul><li><p>工作区（Working Area）：就相当于我们的工作空间的目录，我们代码本地存放的地方。</p></li><li><p>暂存区（Stage）：也称作Index，用来跟踪已暂存的文件，一般是存在.git下的index文件，所以有时也称暂存区为索引。</p></li><li><p>本地仓库（Local Repository）</p></li><li><p>远程仓库（Remote Repository）</p></li></ul><p>我们还需要了解下git文件的5种状态</p><ul><li>未修改（Origin）</li><li>已修改（Modified）</li><li>已暂存（Staged）</li><li>已提交（Committed）</li><li>已推送（Pushed）</li></ul><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240201231605.png"><h2 id="二、工作流程"><a href="#二、工作流程" class="headerlink" title="二、工作流程"></a>二、工作流程</h2><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240201233759.png"><h2 id="三、基本命令"><a href="#三、基本命令" class="headerlink" title="三、基本命令"></a>三、基本命令</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><hr><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">将文件从暂存区和工作区中删除。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr><tr><td align="left"><code>git checkout</code></td><td align="left">分支切换。</td></tr><tr><td align="left"><code>git switch （Git 2.23 版本引入）</code></td><td align="left">更清晰地切换分支。</td></tr><tr><td align="left"><code>git restore （Git 2.23 版本引入）</code></td><td align="left">恢复或撤销文件的更改。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><h2 id="四、版本回退"><a href="#四、版本回退" class="headerlink" title="四、版本回退"></a>四、版本回退</h2><p>版本回退主要就是在<code>已提交</code>代码和<code>已推送</code>代码之间操作。</p><p>回退命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gas">git reset [--soft | --mixed | --hard] [HEAD]<br></code></pre></td></tr></table></figure><p><strong>–mixed</strong> 为默认，可以不用带该参数</p><p>–soft 、–mixed以及–hard是三个恢复等级。</p><div class="note note-success">            <ul><li>使用–soft就仅仅将头指针恢复，已经add的暂存区以及工作空间的所有东西都不变。</li><li>如果使用–mixed，就将头恢复掉，已经add的暂存区也会丢失掉，工作空间的代码什么的是不变的。</li><li>如果使用–hard，那么一切就全都恢复了，头变，aad的暂存区消失，代码什么的也恢复到以前状态。</li></ul>          </div><p>具体实例：</p><ol><li>软回退：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apl">git reset --mixed head #当前版本<br>git reset --mixed HEAD^ #回退到上一个版本<br>git reset --mixed HEAD^^ #回退到上上一个版本<br>git reset --mixed HEAD~3 #回退到往上3个版本<br>git reset --mixed HEAD~10 #回退到往上10个版本<br>git reset HEAD^            # 回退所有内容到上一个版本  <br>git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本  <br>git  reset  052e           # 回退到指定版本 052e<br></code></pre></td></tr></table></figure><ol start="2"><li>硬回退</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apl">git reset --hard HEAD~3  # 回退上上上一个版本  <br>git reset –hard bae128  # 回退到某个版本回退点之前的所有信息。 bae128<br>git reset --hard origin/master    # 将本地的状态回退到和远程的一样 <br></code></pre></td></tr></table></figure><p><strong>HEAD 说明：</strong></p><ul><li><p>HEAD 表示当前版本</p></li><li><p>HEAD^ 上一个版本</p></li><li><p>HEAD^^ 上上一个版本</p></li><li><p>HEAD^^^ 上上上一个版本</p></li><li><p>以此类推…</p></li></ul><p>可以使用 ～数字表示</p><ul><li>HEAD~0 表示当前版本</li><li>HEAD~1 上一个版本</li><li>HEAD^2 上上一个版本</li><li>HEAD^3 上上上一个版本</li><li>以此类推…</li></ul><h2 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h2><h3 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch<br></code></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch &lt;branch&gt;  #创建分支<br>git checkout -b &lt;branch&gt;  #创建并且切换到新的分支<br></code></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支:"></a>切换分支:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout (branchname)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">分支切换回主分支master</span><br>git checkout master<br></code></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>当分支切换回主分支的时候，可以将dev的修改提交合并到master分支上，使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">合并dev到master</span><br>git merge dev<br></code></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d (branchname)<br></code></pre></td></tr></table></figure><h2 id="六、远程库管理"><a href="#六、远程库管理" class="headerlink" title="六、远程库管理"></a>六、远程库管理</h2><p>要查看当前配置有哪些远程仓库，可以用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote<br></code></pre></td></tr></table></figure><p>从远程仓库下载新分支与数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fetch<br></code></pre></td></tr></table></figure><p>该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p><p>从远端仓库提取数据并尝试合并到当前分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge<br></code></pre></td></tr></table></figure><p>删除远程仓库你可以使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote rm [别名]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具知识</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WiFi adb 连接</title>
    <link href="/WiFi-adb-%E8%BF%9E%E6%8E%A5/"/>
    <url>/WiFi-adb-%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="WiFi-adb-连接过程"><a href="#WiFi-adb-连接过程" class="headerlink" title="WiFi adb 连接过程"></a>WiFi adb 连接过程</h1><div class="note note-success">            <p>设备和电脑需要连接相同的热点，保证处于同一局域网内。</p>          </div><ol><li>请求临时root权限。</li><li>adb remount命令用于重新挂载设备的&#x2F;system分区为可读写模式。可以借用ADB工具向&#x2F;system分区推送文件或进行必要的系统级别修改</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">adb root<br>adb remount<br></code></pre></td></tr></table></figure><p>３.命令查询IP地址，<code>wlan开头的inet addr:后面的就是 IP 地址</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">adb shell ifconfig<br></code></pre></td></tr></table></figure><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/img_v3_027d_95f08eb9-53dc-4c91-a8c7-f6fb455041fg.jpg"><p>４.开启远程连接 接口5555，或者选择其他一个空闲的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">adb tcpip 5555<br></code></pre></td></tr></table></figure><p>5.指IP地址，然后查看是否连接成功。例如：<code>adb connect 192.168.108.89：5555</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">adb connect **.***.**.**：5555 <br></code></pre></td></tr></table></figure><p>6.如果连接成功，会显示两个设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apl">PS C:\Users\Sc\Desktop&gt; adb devices<br>List of devices attached<br>0000000000000000        device<br>192.168.108.89:5555     device<br></code></pre></td></tr></table></figure><p>7.退出远程连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">adb disconnect<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具知识</category>
      
      <category>adb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式(Java版)</title>
    <link href="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Java/"/>
    <url>/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Java/</url>
    
    <content type="html"><![CDATA[<h2 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h2><table><thead><tr><th>是否 Lazy 初始化</th><th>否</th></tr></thead><tbody><tr><td>是否多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>易</td></tr></tbody></table><ul><li><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。</li><li>优点：没有加锁，执行效率会提高。</li><li>缺点：类加载时就初始化，浪费内存。</li></ul><p>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-双检锁-x2F-双重校验锁"><a href="#2-双检锁-x2F-双重校验锁" class="headerlink" title="2. 双检锁&#x2F;双重校验锁"></a>2. 双检锁&#x2F;双重校验锁</h2><p>需要增加 volatile 关键字，禁止指令重排序：</p><table><thead><tr><th>是否 Lazy 初始化</th><th>是</th></tr></thead><tbody><tr><td>是否多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>较复杂</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-comment">//volatile关键字</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-comment">// 判断对象是否以及实例化过，没有则进入加锁代码块，此处可能有多个线程同时进来，等待类对象锁</span><br>      <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>      <span class="hljs-comment">// 获取类对象锁，其他线程在外等待，其他线程进来再次判断，如果对象实例化了，则不需要再实例化</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>          instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-登记式-x2F-静态内部类"><a href="#3-登记式-x2F-静态内部类" class="headerlink" title="3.登记式&#x2F;静态内部类"></a>3.登记式&#x2F;静态内部类</h2><table><thead><tr><th>是否 Lazy 初始化</th><th>是</th></tr></thead><tbody><tr><td>是否多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>一般</td></tr></tbody></table><p><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p><p>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 1种方式不同的是：第 1 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 1 种方式就显得很合理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4.枚举"></a>4.枚举</h2><table><thead><tr><th>是否 Lazy 初始化</th><th>否</th></tr></thead><tbody><tr><td>是否多线程安全</td><td>是</td></tr><tr><td>实现难度</td><td>易</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    INSTANCE;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">whateverMethod</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ol><li>涉及到序列号的时候，可以使用<code>枚举单例</code></li><li>明确实现 lazy loading 效果时，才会使用登记式&#x2F;静态内部类。</li><li>正常情况下可以使用<code>双检锁/双重校验锁</code>和<code>饿汉式</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式(C++版)</title>
    <link href="/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-C-%E7%89%88/"/>
    <url>/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-C-%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>关于状态模式的一些概念可以查看 <a href="http://luxi.natapp1.cc/2024/02/05/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88java%E7%89%88%EF%BC%89/">状态模式 JAVA</a></p><h2 id="1-类图"><a href="#1-类图" class="headerlink" title="1.类图"></a>1.类图</h2><p><img src="https://subingwen.cn/design-patterns/state/image-20220925230648189.png" alt="https://subingwen.cn/design-patterns/state/image-20220925230648189.png"></p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h2><h3 id="2-1Sanji-h"><a href="#2-1Sanji-h" class="headerlink" title="2.1Sanji.h"></a>2.1Sanji.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Sanji.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;State.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sanji</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Sanji</span>()<br>&#123;<br>m_state = <span class="hljs-keyword">new</span> ForenoonState;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">working</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_state-&gt;<span class="hljs-built_in">working</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(AbstractState* state)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_state != <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_state;<br>&#125;<br>m_state = state;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setClock</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br>m_clock = time;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getClock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_clock;<br>&#125;<br>~<span class="hljs-built_in">Sanji</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> m_state;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_clock = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 时钟</span><br>AbstractState* m_state = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-state-h"><a href="#2-2-state-h" class="headerlink" title="2.2 state.h"></a>2.2 state.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// State.h</span><br><span class="hljs-comment">// 抽象状态</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sanji</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractState</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">working</span><span class="hljs-params">(Sanji* sanji)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractState</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 上午状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ForenoonState</span> : <span class="hljs-keyword">public</span> AbstractState<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">working</span><span class="hljs-params">(Sanji* sanji)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 中午状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoonState</span> : <span class="hljs-keyword">public</span> AbstractState<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">working</span><span class="hljs-params">(Sanji* sanji)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 下午状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AfternoonState</span> : <span class="hljs-keyword">public</span> AbstractState<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">working</span><span class="hljs-params">(Sanji* sanji)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 晚上状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EveningState</span> : <span class="hljs-keyword">public</span> AbstractState<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">working</span><span class="hljs-params">(Sanji* sanji)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="2-3State-cpp"><a href="#2-3State-cpp" class="headerlink" title="2.3State.cpp"></a>2.3State.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;State.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sanji.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ForenoonState::working</span><span class="hljs-params">(Sanji* sanji)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> time = sanji-&gt;<span class="hljs-built_in">getClock</span>();<br><span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">8</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前时间&lt;&quot;</span> &lt;&lt; time &lt;&lt; <span class="hljs-string">&quot;&gt;点, 准备早餐, 布鲁克得多喝点牛奶...&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">8</span> &amp;&amp; time &lt; <span class="hljs-number">11</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前时间&lt;&quot;</span> &lt;&lt; time &lt;&lt; <span class="hljs-string">&quot;&gt;点, 去船头钓鱼, 储备食材...&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>sanji-&gt;<span class="hljs-built_in">setState</span>(<span class="hljs-keyword">new</span> NoonState);<br>sanji-&gt;<span class="hljs-built_in">working</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NoonState::working</span><span class="hljs-params">(Sanji* sanji)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> time = sanji-&gt;<span class="hljs-built_in">getClock</span>();<br><span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">13</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前时间&lt;&quot;</span> &lt;&lt; time &lt;&lt; <span class="hljs-string">&quot;&gt;点, 去厨房做午饭, 给路飞多做点肉...&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>sanji-&gt;<span class="hljs-built_in">setState</span>(<span class="hljs-keyword">new</span> AfternoonState);<br>sanji-&gt;<span class="hljs-built_in">working</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AfternoonState::working</span><span class="hljs-params">(Sanji* sanji)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> time = sanji-&gt;<span class="hljs-built_in">getClock</span>();<br><span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">15</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前时间&lt;&quot;</span> &lt;&lt; time &lt;&lt; <span class="hljs-string">&quot;&gt;点, 准备下午茶, 给罗宾和娜美制作爱心甜点...&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">15</span> &amp;&amp; time &lt; <span class="hljs-number">18</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前时间&lt;&quot;</span> &lt;&lt; time &lt;&lt; <span class="hljs-string">&quot;&gt;点, 和乔巴去船尾钓鱼, 储备食材...&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>sanji-&gt;<span class="hljs-built_in">setState</span>(<span class="hljs-keyword">new</span> EveningState);<br>sanji-&gt;<span class="hljs-built_in">working</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EveningState::working</span><span class="hljs-params">(Sanji* sanji)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> time = sanji-&gt;<span class="hljs-built_in">getClock</span>();<br><span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">19</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前时间&lt;&quot;</span> &lt;&lt; time &lt;&lt; <span class="hljs-string">&quot;&gt;点, 去厨房做晚饭, 让索隆多喝点汤...&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前时间&lt;&quot;</span> &lt;&lt; time &lt;&lt; <span class="hljs-string">&quot;&gt;点, 今天过得很高兴, 累了睡觉了...&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试程序：main-cpp"><a href="#测试程序：main-cpp" class="headerlink" title="测试程序：main.cpp"></a>测试程序：main.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;State.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sanji.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Sanji* sanji = <span class="hljs-keyword">new</span> Sanji;<br>    <span class="hljs-comment">// 时间点</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; data&#123; <span class="hljs-number">10</span>,<span class="hljs-number">22</span> &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : data)<br>    &#123;<br>        sanji-&gt;<span class="hljs-built_in">setClock</span>(item);<br>        sanji-&gt;<span class="hljs-built_in">working</span>();<br>    &#125;<br>    <span class="hljs-keyword">delete</span> sanji;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>孤儿/僵尸/守护进程</title>
    <link href="/%E5%AD%A4%E5%84%BF%E5%83%B5%E5%B0%B8%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <url>/%E5%AD%A4%E5%84%BF%E5%83%B5%E5%B0%B8%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h1><p>讲到进程，我们要先了解一下另一个概念：<code>程序</code>。</p><p>程序说白了就是躺在电脑硬盘上的一个文件而已（如同硬盘女神一样），在被 CPU 执行之前，它啥也做不了。</p><p>当程序被执行之后，它运行的实例就称为<code>进程</code> 。一个程序可以对应多个进程。</p><p>进程是系统的工作单元。系统由多个进程组成，其中有的是操作系统进程（执行系统代码），其他的是用户进程（执行用户代码）。所有这些进程都会并发执行，例如通过在单 CPU 上采用多路复用来实现。</p><p>你可以使用 <span class="label label-primary">ps</span>命令查看 Linux 系统中的所有进程 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">$ ps -ax<br>        PID TTY         STAT   <span class="hljs-selector-tag">TIME</span> COMMAND<br>        <span class="hljs-number">1</span> ?     Ss      <span class="hljs-number">0</span>:<span class="hljs-number">01</span> /usr/lib/systemd/systemd rhgb --switched-root --sys<br>        <span class="hljs-number">2</span> ?     S       <span class="hljs-number">0</span>:<span class="hljs-number">00</span> [kthreadd]<br>        <span class="hljs-number">3</span> ?     I&lt;      <span class="hljs-number">0</span>:<span class="hljs-number">00</span> [rcu_gp]<br>        <span class="hljs-number">4</span> ?     I&lt;      <span class="hljs-number">0</span>:<span class="hljs-number">00</span> [rcu_par_gp]<br></code></pre></td></tr></table></figure><p>当一个进程调用 <code>fork</code> 函数生成另一个进程，原进程就称为父进程，新生成的进程则称为子进程。</p><p>Linux 系统中这样父子进程非常多，我们可以使用 <code>pstree</code> 命令查看系统上的进程「谱系」。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ pstree -psn<br><span class="hljs-built_in">systemd</span>(<span class="hljs-number">1</span>)─┬─<span class="hljs-built_in">systemd-journal</span>(<span class="hljs-number">952</span>)<br>        ├─<span class="hljs-built_in">systemd-udevd</span>(<span class="hljs-number">963</span>)<br>        ├─<span class="hljs-built_in">systemd-oomd</span>(<span class="hljs-number">1137</span>)<br>        ├─<span class="hljs-built_in">systemd-resolve</span>(<span class="hljs-number">1138</span>)<br>        ├─<span class="hljs-built_in">systemd-userdbd</span>(<span class="hljs-number">1139</span>)─┬─<span class="hljs-built_in">systemd-userwor</span>(<span class="hljs-number">12707</span>)<br>        │                     ├─<span class="hljs-built_in">systemd-userwor</span>(<span class="hljs-number">12714</span>)<br>        │                     └─<span class="hljs-built_in">systemd-userwor</span>(<span class="hljs-number">12715</span>)<br>        ├─<span class="hljs-built_in">auditd</span>(<span class="hljs-number">1140</span>)───&#123;auditd&#125;(<span class="hljs-number">1141</span>)<br>        ├─<span class="hljs-built_in">dbus-broker-lau</span>(<span class="hljs-number">1164</span>)───<span class="hljs-built_in">dbus-broker</span>(<span class="hljs-number">1165</span>)<br>        ├─<span class="hljs-built_in">avahi-daemon</span>(<span class="hljs-number">1166</span>)───<span class="hljs-built_in">avahi-daemon</span>(<span class="hljs-number">1196</span>)<br>        ├─<span class="hljs-built_in">bluetoothd</span>(<span class="hljs-number">1167</span>)<br></code></pre></td></tr></table></figure><p>每个进程在系统中都被分配了一个编号。在这所有的进程中，有个非常特殊的进程，它的 ID 号是 1 。它是系统在引导过程中执行的第一个进程，PID 1 之后的每个后续进程都是它的后代。</p><h1 id="2-孤儿进程"><a href="#2-孤儿进程" class="headerlink" title="2. 孤儿进程"></a>2. 孤儿进程</h1><ul><li>孤儿进程是一个比父进程存活时间更长的进程</li><li>孤立进程被init所采用</li><li>Init等待被收养的子进程终止</li><li>采用孤儿进程后，getppid()返回init的PID；通常下<strong>init的PID为1</strong></li><li>在使用upstart作为init system的系统上，或者在某些配置中使用systemd的系统上，情况是不同的</li></ul><p>父进程如果不等待子进程退出，在子进程之前就结束了自己的“生命”此时的子进程叫做孤儿进程。&#x3D;&#x3D;&#x3D;&#x3D;<strong>爹没了</strong><br>Linux避免系统存在过多的孤儿进程，init进程收留孤儿进程，变成孤儿进程的父进程。&#x3D;&#x3D;&#x3D;&#x3D;<strong>init养父</strong></p><h1 id="3-僵尸进程"><a href="#3-僵尸进程" class="headerlink" title="3.僵尸进程"></a>3.僵尸进程</h1><div class="note note-success">            <p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。 </p>          </div><p><strong>注意：</strong></p><p>​僵尸进程还会消耗一定的系统资源，并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息。一旦父进程得到想要的信息，僵尸进程就会结束。</p><h2 id="3-1僵尸进程怎样产生的："><a href="#3-1僵尸进程怎样产生的：" class="headerlink" title="3.1僵尸进程怎样产生的："></a>3.1<strong>僵尸进程怎样产生的：</strong></h2><p>一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用 exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。<br>在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装 SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了， 那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。<strong>但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是 为什么系统中有时会有很多的僵尸进程。</strong></p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240122003624.png"><h2 id="3-2-查看僵尸进程"><a href="#3-2-查看僵尸进程" class="headerlink" title="3.2 查看僵尸进程"></a>3.2 查看僵尸进程</h2><p>利用命令：<strong>ps</strong>，可以看到有标记为<strong>Z</strong>的进程就是僵尸进程</p><h2 id="3-3-僵尸进程的危害"><a href="#3-3-僵尸进程的危害" class="headerlink" title="3.3 僵尸进程的危害"></a>3.3 僵尸进程的危害</h2><p>内核为每个子进程保留了一个数据结构，包括进程编号、终止状态、使用CPU时间等。父进程如果处理了子进程退出的信息，内核就会释放这个数据结构，父进程如果没有处理子进程退出的信息，内核就不会释放这个数据结构，子进程的进程编号将一直被占用。系统可用的进程编号是有限的，如果产生了大量的僵尸进程，将因为没有可用的进程编号而导致系统不能产生新的进程。</p><h2 id="3-4-如何杀死僵尸进程"><a href="#3-4-如何杀死僵尸进程" class="headerlink" title="3.4 如何杀死僵尸进程"></a>3.4 如何杀死僵尸进程</h2><p>对于普通进程，我们可以通过使用 <code>kill</code> 命令来杀死它们。<code>kill</code> 命令它还有几个兄弟，比如 <code>pkill</code> 和 <code>killall</code> ，虽然它们名称里都带 <code>kill</code> 这样杀气腾腾的字眼，但它们实际上是被设计为向一个或多个进程发送信号。</p><p>在未指定的情况下，这几个命令默认发送的是 <code>SIGTERM</code> 信号。</p><p>普通进程可以被 <code>kill</code> ，但僵尸进程是不行的。为什么？因为僵尸进程本身就已经「死」过一次了！如果还可以再「死」，那「僵尸」这个名号就没多大意义了。</p><p>僵尸进程其实已经就是退出的进程，因此无法再利用kill命令杀死僵尸进程。僵尸进程的罪魁祸首是父进程没有回收它的资源，那我们可以想办法它其它进程去回收僵尸进程的资源，这个进程就是 init 进程。</p><h3 id="3-4-1改写父进程，在子进程死后要为它收尸"><a href="#3-4-1改写父进程，在子进程死后要为它收尸" class="headerlink" title="3.4.1改写父进程，在子进程死后要为它收尸"></a>3.4.1改写父进程，在子进程死后要为它收尸</h3><p>具体做法是接管<strong>SIGCHLD</strong>信号。子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子进程收尸。这是基于这样的原理：就算父进程没有调用 wait，内核也会向它发送SIGCHLD消息，尽管对的默认处理是忽略，如果想响应这个消息，可以设置一个处理函数。</p><h3 id="3-4-2-把父进程杀掉"><a href="#3-4-2-把父进程杀掉" class="headerlink" title="3.4.2 把父进程杀掉"></a>3.4.2 把父进程杀掉</h3><p>父进程死后，僵尸进程成为”孤儿进程”，过继给进程init，init始终会负责清理僵尸进程。它产生的所有僵尸进程也跟着消失。<strong>僵尸进程将会导致资源浪费，而孤儿则不会。</strong></p><h1 id="4-守护进程"><a href="#4-守护进程" class="headerlink" title="4.守护进程"></a>4.守护进程</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><ul><li>守护进程是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或循环等待处理某些事件的发生；它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。</li><li>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机才随之一起停止运行；</li><li>守护进程一般都以root用户权限运行，因为要使用某些特殊的端口（1-1024）或者资源；</li><li>守护进程的父进程一般都是init进程，因为它真正的父进程在fork出守护进程后就直接退出了，所以守护进程都是孤儿进程，由init接管；</li><li>守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。</li><li>守护进程的名称通常以d结尾，比如sshd、xinetd、crond等</li></ul><h2 id="4-2-创建守护进程的过程："><a href="#4-2-创建守护进程的过程：" class="headerlink" title="4.2 创建守护进程的过程："></a>4.2 创建守护进程的过程：</h2><ol><li><p>fork()创建子进程，父进程exit()退出</p><p>这是创建守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。</p></li><li><p>在子进程中调用 setsid() 函数创建新的会话<br>在调用了fork()函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来。</p></li><li><p>再次 fork() 一个孙进程并让子进程退出<br>为什么要再次fork呢，假定有这样一种情况，之前的父进程fork出子进程以后还有别的事情要做，在做事情的过程中因为某种原因阻塞了，而此时的子进程因为某些非正常原因要退出的话，就会形成僵尸进程，所以由子进程fork出一个孙进程以后立即退出，孙进程作为守护进程会被init接管，此时无论父进程想做什么都随它了。</p></li><li><p>在孙进程中调用 chdir() 函数，让根目录 ”&#x2F;” 成为孙进程的工作目录</p><p>这一步也是必要的步骤，使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“&#x2F;mnt&#x2F;usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）。因此，通常的做法是让”&#x2F;“作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如&#x2F;tmp，改变工作目录的常见函数是chdir。</p></li><li><p>在孙进程中调用 umask() 函数，设置进程的文件权限掩码为0</p><p>文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的使用方法为umask(0)。</p></li><li><p>在孙进程中关闭任何不需要的文件描述符<br>同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。</p><p>在上面的第2)步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭。</p></li><li><p>守护进程退出处理<br>当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。所以，守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式(C++版)</title>
    <link href="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>引言：</p><p>面向对象很好地解决了”抽象”的问题,但是必不可免地要付出一定的代价。对于通常情况来讲,面向对象的成本大都可以忽略不不计。但是某些情况,面向对象所带来的成本必须谨慎处理。</p><div class="note note-success">            <p>在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫单例模式。单例模式的典型应用就是任务队列。</p>          </div><h2 id="1-动机-Motivation"><a href="#1-动机-Motivation" class="headerlink" title="1. 动机(Motivation)"></a>1. 动机(Motivation)</h2><ol><li><p>在软件系统中,经常有这样一些特殊的类,必须保证它们在系统中只存在一个实例,才能确保它们的逻辑正确性、以及良好的效率。</p></li><li><p>如何绕过常规的构造器,提供一种机制来保证一个类只有一个实例?</p></li><li><p>这应该是类设计者的责任,而不是使用者的责任。</p></li></ol><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><p>我们必须采取一些措施，保证只有一个实例。对于C++而言，涉及一个类多对象操作的函数有以下几个：</p><ol><li>构造函数：创建一个新的对象</li><li>拷贝构造函数：根据已有对象拷贝出一个新的对象</li><li>拷贝赋值操作符重载函数：两个对象之间的赋值</li></ol><p>针对上面的三种情况，我们设计类的时候，应该做如下处理：</p><ol><li><div style="color: rgb(255, 200, 0);">构造函数私有化，在类内部只调用一次，这个是可控的。</div><ul><li>由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是静态的，这样就可以通过类名来访问了，为了不破坏类的封装，我们都会把这个静态对象的访问权限设置为私有的。</li><li>在类中只有它的静态成员函数才能访问其静态成员变量，所以可以给这个单例类提供一个静态函数用于得到这个静态的单例对象。</li></ul></li><li><div style="color: rgb(255, 200, 0);">拷贝构造函数私有化或者禁用（使用 = delete）。</div></li><li><div style="color: rgb(255, 200, 0);">拷贝赋值操作符重载函数私有化或者禁用（从单例的语义上讲这个函数已经毫无意义，所以在类中不再提供这样一个函数，故将它也一并处理一下。）</div></li></ol><h2 id="3-类图"><a href="#3-类图" class="headerlink" title="3.类图"></a>3.类图</h2><p><img src="https://subingwen.cn/design-patterns/singleton/image-20220901082949746.png" alt="image-20220901082949746"></p><h3 id="3-1-定义一个单例模式的类的示例代码"><a href="#3-1-定义一个单例模式的类的示例代码" class="headerlink" title="3.1  定义一个单例模式的类的示例代码"></a>3.1  定义一个单例模式的类的示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义一个单例模式的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; obj) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp; obj) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-type">static</span> Singleton* m_obj;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-具体实现"><a href="#4-具体实现" class="headerlink" title="4.具体实现"></a>4.具体实现</h2><p>在实现一个单例模式的类的时候，有两种处理模式：</p><ul><li>饿汉模式</li><li>懒汉模式</li></ul><p>两者的区别在于</p><ul><li><p><code>饿汉式</code>是在类加载时候完成实：例化的。<code>懒汉式</code>是延时加载的，当需要的时候才进行实例化。</p></li><li><p><code>饿汉式</code>是[线程安全]的,在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。<code>懒汉式</code>需要自己实现线程安全。</p></li></ul><h3 id="4-1-饿汉式实现"><a href="#4-1-饿汉式实现" class="headerlink" title="4.1 饿汉式实现"></a>4.1 饿汉式实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">// 饿汉模式</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span><br>    <span class="hljs-built_in">TaskQueue</span>(<span class="hljs-type">const</span> TaskQueue&amp; obj) = <span class="hljs-keyword">delete</span>;<br>    TaskQueue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TaskQueue&amp; obj) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> TaskQueue* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_taskQ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf_text</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;this is a Singleton&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">TaskQueue</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-type">static</span> TaskQueue* m_taskQ;<br>&#125;;<br><span class="hljs-comment">// 静态成员初始化放到类外部处理</span><br>TaskQueue* TaskQueue::m_taskQ = <span class="hljs-keyword">new</span> TaskQueue;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TaskQueue* obj = TaskQueue::<span class="hljs-built_in">getInstance</span>();<br>    obj-&gt;<span class="hljs-built_in">printf_text</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>定义这个单例类的时候，就把这个静态的单例对象创建出来了。</p><div class="note note-success">            <p>类的静态成员变量在使用之前必须在类的外部进行初始化才能使用。</p>          </div><h3 id="4-2-懒汉式实现"><a href="#4-2-懒汉式实现" class="headerlink" title="4.2 懒汉式实现"></a>4.2 懒汉式实现</h3><p><code>懒汉模式是在类加载的时候不去创建这个唯一的实例，而是在需要使用的时候再进行实例化。</code></p><h4 id="4-2-1-单线程使用，多线程不安全"><a href="#4-2-1-单线程使用，多线程不安全" class="headerlink" title="4.2.1 单线程使用，多线程不安全"></a>4.2.1 单线程使用，多线程不安全</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 懒汉模式</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span><br>    <span class="hljs-built_in">TaskQueue</span>(<span class="hljs-type">const</span> TaskQueue &amp;obj) = <span class="hljs-keyword">delete</span>;<br>    TaskQueue &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TaskQueue &amp;obj) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> TaskQueue *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_taskQ == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m_taskQ = <span class="hljs-keyword">new</span> TaskQueue;<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_taskQ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf_text</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is a Singleton&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">TaskQueue</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-type">static</span> TaskQueue *m_taskQ;<br>&#125;;<br><br>TaskQueue *TaskQueue::m_taskQ = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TaskQueue *obj_1 = TaskQueue::<span class="hljs-built_in">getInstance</span>();<br>    TaskQueue::<span class="hljs-built_in">getInstance</span>()-&gt;<span class="hljs-built_in">printf_text</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用getInstance()函数获取单例对象的时候，如果在单线程情况下是没有什么问题的，如果是多个线程，调用这个函数去访问单例对象就有问题了。假设有三个线程同时执行了getInstance()函数，在这个函数内部每个线程都会new出一个实例对象。此时，这个任务队列类的实例对象不是一个而是3个，很显然这与单例模式的定义是相悖的。</p><h4 id="4-2-2-多线程安全，加锁代价高"><a href="#4-2-2-多线程安全，加锁代价高" class="headerlink" title="4.2.2 多线程安全，加锁代价高"></a>4.2.2 多线程安全，加锁代价高</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 懒汉模式</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-comment">//互斥锁mutex</span><br>std::mutex mt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span><br>    <span class="hljs-built_in">TaskQueue</span>(<span class="hljs-type">const</span> TaskQueue &amp;obj) = <span class="hljs-keyword">delete</span>;<br>    TaskQueue &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TaskQueue &amp;obj) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> TaskQueue *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//加锁</span><br>        mt.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (m_taskQ == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m_taskQ = <span class="hljs-keyword">new</span> TaskQueue;<br>        &#125;<br>        mt.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> m_taskQ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf_text</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is a Singleton&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">TaskQueue</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-type">static</span> TaskQueue *m_taskQ;<br>&#125;;<br><br>TaskQueue *TaskQueue::m_taskQ = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TaskQueue *obj_1 = TaskQueue::<span class="hljs-built_in">getInstance</span>();<br>    TaskQueue::<span class="hljs-built_in">getInstance</span>()-&gt;<span class="hljs-built_in">printf_text</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在资源浪费，当其实只有当存在写操作的时候，我们才需要加锁，现在即使是获取实例，也需要等待。</p><h4 id="4-2-3-双检查锁，由于内存读写导致不安全-reorder导致"><a href="#4-2-3-双检查锁，由于内存读写导致不安全-reorder导致" class="headerlink" title="4.2.3 双检查锁，由于内存读写导致不安全(reorder导致)"></a>4.2.3 双检查锁，由于内存读写导致不安全(reorder导致)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 懒汉模式</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span><br>    <span class="hljs-built_in">TaskQueue</span>(<span class="hljs-type">const</span> TaskQueue &amp;obj) = <span class="hljs-keyword">delete</span>;<br>    TaskQueue &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TaskQueue &amp;obj) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> TaskQueue *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_taskQ == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            mt.<span class="hljs-built_in">lock</span>();<br>            <span class="hljs-keyword">if</span> (m_taskQ == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                m_taskQ = <span class="hljs-keyword">new</span> TaskQueue;  <br>                mt.<span class="hljs-built_in">unlock</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> m_taskQ;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf_text</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is a Singleton&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">TaskQueue</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-type">static</span> TaskQueue *m_taskQ;<br>&#125;;<br><br>TaskQueue *TaskQueue::m_taskQ = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TaskQueue *obj_1 = TaskQueue::<span class="hljs-built_in">getInstance</span>();<br>    TaskQueue::<span class="hljs-built_in">getInstance</span>()-&gt;<span class="hljs-built_in">printf_text</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>“双重检查”Double-Check。看似完美，但是存在致命的问题。</p><p>对于我们正常的思维来说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">m_taskQ = <span class="hljs-keyword">new</span> TaskQueue;  <br></code></pre></td></tr></table></figure><p>应该是会顺序进行下面三个步骤：</p><ol><li><p>singleton对象分配空间。</p></li><li><p>在分配的空间中构造对象</p></li><li><p>使m_taskQ指向分配的空间</p></li></ol><p>但是代码到了汇编层次，到了CPU的指令层，线程的执行顺序是随机的，他需要去抢时间片，所有它的实际步骤会和我们假设的不一样。比如就会<code>分配空间</code>，然后就会<code>使m_taskQ指向分配的空间</code>，最后在进行<code>对象的构造</code>。如果出现了这种情况，那么指针指向内存里面的值是不可用的。</p><p>这样重排序并不影响单线程的执行结果，但是在多线程中就会出问题。如果线程A按照第二种顺序执行机器指令，执行完前两步之后失去CPU时间片被挂起了，此时线程B在第3行处进行指针判断的时候m_taskQ 指针是不为空的，但这个指针指向的内存却没有被初始化，最后线程 B 使用了一个没有被初始化的队列对象就出问题了（出现这种情况是概率问题，需要反复的大量测试问题才可能会出现）。</p><h3 id="4-3-C-11之后的最优解"><a href="#4-3-C-11之后的最优解" class="headerlink" title="4.3  C++11之后的最优解"></a>4.3  C++11之后的最优解</h3><h4 id="4-3-1静态局部对象"><a href="#4-3-1静态局部对象" class="headerlink" title="4.3.1静态局部对象"></a>4.3.1静态局部对象</h4><p>在实现懒汉模式的单例的时候，相较于双重检查锁定模式有一种更简单的实现方法并且不会出现线程安全问题，那就是使用静态局部局部对象，对应的代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 懒汉模式 C++ 11之后可以使用 静态局部变量</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span><br>    <span class="hljs-built_in">TaskQueue</span>(<span class="hljs-type">const</span> TaskQueue&amp; obj) = <span class="hljs-keyword">delete</span>;<br>    TaskQueue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TaskQueue&amp; obj) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> TaskQueue* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> TaskQueue taskQ;<br>        <span class="hljs-keyword">return</span> &amp;taskQ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello, world!!!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">TaskQueue</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TaskQueue* queue = TaskQueue::<span class="hljs-built_in">getInstance</span>();<br>    queue-&gt;<span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种单例被称为<code>Meyers&#39; Singleton</code>。这种方法很简洁，也很完美，但是注意：</p><ol><li>gcc 4.0之后的编译器支持这种写法。</li><li>C++11及以后的版本（如C++14）的多线程下，正确。</li><li>C++11之前<strong>不能</strong>这么写。</li></ol><p>可以这样实现的原因：</p><div class="note note-success">            <p>C++11规定：<strong>如果指令逻辑进入一个未被初始化的声明变量，所有并发执行应当等待该变量完成初始化。如果指令逻辑进入一个未被初始化的声明变量，所有并发执行应当等待该变量完成初始化。</strong></p>          </div><h4 id="4-3-2-原子变量atomic"><a href="#4-3-2-原子变量atomic" class="headerlink" title="4.3.2 原子变量atomic"></a>4.3.2 原子变量atomic</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span><br>    <span class="hljs-built_in">TaskQueue</span>(<span class="hljs-type">const</span> TaskQueue&amp; obj) = <span class="hljs-keyword">delete</span>;<br>    TaskQueue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TaskQueue&amp; obj) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> TaskQueue* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        TaskQueue* queue = m_taskQ.<span class="hljs-built_in">load</span>();  <br>        <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// m_mutex.lock();  // 加锁: 方式1</span><br>            <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(m_mutex)</span></span>;  <span class="hljs-comment">// 加锁: 方式2</span><br>            queue = m_taskQ.<span class="hljs-built_in">load</span>();<br>            <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                queue = <span class="hljs-keyword">new</span> TaskQueue;<br>                m_taskQ.<span class="hljs-built_in">store</span>(queue);<br>            &#125;<br>            <span class="hljs-comment">// m_mutex.unlock();</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello, world!!!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">TaskQueue</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-type">static</span> atomic&lt;TaskQueue*&gt; m_taskQ;<br>    <span class="hljs-type">static</span> mutex m_mutex;<br>&#125;;<br>atomic&lt;TaskQueue*&gt; TaskQueue::m_taskQ;<br>mutex TaskQueue::m_mutex;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TaskQueue* queue = TaskQueue::<span class="hljs-built_in">getInstance</span>();<br>    queue-&gt;<span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中使用原子变量atomic的store() 方法来存储单例对象，使用load() 方法来加载单例对象。在原子变量中这两个函数在处理指令的时候默认的原子顺序是memory_order_seq_cst（顺序原子操作 - sequentially consistent），使用顺序约束原子操作库，整个函数执行都将保证顺序执行，并且不会出现数据竞态（data races），不足之处就是使用这种方法实现的懒汉模式的单例执行效率更低一些。</p><h4 id="4-3-3-call-once方式"><a href="#4-3-3-call-once方式" class="headerlink" title="4.3.3 call_once方式"></a>4.3.3 call_once方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>std::once_flag flag;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::<span class="hljs-built_in">call_once</span>(flag, []() &#123;instance_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>()); &#125;);<br><span class="hljs-keyword">return</span> *instance_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> std::unique_ptr&lt;Singleton&gt; instance_;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; other) = <span class="hljs-keyword">delete</span>;<br>Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br>std::unique_ptr&lt;Singleton&gt; Singleton::instance_;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_onceflag</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Singleton&amp; s = Singleton::<span class="hljs-built_in">getInstance</span>();<br>cout &lt;&lt; &amp;s &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(do_onceflag)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(do_onceflag)</span></span>;<br><br>t1.<span class="hljs-built_in">join</span>();<br>t2.<span class="hljs-built_in">join</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC基础知识</title>
    <link href="/Android%20%E4%B8%AD%E5%AE%9E%E7%8E%B0IPC-1/"/>
    <url>/Android%20%E4%B8%AD%E5%AE%9E%E7%8E%B0IPC-1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Android-中的IPC机制"><a href="#Android-中的IPC机制" class="headerlink" title="Android 中的IPC机制"></a>Android 中的IPC机制</h1><h2 id="1-Android-IPC简介"><a href="#1-Android-IPC简介" class="headerlink" title="1.  Android IPC简介"></a>1.  Android IPC简介</h2><blockquote><p>IPC是Inter-Process Communication的缩写，含义为<strong>进程间通信</strong>或者<strong>跨进程通信</strong>，是指两个进程之间进行数据交换的过程。</p></blockquote><p><strong>线程是CPU调度的最小单元，同时线程是一种有限的系统资源。而进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。</strong>一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。</p><p>🎈最简单的情况下，一个进程中可以只有一个线程，即主线程。在Android里面主线程也叫UI线程，在UI线程里才能操作界面元素。</p><p>很多时候，一个进程中需要执行大量耗时的任务，如果这些任务放在主线程中去执行就会造成界面无法响应，严重影响用户体验，在Android中有一个特殊的名字叫做ANR(Application Not Responding)，即应用无响应。解决这个问题就需要用到线程，把一些耗时的任务放在线程中完成。</p><p>IPC不是Android中独有的，任何一个操作系统都需要有相应的IPC机制。对于Android来说，它是一种基于Linux内核的移动操作系统，它的进程间通信并不能完全继承自Linux。在Android中最有特色的进程间通信方式是Binder，通过Binder可以轻松地实现进程间通信。除了Binder，Android还支持Socket，通过Socket也可以实现任意两个终端之间的通信。</p><p>说到IPC的使用场景就必须提到多进程，只有面对多进程这种场景下，才需要考虑进程间通信。</p><h3 id="1-1-开启一个进程"><a href="#1-1-开启一个进程" class="headerlink" title="1.1 开启一个进程"></a>1.1 开启一个进程</h3><p>通过在四大组件中指定android:process 开启多进程,以下两种方式都可以开启一个进程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.FirstActivity&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:remote&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.SecondActivity&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;com.luxi.LaunchMode:remote&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>两种开启方法有一点区别：</p><ol><li><code>：</code>的含义表示，要在当前进程的前面加上当前的包名，这只是一种简写。</li><li>&#96;：开头的进程属于当前应用的私有进程。其他应用的组件不可以和他运行在同一个进程中。</li><li><code>com.luxi.LaunchMode:remote</code>这种命名方式则是全局进程，其他应用可以通过ShareUID方式可以和他运行在同一个进程下。</li></ol><p>🚑可以这样理解：</p><ol><li><p>如果有两个应用（包名不同），他们具有相同的Share UID，并且签名相同。那么就可以在某些方面共享数据和权限。比如data目录、组件信息。</p><p>比如将apk打成系统apk，需要指定<code>android:sharedUserId=&quot;android.uid.system&quot;</code>，然后还需要系统签名。</p></li><li><p>通过修改process属性，将两个apk（<strong>Share User Id相同</strong>）指定绑定到进程名为com.demo，那么这两个apk可以视为一个应用的两个部分，内存共享。</p></li></ol><p><a href="https://www.cnblogs.com/scarecrow-blog/p/4876560.html">通过共享用户ID来实现多个应用程序使用同一个进程（一些情况的测试） - 午夜稻草人 - 博客园 (cnblogs.com)</a></p><h3 id="1-2-多进程模式的运行机制"><a href="#1-2-多进程模式的运行机制" class="headerlink" title="1.2 多进程模式的运行机制"></a>1.2 多进程模式的运行机制</h3><ol><li><strong>共享用户标识 (Share User Id):</strong> 共享用户标识允许两个或多个应用共享相同的用户 ID 和数据。这意味着它们可以访问并修改对方的数据（前提是有相应的权限）。这在一些特定的应用场景中可能很有用，例如同一个开发者创建的多个应用之间共享用户数据。</li><li><strong>包名不同:</strong> 尽管两个 APK 共享用户标识，但它们的包名是不同的。包名是 Android 系统用于唯一标识每个应用的字符串。由于包名不同，系统会将这两个应用视为不同的应用。</li><li><strong>签名密钥相同:</strong> 由于签名密钥相同，这意味着这两个应用都来自同一个开发者，并且它们可以共享一些签名密钥相关的特性，例如共享相同的数字证书。</li></ol><p>🎄<strong>同一个应用间的多进程</strong>：<strong>它就相当于两个不同的应用采用了SharedUID的模式</strong></p><p>使用多进程会造成如下几个方面的问题：</p><ul><li>静态成员和单例模式完全失效</li><li>线程同步机制完全失效</li><li>SharedPreferences的可靠性下降</li><li>Application会多次创建</li></ul><h2 id="2-进程间的通信原理"><a href="#2-进程间的通信原理" class="headerlink" title="2. 进程间的通信原理"></a>2. 进程间的通信原理</h2><h3 id="2-1-Linux传统的进程间通信"><a href="#2-1-Linux传统的进程间通信" class="headerlink" title="2.1 Linux传统的进程间通信"></a>2.1 Linux传统的进程间通信</h3><div align="center"><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240118223942.png"></div><ol><li>消息发送方将要发送的数据存放在内存缓存区中</li><li>通过系统调用进入内核态</li><li>内核程序在内核空间分配内存,开辟一块内核缓存区</li><li>调用copy_from_user()函数将数据从用户空间的内存缓冲区拷贝到内核空间的内核缓冲区中</li><li>接收方进程在接收数据时在自己的用户空间开辟一块内存缓冲区</li><li>接收方进程接收数据</li></ol><h3 id="2-2-Android中的Binder跨进程通信"><a href="#2-2-Android中的Binder跨进程通信" class="headerlink" title="2.2 Android中的Binder跨进程通信"></a>2.2 Android中的Binder跨进程通信</h3><div align="center"><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240118223718.png"></div><ol><li>首先Binder驱动在内核空间创建一个数据接收的缓存区</li><li>在内核空间开辟一块内核缓存区,建立内核缓存区和内核中数据接收缓存区之间的映射关系,以及内核中数据接收缓存区和接收进程用户空间地址的映射关系</li><li>当发送方进程通过系统调用copy_from_user()将数据copy到内核缓存区时,由于内核缓存区和接收数据的用户空间存在映射关系,所以就直接把数据发送到了接收进程的用户空间,完成了一次进程间的通信.</li></ol><h2 id="3-Android-中进程间通信的方式"><a href="#3-Android-中进程间通信的方式" class="headerlink" title="3.Android 中进程间通信的方式"></a>3.Android 中进程间通信的方式</h2><p>常见的有下面几种方式：</p><ol><li><p>使用Bundle的方式</p></li><li><p>使用文件共享的方式</p></li><li><p>使用Messenger的方式</p></li><li><p>使用AIDL的方式</p></li><li><p>使用ContentProvider的方式</p></li><li><p>使用广播接收者（Broadcast）的方式</p></li><li><p>使用Socket的方式</p></li></ol><h3 id="3-1-使用Bundle的方式"><a href="#3-1-使用Bundle的方式" class="headerlink" title="3.1  使用Bundle的方式"></a>3.1  使用Bundle的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>bundle.putString(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;luxi&quot;</span>);<br>bundle.putInt(<span class="hljs-string">&quot;birthday&quot;</span>, <span class="hljs-number">1997</span>);<br>bundle.putSerializable(<span class="hljs-string">&quot;student&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><ol><li>Bundle传递的数据包括：string、int、boolean、byte、float、long、double等基本类型或它们对应的数组。</li><li>当Bundle传递的是对象或对象数组时，必须实现Serialiable或Parcelable接口。</li><li>Bundle所保存的数据是以key-value(键值对)的形式保存在ArrayMap中</li></ol><h3 id="3-2-使用文件共享的方式"><a href="#3-2-使用文件共享的方式" class="headerlink" title="3.2 使用文件共享的方式"></a>3.2 使用文件共享的方式</h3><ol><li>文件共享对于文件格式没有要求，只要双方约定数据格式即可。</li><li>如果存在并发写入的情况，我们应该使用进程同步限制多个进程的写操作。</li><li>SharedPreferences不能用于共享文件实现进程通信。因为系统对于它的读写有一定的缓存策略，在内存中有SharedPreferences的缓存。在多进程下，系统对他的读写就会变得不可靠。</li></ol><h3 id="3-3-使用Messenger的方式"><a href="#3-3-使用Messenger的方式" class="headerlink" title="3.3 使用Messenger的方式"></a>3.3 使用Messenger的方式</h3><h4 id="3-3-1-Messenger-概述"><a href="#3-3-1-Messenger-概述" class="headerlink" title="3.3.1 Messenger 概述"></a>3.3.1 Messenger 概述</h4><p>Messenger是基于消息Message的传递的一种轻量级IPC进程间通信方式（通过在一个进程中创建一个指向Handler的Messenger，并将该Messenger传递给另一个进程），当然本质就是对Binder的封装（也是通过AIDL实现的 ）。通过Messenger可以让我们可以简单地在进程间直接使用Handler进行Message传递，跨进程是通过Binder（AIDL实现），而消息发送是通过Handler#sendMessage方法，而处理则是Handler#handleMessage处理的；当然除了Handler之外还可以是自定义的相关的某些IBinder接口，简而言之，Messenger的跨进程能力是由构造时关联的对象提供的。</p><h4 id="3-3-2-Messenger-的具体实现"><a href="#3-3-2-Messenger-的具体实现" class="headerlink" title="3.3.2 Messenger 的具体实现"></a>3.3.2 Messenger 的具体实现</h4><div align="center">==============客户端=============</div><p>1. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">mConnection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>           mMessenger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Messenger</span>(service);<br>           mBound = <span class="hljs-literal">true</span>;<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br>           mMessenger = <span class="hljs-literal">null</span>;<br>           mBound = <span class="hljs-literal">false</span>;<br>       &#125;<br>   &#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>准备一个接收服务端消息的Handler</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivityHandle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MainActivityHandle</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper)</span> &#123;<br>        <span class="hljs-built_in">super</span>(looper);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-type">Bundle</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> msg.getData();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">reply</span> <span class="hljs-operator">=</span> data.getString(<span class="hljs-string">&quot;reply&quot;</span>);<br>                Log.d(TAG, <span class="hljs-string">&quot;handleMessage: &quot;</span> + reply);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">super</span>.handleMessage(msg);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>准备一个保存消息的Messenge（从服务端返回的Messenge）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>     <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>     setContentView(R.layout.activity_main);<br><br>     mGetReplyMessenger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Messenger</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MainActivityHandle</span>(Looper.getMainLooper()));<br><br> &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>绑定服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.onStart();<br>    <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, MyService.class);<br>    bindService(intent, mConnection, Context.BIND_AUTO_CREATE);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>向服务端发送消息。   <code>obtain.replyTo = mGetReplyMessenger;</code>将<code>mGetReplyMessenger</code>传递给服务端。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mBound) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">obtain</span> <span class="hljs-operator">=</span> Message.obtain(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>    bundle.putString(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;这是一条消息&quot;</span>);<br>    obtain.setData(bundle);<br>    obtain.replyTo = mGetReplyMessenger;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mMessenger.send(obtain);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div align="center">==============服务端=============</div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> MyService.class.getSimpleName();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Messenger mMessenger;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建线程</span><br>        <span class="hljs-type">HandlerThread</span> <span class="hljs-variable">handlerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span>(<span class="hljs-string">&quot;massage_handle&quot;</span>);<br>        handlerThread.start();<br>        mMessenger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Messenger</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageHandler</span>(handlerThread.getLooper()));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper)</span> &#123;<br>            <span class="hljs-built_in">super</span>(looper);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    Log.d(TAG, <span class="hljs-string">&quot;handleMessage: &quot;</span> + msg);<br>                    <span class="hljs-type">Bundle</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> msg.getData();<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">msg1</span> <span class="hljs-operator">=</span> data.getString(<span class="hljs-string">&quot;msg&quot;</span>);<br>                    Log.d(TAG, <span class="hljs-string">&quot;handleMessage: &quot;</span> + msg1);<br>                    replyToClient(msg);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-built_in">super</span>.handleMessage(msg);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replyToClient</span><span class="hljs-params">(Message msg)</span> &#123;<br>        <span class="hljs-type">Messenger</span> <span class="hljs-variable">replyTo</span> <span class="hljs-operator">=</span> msg.replyTo;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">obtain</span> <span class="hljs-operator">=</span> Message.obtain(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>        bundle.putString(<span class="hljs-string">&quot;reply&quot;</span>, <span class="hljs-string">&quot;返回的消息!!&quot;</span>);<br>        obtain.setData(bundle);<br>        <span class="hljs-keyword">try</span> &#123;<br>            replyTo.send(obtain);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> mMessenger.getBinder();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>IPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>adb基本命令</title>
    <link href="/adb%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/adb%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、ADB是什么？"><a href="#一、ADB是什么？" class="headerlink" title="一、ADB是什么？"></a>一、ADB是什么？</h2><p>adb 称之为：Android 调试桥 （<a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a> ）是一种允许模拟器或已连接的 Android 设备进行通信的命令行工具，它可为各种设备操作提供便利，如安装和调试应用，并提供对 <code>Unix shell</code>（可用来在模拟器或连接的设备上运行各种命令）的访问。可以在<code>Android SDK/platform-tools</code>中找到 <code>adb</code> 工具或下载 <a href="http://adbshell.com/downloads">ADB Kits</a> 。</p><p><strong>注：</strong> 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</p><h2 id="二、ADB有什么作用？"><a href="#二、ADB有什么作用？" class="headerlink" title="二、ADB有什么作用？"></a>二、ADB有什么作用？</h2><p><code>ADB</code> 是 <code>Android SDK</code> 里的一个工具, 用这个工具可以直接操作管理Android模拟器或者真实的Android设备。它的主要功能有:</p><ul><li>在设备上运行Shell命令；</li><li>将本地APK软件安装至模拟器或Android设备；</li><li>管理设备或手机模拟器上的预定端口；</li><li>在设备或手机模拟器上复制或粘贴文件。</li></ul><p><code>ADB</code> 是一个<code>客户端-服务器程序</code>程序，包括三个组件：</p><ul><li><strong>客户端</strong>：该组件发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端。</li><li><strong>后台程序</strong>：该组件在设备上运行命令。后台程序在每个模拟器或设备实例上作为后台进程运行。</li><li><strong>服务器</strong>：该组件管理客户端和后台程序之间的通信。服务器在开发计算机上作为后台进程运行。</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">adb <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><h4 id="4-1-2-启动adb"><a href="#4-1-2-启动adb" class="headerlink" title="4.1.2 启动adb"></a>4.1.2 启动adb</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">adb <span class="hljs-keyword">start</span>-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。</p><h4 id="4-1-3-停止adb"><a href="#4-1-3-停止adb" class="headerlink" title="4.1.3 停止adb"></a>4.1.3 停止adb</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">adb kill-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h4 id="4-1-4-以-root-权限运行-adb"><a href="#4-1-4-以-root-权限运行-adb" class="headerlink" title="4.1.4 以 root 权限运行 adb"></a>4.1.4 以 root 权限运行 adb</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adb root</span><br></code></pre></td></tr></table></figure><h4 id="4-1-5-指定-adb-server-的网络端口"><a href="#4-1-5-指定-adb-server-的网络端口" class="headerlink" title="4.1.5 指定 adb server 的网络端口"></a>4.1.5 指定 adb server 的网络端口</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">adb -P &lt;port&gt; <span class="hljs-keyword">start</span>-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>ADB的默认端口为 5037。</p><h4 id="4-1-5-查询已连接的设备-x2F-模拟器列表"><a href="#4-1-5-查询已连接的设备-x2F-模拟器列表" class="headerlink" title="4.1.5 查询已连接的设备&#x2F;模拟器列表"></a>4.1.5 查询已连接的设备&#x2F;模拟器列表</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adb devices</span><br></code></pre></td></tr></table></figure><h3 id="4-2-应用管理"><a href="#4-2-应用管理" class="headerlink" title="4.2 应用管理"></a>4.2 应用管理</h3><h4 id="4-2-1-查看应用列表"><a href="#4-2-1-查看应用列表" class="headerlink" title="4.2.1 查看应用列表"></a>4.2.1 查看应用列表</h4><p>查看应用列表的基本命令格式是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">adb shell pm list packages <span class="hljs-selector-attr">[-f]</span> <span class="hljs-selector-attr">[-d]</span> <span class="hljs-selector-attr">[-e]</span> <span class="hljs-selector-attr">[-s]</span> <span class="hljs-selector-attr">[-3]</span> <span class="hljs-selector-attr">[-i]</span> <span class="hljs-selector-attr">[-u]</span> <span class="hljs-selector-attr">[--user USER_ID]</span> <span class="hljs-selector-attr">[FILTER]</span> <br></code></pre></td></tr></table></figure><p><code>adb shell pm list packages</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p><table><thead><tr><th align="left">参数</th><th align="left">显示列表</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">所有应用</td></tr><tr><td align="left">-f</td><td align="left">显示应用关联的 apk 文件</td></tr><tr><td align="left">-d</td><td align="left">只显示 disabled 的应用</td></tr><tr><td align="left">-e</td><td align="left">只显示 enabled 的应用</td></tr><tr><td align="left">-s</td><td align="left">只显示系统应用</td></tr><tr><td align="left">-3</td><td align="left">只显示第三方应用</td></tr><tr><td align="left">-i</td><td align="left">显示应用的 installer</td></tr><tr><td align="left">-u</td><td align="left">包含已卸载应用</td></tr><tr><td align="left"><code>&lt;filter&gt;</code></td><td align="left">包名包含 <code>&lt;filter&gt;</code> 字符串</td></tr></tbody></table><h5 id="4-2-1-1-查看所有应用"><a href="#4-2-1-1-查看所有应用" class="headerlink" title="4.2.1.1 查看所有应用"></a>4.2.1.1 查看所有应用</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> pm list packages</span><br></code></pre></td></tr></table></figure><h5 id="4-2-1-2-查看系统应用"><a href="#4-2-1-2-查看系统应用" class="headerlink" title="4.2.1.2 查看系统应用"></a>4.2.1.2 查看系统应用</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> pm list packages -s</span><br></code></pre></td></tr></table></figure><h5 id="4-2-1-3-查看第三方应用"><a href="#4-2-1-3-查看第三方应用" class="headerlink" title="4.2.1.3 查看第三方应用"></a>4.2.1.3 查看第三方应用</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> shell pm list packages -<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="4-2-1-4-包名包含某字符串的应用"><a href="#4-2-1-4-包名包含某字符串的应用" class="headerlink" title="4.2.1.4 包名包含某字符串的应用"></a>4.2.1.4 包名包含某字符串的应用</h5><p>比如要查看包名包含字符串 <code>huawei</code> 的应用列表，命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> pm list packages huawei</span><br></code></pre></td></tr></table></figure><h4 id="4-2-2-安装应用"><a href="#4-2-2-安装应用" class="headerlink" title="4.2.2 安装应用"></a>4.2.2 安装应用</h4><p>安装应用的基本命令格式是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">adb install <span class="hljs-selector-attr">[-l]</span> <span class="hljs-selector-attr">[-r]</span> <span class="hljs-selector-attr">[-t]</span> <span class="hljs-selector-attr">[-s]</span> <span class="hljs-selector-attr">[-d]</span> <span class="hljs-selector-attr">[-g]</span> &lt;apk-file&gt;<br></code></pre></td></tr></table></figure><p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-l</td><td align="left">将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td></tr><tr><td align="left">-r</td><td align="left">允许覆盖安装</td></tr><tr><td align="left">-t</td><td align="left">允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td></tr><tr><td align="left">-s</td><td align="left">将应用安装到 sdcard</td></tr><tr><td align="left">-d</td><td align="left">允许降级覆盖安装</td></tr><tr><td align="left">-g</td><td align="left">授予所有运行时权限</td></tr></tbody></table><p>运行命令后可以看到输出内容，包含安装进度和状态，安装状态如下：</p><ul><li><code>Success</code>：代表安装成功。</li><li><code>Failure</code>：代表安装失败。 APK 安装失败的情况有很多，<code>Failure</code>状态之后有安装失败输出代码。常见安装失败输出代码、含义及可能的解决办法如下：</li></ul><table><thead><tr><th align="left">输出代码</th><th align="left">含义</th><th align="left">解决办法</th></tr></thead><tbody><tr><td align="left">INSTALL_FAILED_ALREADY_EXISTS</td><td align="left">应用已经存在，或卸载了但没卸载干净</td><td align="left"><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td></tr><tr><td align="left">INSTALL_FAILED_INVALID_APK</td><td align="left">无效的 APK 文件</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_INVALID_URI</td><td align="left">无效的 APK 文件名</td><td align="left">确保 APK 文件名里无中文</td></tr><tr><td align="left">INSTALL_FAILED_INSUFFICIENT_STORAGE</td><td align="left">空间不足</td><td align="left">清理空间</td></tr><tr><td align="left">INSTALL_FAILED_DUPLICATE_PACKAGE</td><td align="left">已经存在同名程序</td><td align="left">public class MyService extends Service {​    private static final String TAG &#x3D; MyService.class.getSimpleName();    private final Messenger mMessenger;​    public MyService() {        &#x2F;&#x2F;创建线程        HandlerThread handlerThread &#x3D; new HandlerThread(“massage_handle”);        handlerThread.start();        mMessenger &#x3D; new Messenger(new MessageHandler(handlerThread.getLooper()));    }​    private class MessageHandler extends Handler {​        public MessageHandler(@NonNull Looper looper) {            super(looper);        }​        @Override        public void handleMessage(@NonNull Message msg) {            switch (msg.what) {                case 1:                    Log.d(TAG, “handleMessage: “ + msg);                    Bundle data &#x3D; msg.getData();                    String msg1 &#x3D; data.getString(“msg”);                    Log.d(TAG, “handleMessage: “ + msg1);                    replyToClient(msg);                    break;                default:                    super.handleMessage(msg);                    break;            }        }    }​​    private void replyToClient(Message msg) {        Messenger replyTo &#x3D; msg.replyTo;        Message obtain &#x3D; Message.obtain(null, 2);        Bundle bundle &#x3D; new Bundle();        bundle.putString(“reply”, “返回的消息!!”);        obtain.setData(bundle);        try {            replyTo.send(obtain);        } catch (RemoteException e) {            e.printStackTrace();        }    }​    @Override    public IBinder onBind(Intent intent) {        return mMessenger.getBinder();​    }}java</td></tr><tr><td align="left">INSTALL_FAILED_NO_SHARED_USER</td><td align="left">请求的共享用户不存在</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_UPDATE_INCOMPATIBLE</td><td align="left">以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td><td align="left">先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td></tr><tr><td align="left">INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td><td align="left">请求的共享用户存在但签名不一致</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_MISSING_SHARED_LIBRARY</td><td align="left">安装包使用了设备上不可用的共享库</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_REPLACE_COULDNT_DELETE</td><td align="left">替换时无法删除</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_DEXOPT</td><td align="left">dex 优化验证失败或空间不足</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_OLDER_SDK</td><td align="left">设备系统版本低于应用要求</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_CONFLICTING_PROVIDER</td><td align="left">设备里已经存在与应用里同名的 content provider</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_NEWER_SDK</td><td align="left">设备系统版本高于应用要求</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_TEST_ONLY</td><td align="left">应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td><td align="left">包含不兼容设备 CPU 应用程序二进制接口的 native code</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_MISSING_FEATURE</td><td align="left">应用使用了设备不可用的功能</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_CONTAINER_ERROR</td><td align="left">1. sdcard 访问失败; 2. 应用签名与 ROM 签名一致，被当作内置应用。</td><td align="left">1. 确认 sdcard 可用，或者安装到内置存储; 2. 打包时不与 ROM 使用相同签名。</td></tr><tr><td align="left">INSTALL_FAILED_INVALID_INSTALL_LOCATION</td><td align="left">1. 不能安装到指定位置; 2. 应用签名与 ROM 签名一致，被当作内置应用。</td><td align="left">1. 切换安装位置，添加或删除 <code>-s</code> 参数; 2. 打包时不与 ROM 使用相同签名。</td></tr><tr><td align="left">INSTALL_FAILED_MEDIA_UNAVAILABLE</td><td align="left">安装位置不可用</td><td align="left">一般为 sdcard，确认 sdcard 可用或安装到内置存储</td></tr><tr><td align="left">INSTALL_FAILED_VERIFICATION_TIMEOUT</td><td align="left">验证安装包超时</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_VERIFICATION_FAILURE</td><td align="left">验证安装包失败</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_PACKAGE_CHANGED</td><td align="left">应用与调用程序期望的不一致</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_UID_CHANGED</td><td align="left">以前安装过该应用，与本次分配的 UID 不一致</td><td align="left">清除以前安装过的残留文件</td></tr><tr><td align="left">INSTALL_FAILED_VERSION_DOWNGRADE</td><td align="left">已经安装了该应用更高版本</td><td align="left">使用 <code>-d</code> 参数</td></tr><tr><td align="left">INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td><td align="left">已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_NOT_APK</td><td align="left">指定路径不是文件，或不是以 <code>.apk</code> 结尾</td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_BAD_MANIFEST</td><td align="left">无法解析的 AndroidManifest.xml 文件</td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td><td align="left">解析器遇到异常</td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_NO_CERTIFICATES</td><td align="left">安装包没有签名</td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td><td align="left">已安装该应用，且签名与 APK 文件不一致</td><td align="left">先卸载设备上的该应用，再安装</td></tr><tr><td align="left">INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td><td align="left">解析 APK 文件时遇到 <code>CertificateEncodingException</code></td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td><td align="left">manifest 文件里没有或者使用了无效的包名</td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td><td align="left">manifest 文件里指定了无效的共享用户 ID</td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td><td align="left">解析 manifest 文件时遇到结构性错误</td><td align="left"></td></tr><tr><td align="left">INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td><td align="left">在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_INTERNAL_ERROR</td><td align="left">因系统问题安装失败</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_USER_RESTRICTED</td><td align="left">用户被限制安装应用</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_DUPLICATE_PERMISSION</td><td align="left">应用尝试定义一个已经存在的权限名称</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_NO_MATCHING_ABIS</td><td align="left">应用包含设备的应用程序二进制接口不支持的 native code</td><td align="left"></td></tr><tr><td align="left">INSTALL_CANCELED_BY_USER</td><td align="left">应用安装需要在设备上确认，但未操作设备或点了取消</td><td align="left">在设备上同意安装</td></tr><tr><td align="left">INSTALL_FAILED_ACWF_INCOMPATIBLE</td><td align="left">应用程序与设备不兼容</td><td align="left"></td></tr><tr><td align="left">INSTALL_FAILED_TEST_ONLY</td><td align="left">APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td><td align="left">通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td></tr><tr><td align="left">does not contain AndroidManifest.xml</td><td align="left">无效的 APK 文件</td><td align="left"></td></tr><tr><td align="left">is not a valid zip file</td><td align="left">无效的 APK 文件</td><td align="left"></td></tr><tr><td align="left">Offline</td><td align="left">设备未连接成功</td><td align="left">先将设备与 adb 连接成功</td></tr><tr><td align="left">unauthorized</td><td align="left">设备未授权允许调试</td><td align="left"></td></tr><tr><td align="left">error: device not found</td><td align="left">没有连接成功的设备</td><td align="left">先将设备与 adb 连接成功</td></tr><tr><td align="left">protocol failure</td><td align="left">设备已断开连接</td><td align="left">先将设备与 adb 连接成功</td></tr><tr><td align="left">Unknown option: -s</td><td align="left">Android 2.2 以下不支持安装到 sdcard</td><td align="left">不使用 <code>-s</code> 参数</td></tr><tr><td align="left">No space left on device</td><td align="left">空间不足</td><td align="left">清理空间</td></tr><tr><td align="left">Permission denied … sdcard …</td><td align="left">sdcard 不可用</td><td align="left"></td></tr><tr><td align="left">signatures do not match the previously installed version; ignoring!</td><td align="left">已安装该应用且签名不一致</td><td align="left">先卸载设备上的该应用，再安装</td></tr></tbody></table><p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java">PackageManager.java</a></p><p><code>adb install</code> 实际是分三步完成：</p><ol><li>push apk 文件到 &#x2F;data&#x2F;local&#x2F;tmp。</li><li>调用 pm install 安装。</li><li>删除 &#x2F;data&#x2F;local&#x2F;tmp 下的对应 apk 文件。</li></ol><h4 id="4-2-3-卸载应用"><a href="#4-2-3-卸载应用" class="headerlink" title="4.2.3 卸载应用"></a>4.2.3 卸载应用</h4><p>卸载应用的基本命令格式是：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">adb uninstall [-k] &lt;<span class="hljs-keyword">package</span>-name&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;package-name&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p><h4 id="4-2-4-清除应用数据与缓存"><a href="#4-2-4-清除应用数据与缓存" class="headerlink" title="4.2.4 清除应用数据与缓存"></a>4.2.4 清除应用数据与缓存</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">adb <span class="hljs-built_in">shell</span> pm <span class="hljs-keyword">clear</span> &lt;package-name&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;package-name&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p><h4 id="4-2-5-查看前台-Activity"><a href="#4-2-5-查看前台-Activity" class="headerlink" title="4.2.5 查看前台 Activity"></a>4.2.5 查看前台 Activity</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> dumpsys activity activities | <span class="hljs-keyword">grep</span> mFocusedActivity<br></code></pre></td></tr></table></figure><h4 id="4-2-6-查看正在运行的-Services"><a href="#4-2-6-查看正在运行的-Services" class="headerlink" title="4.2.6 查看正在运行的 Services"></a>4.2.6 查看正在运行的 Services</h4><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">adb shell dumpsys activity services <span class="hljs-meta">[&lt;package-name&gt;]</span><br></code></pre></td></tr></table></figure><p><code>&lt;package-name&gt;</code> 参数不是必须的，指定 <code>&lt;package-name&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。<code>&lt;package-name&gt;</code> 不一定要给出完整的包名，可以只给一部分，那么所给包名相关的 Services 都会列出来。</p><h4 id="4-2-7-查看应用详细信息"><a href="#4-2-7-查看应用详细信息" class="headerlink" title="4.2.7 查看应用详细信息"></a>4.2.7 查看应用详细信息</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">adb shell dumpsys <span class="hljs-keyword">package</span> <span class="hljs-title">&lt;<span class="hljs-keyword">package</span>-name&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;package-name&gt;</code> 表示应用包名。运行次命令的输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p><h4 id="4-2-7-查看应用安装路径"><a href="#4-2-7-查看应用安装路径" class="headerlink" title="4.2.7 查看应用安装路径"></a>4.2.7 查看应用安装路径</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">adb shell pm <span class="hljs-built_in">path</span> &lt;<span class="hljs-built_in">package</span>-name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-3-与应用交互"><a href="#4-3-与应用交互" class="headerlink" title="4.3 与应用交互"></a>4.3 与应用交互</h3><p>与应用交互主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p><table><thead><tr><th align="left">command</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left"><code>start [options] &lt;intent&gt;</code></td><td align="left">启动 <code>&lt;intent&gt;</code> 指定的 Activity</td></tr><tr><td align="left"><code>startservice [options] &lt;intent&gt;</code></td><td align="left">启动 <code>&lt;intent&gt;</code> 指定的 Service</td></tr><tr><td align="left"><code>broadcast [options] &lt;intent&gt;</code></td><td align="left">发送 <code>&lt;intent&gt;</code> 指定的广播</td></tr><tr><td align="left"><code>force-stop &lt;package-name&gt;</code></td><td align="left">停止 <code>&lt;package-name&gt;</code> 相关的进程</td></tr></tbody></table><p><code>&lt;intent&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p><p>用于决定 intent 对象的选项如下：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>-a &lt;action&gt;</code></td><td align="left">指定 action，比如 <code>android.intent.action.VIEW</code></td></tr><tr><td align="left"><code>-c &lt;category&gt;</code></td><td align="left">指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td></tr><tr><td align="left"><code>-n &lt;component&gt;</code></td><td align="left">指定完整 component 名，用于明确指定启动哪个 Activity</td></tr></tbody></table><p><code>&lt;intent&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>--esn &lt;extra-key&gt;</code></td><td align="left">null 值(只有 key 名)</td></tr><tr><td align="left">&#96;-e</td><td align="left">–es <extra-key> <extra-string-value>&#96;</extra-string-value></extra-key></td></tr><tr><td align="left"><code>--ez &lt;extra-key&gt; &lt;extra-boolean-value&gt;</code></td><td align="left">boolean 值</td></tr><tr><td align="left"><code>--ei &lt;extra-key&gt; &lt;extra-int-value&gt;</code></td><td align="left">integer 值</td></tr><tr><td align="left"><code>--el &lt;extra-key&gt; &lt;extra-long-value&gt;</code></td><td align="left">long 值</td></tr><tr><td align="left"><code>--ef &lt;extra-key&gt; &lt;extra-float-value&gt;</code></td><td align="left">float 值</td></tr><tr><td align="left"><code>--eu &lt;extra-key&gt; &lt;extra-uri-value&gt;</code></td><td align="left">URI</td></tr><tr><td align="left"><code>--ecn &lt;extra-key&gt; &lt;extra-component-name-value&gt;</code></td><td align="left">component name</td></tr><tr><td align="left"><code>--eia &lt;extra-key&gt; &lt;extra-int-value&gt;[,&lt;extra-int-value...]</code></td><td align="left">integer 数组</td></tr><tr><td align="left"><code>--ela &lt;extra-key&gt; &lt;extra-long-value&gt;[,&lt;extra-long-value...]</code></td><td align="left">long 数组</td></tr></tbody></table><h4 id="4-3-1-启动应用-x2F-调起-Activity"><a href="#4-3-1-启动应用-x2F-调起-Activity" class="headerlink" title="4.3.1 启动应用&#x2F; 调起 Activity"></a>4.3.1 启动应用&#x2F; 调起 Activity</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> start [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;intent&gt;</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell am start -a android.settings.SETTINGS                   # 打开系统设置页面<br>adb shell am start -a android.intent.action.DIAL -d tel:10086     # 打开拨号页面<br>adb shell am start -n com.android.mms/.ui.ConversationList        # 打开短信会话列表<br></code></pre></td></tr></table></figure><p>options 是一些改变其行为的选项，支持的可选参数及含义如下：</p><table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-D</td><td align="left">启用调试</td></tr><tr><td align="left">-W</td><td align="left">等待启动完成</td></tr><tr><td align="left">–start-profiler <code>file</code></td><td align="left">启动分析器并将结果发送到 <code>file</code></td></tr><tr><td align="left">-P <code>file</code></td><td align="left">类似于 –start-profiler，但当应用进入空闲状态时分析停止</td></tr><tr><td align="left">-R <code>count</code></td><td align="left">重复 Activity 启动次数</td></tr><tr><td align="left">-S</td><td align="left">启动 Activity 前强行停止目标应用</td></tr><tr><td align="left">–opengl-trace</td><td align="left">启用 OpenGL 函数的跟踪</td></tr><tr><td align="left">–user <code>user_id</code> | current</td><td align="left">指定要作为哪个用户运行；如果未指定，则作为当前用户运行</td></tr></tbody></table><h4 id="4-3-2-调起-Service"><a href="#4-3-2-调起-Service" class="headerlink" title="4.3.2 调起 Service"></a>4.3.2 调起 Service</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> startservice [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;intent&gt;</span><br></code></pre></td></tr></table></figure><p>一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> startservice -n <span class="hljs-keyword">com</span>.android.systemui/.SystemUIService<br></code></pre></td></tr></table></figure><h4 id="4-3-3-停止-Service"><a href="#4-3-3-停止-Service" class="headerlink" title="4.3.3 停止 Service"></a>4.3.3 停止 Service</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> stopservice [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;intent&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-3-4-强制停止应用"><a href="#4-3-4-强制停止应用" class="headerlink" title="4.3.4 强制停止应用"></a>4.3.4 强制停止应用</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> force-<span class="hljs-keyword">stop</span> <span class="hljs-symbol">&lt;packagename&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-4-文件管理"><a href="#4-4-文件管理" class="headerlink" title="4.4 文件管理"></a>4.4 文件管理</h3><h4 id="4-4-1-从模拟器-x2F-设备下载指定的文件到计算机"><a href="#4-4-1-从模拟器-x2F-设备下载指定的文件到计算机" class="headerlink" title="4.4.1 从模拟器&#x2F;设备下载指定的文件到计算机"></a>4.4.1 从模拟器&#x2F;设备下载指定的文件到计算机</h4><p>从模拟器&#x2F;设备下载指定的文件到计算机的基本命令格式是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> pull &lt;remote&gt;<span class="hljs-meta"> [local]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>remote</code>: 模拟器&#x2F;设备里的文件路径</li><li><code>local</code>:计算机上的目录，参数可以省略，默认复制到当前目录</li></ul><p>例如，将 &#x2F;sdcard&#x2F;yibijizhang.apk 下载到计算机的当前目录：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb pull <span class="hljs-regexp">/sdcard/yi</span>bijizhang.apk<br></code></pre></td></tr></table></figure><p>将 &#x2F;sdcard&#x2F;yibijizhang.apk 下载到计算机的当前目录(目录需存在)：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb pull <span class="hljs-regexp">/sdcard/yi</span>bijizhang.apk D:\Download<br></code></pre></td></tr></table></figure><h4 id="4-4-2-将指定的文件从计算机上传到模拟器-x2F-设备"><a href="#4-4-2-将指定的文件从计算机上传到模拟器-x2F-设备" class="headerlink" title="4.4.2 将指定的文件从计算机上传到模拟器&#x2F;设备"></a>4.4.2 将指定的文件从计算机上传到模拟器&#x2F;设备</h4><p>将指定的文件从计算机上传到模拟器&#x2F;设备的基本命令格式是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">adb push <span class="hljs-tag">&lt;<span class="hljs-name">local</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">remote</span>&gt;</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>local</code>:计算机上的文件路径</li><li><code>remote</code>: 模拟器&#x2F;设备里的目录</li></ul><p>例如，将 D:\Download\</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">adb push <span class="hljs-tag">&lt;<span class="hljs-name">local</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">remote</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下载到设备的&#x2F;sdcard&#x2F;music&#x2F;目录：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">adb <span class="hljs-built_in">push</span> D:\Download\<br>adb <span class="hljs-built_in">push</span> &lt;local&gt; &lt;remote&gt;<br><span class="hljs-regexp">/sdcard/mu</span>sic/ <br></code></pre></td></tr></table></figure><h4 id="4-4-4-列出指定目录的内容"><a href="#4-4-4-列出指定目录的内容" class="headerlink" title="4.4.4 列出指定目录的内容"></a>4.4.4 列出指定目录的内容</h4><p>列出模拟器&#x2F;设备上指定目录的内容的基本命令格式是：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">ls</span> [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;directory&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;directory&gt;</code> 表示指定目录，可以省略，表示列出根目录下的所有文件和目录。 <code>adb shell ls</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p><table><thead><tr><th align="left">参数</th><th align="left">显示列表</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">列出目录下的所有文件和目录</td></tr><tr><td align="left">-a</td><td align="left">列出目录下的所有文件(包括隐藏的)</td></tr><tr><td align="left">-i</td><td align="left">列出目录下的所有文件和索引编号</td></tr><tr><td align="left">-s</td><td align="left">列出目录下的所有文件和文件大小</td></tr><tr><td align="left">-n</td><td align="left">列出目录下的所有文件及其 UID和 GID</td></tr><tr><td align="left">-R</td><td align="left">列出目录下的所有子目录中的文件</td></tr></tbody></table><h4 id="4-4-5-切换到目标目录"><a href="#4-4-5-切换到目标目录" class="headerlink" title="4.4.5 切换到目标目录"></a>4.4.5 切换到目标目录</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">cd</span> <span class="hljs-symbol">&lt;directory&gt;</span><br></code></pre></td></tr></table></figure><p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>cd &lt;directory&gt;</code>命令切换到目标目录。</p><h4 id="4-4-6-删除文件或目录"><a href="#4-4-6-删除文件或目录" class="headerlink" title="4.4.6 删除文件或目录"></a>4.4.6 删除文件或目录</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">adb <span class="hljs-built_in">shell</span> rm [options] &lt;<span class="hljs-built_in">files</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">directory</span>&gt;<br></code></pre></td></tr></table></figure><p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>rm [options] &lt;files or directory&gt;</code>命令删除文件或目录。</p><p><code>rm</code> 后面可以跟一些可选参数进行不同的操作，可用参数及含义如下：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">删除文件</td></tr><tr><td align="left">-f</td><td align="left">强制删除文件，系统不提示</td></tr><tr><td align="left">-r</td><td align="left">强制删除指定目录中的所有文件和子目录</td></tr><tr><td align="left">-d</td><td align="left">删除指定目录，即使它是一个非空目录</td></tr><tr><td align="left">-i</td><td align="left">交互式删除，删除前提示</td></tr></tbody></table><p><code>rm -d</code> 等同于 <code>rmdir</code> 命令，有些版本不包含<code>-d</code> 参数。</p><h4 id="4-4-7-创建目录"><a href="#4-4-7-创建目录" class="headerlink" title="4.4.7 创建目录"></a>4.4.7 创建目录</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-built_in">mkdir</span> [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;directory-name&gt;</span><br></code></pre></td></tr></table></figure><p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>mkdir [options] &lt;directory-name&gt;</code>命令创建目录。 <code>mkdir</code> 后面可以跟一些可选参数进行不同的操作，可用参数及含义如下：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">创建指定目录</td></tr><tr><td align="left">-m</td><td align="left">创建指定目录并赋予读写权限</td></tr><tr><td align="left">-p</td><td align="left">创建指定目录及其父目录</td></tr></tbody></table><h4 id="4-4-8-创建空文件或改变文件时间戳"><a href="#4-4-8-创建空文件或改变文件时间戳" class="headerlink" title="4.4.8 创建空文件或改变文件时间戳"></a>4.4.8 创建空文件或改变文件时间戳</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> touch [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;file&gt;</span><br></code></pre></td></tr></table></figure><p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>touch [options] &lt;file&gt;</code>命令创建空文件或改变文件时间戳。</p><p>可通过<code>ls -n &lt;directory&gt;</code> 命令查看文件的时间。</p><h4 id="4-4-9-输出当前目录路径"><a href="#4-4-9-输出当前目录路径" class="headerlink" title="4.4.9 输出当前目录路径"></a>4.4.9 输出当前目录路径</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>pwd</code>命令输出当前目录路径。</p><h4 id="4-4-10-复制文件和目录"><a href="#4-4-10-复制文件和目录" class="headerlink" title="4.4.10 复制文件和目录"></a>4.4.10 复制文件和目录</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">cp</span> [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;source&gt;</span> <span class="hljs-symbol">&lt;dest&gt;</span><br></code></pre></td></tr></table></figure><p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>cp [options] &lt;source&gt; &lt;dest&gt;</code>命令复制文件和目录。 参数说明：</p><ul><li><code>source</code>:源文件路径</li><li><code>dest</code>: 目标文件路径</li></ul><h4 id="4-4-11-移动或重命名文件"><a href="#4-4-11-移动或重命名文件" class="headerlink" title="4.4.11 移动或重命名文件"></a>4.4.11 移动或重命名文件</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> mv [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;source&gt;</span> <span class="hljs-symbol">&lt;dest&gt;</span><br></code></pre></td></tr></table></figure><p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>mv [options] &lt;source&gt; &lt;dest&gt;</code>命令移动或重命名文件。 参数说明：</p><ul><li><code>source</code>:源文件路径</li><li><code>dest</code>: 目标文件路径</li></ul><h3 id="4-5-网络管理"><a href="#4-5-网络管理" class="headerlink" title="4.5 网络管理"></a>4.5 网络管理</h3><h4 id="4-5-1-查看网络统计信息"><a href="#4-5-1-查看网络统计信息" class="headerlink" title="4.5.1 查看网络统计信息"></a>4.5.1 查看网络统计信息</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> netstat</span><br></code></pre></td></tr></table></figure><p>也可以将网络统计信息输出到指定文件：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">adb <span class="hljs-built_in">shell</span> netstat&gt;&lt;<span class="hljs-built_in">file</span>-path&gt;<br></code></pre></td></tr></table></figure><p>例如，可以通过 <code>adb shell netstat&gt;D:\netstat.log</code> 将日志输出到 <code>D:\netstat.log</code> 中。</p><h4 id="4-5-2-测试两个网络间的连接和延迟"><a href="#4-5-2-测试两个网络间的连接和延迟" class="headerlink" title="4.5.2 测试两个网络间的连接和延迟"></a>4.5.2 测试两个网络间的连接和延迟</h4><p><code>ping</code> 命令的格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]<br>[-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]<br>[-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]<br>[-w deadline] [-W timeout] [hop1 ...] destination<br>复制代码<br></code></pre></td></tr></table></figure><p>例如，ping一个域名：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> ping www.baidu.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p>不结束的话会一直ping下去，可以按 <code>Ctrl + C</code> 停止ping操作。</p><p>也可以指定ping的次数：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> ping -<span class="hljs-keyword">c</span> <span class="hljs-number">4</span> www.baidu.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><h4 id="4-5-3-通过配置文件配置和管理网络连接"><a href="#4-5-3-通过配置文件配置和管理网络连接" class="headerlink" title="4.5.3 通过配置文件配置和管理网络连接"></a>4.5.3 通过配置文件配置和管理网络连接</h4><p><code>netcfg</code> 命令的格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">adb shell netcfg [<span class="hljs-variable">&lt;interface&gt;</span> &#123;dhcp|<span class="hljs-string">up</span>|<span class="hljs-string">down&#125;]</span><br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">rmnet_ims10 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_ims00 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun04 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun03 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun02 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun01 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun00 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun14 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun13 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun12 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun11 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_tun10 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet1   DOWN                                   0.0.0.0/0   0x00001002<br>rmnet0   DOWN                                   0.0.0.0/0   0x00001002<br>rmnet4   DOWN                                   0.0.0.0/0   0x00001002<br>rmnet3   DOWN                                   0.0.0.0/0   0x00001002<br>rmnet2   DOWN                                   0.0.0.0/0   0x00001002<br>rmnet6   DOWN                                   0.0.0.0/0   0x00001002<br>rmnet5   DOWN                                   0.0.0.0/0   0x00001002<br>dummy0   UP                                     0.0.0.0/0   0x000000c3<br>rmnet_r_ims10 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_r_ims00 DOWN                                   0.0.0.0/0   0x00001002<br>rmnet_emc0 DOWN                                   0.0.0.0/0   0x00001002<br>lo       UP                                   127.0.0.1/8   0x00000049<br>sit0     DOWN                                   0.0.0.0/0   0x00000080<br>wlan0    UP                                 10.0.38.176/23  0x00001043<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="4-5-4-显示、操作路由、设备、策略路由和隧道"><a href="#4-5-4-显示、操作路由、设备、策略路由和隧道" class="headerlink" title="4.5.4 显示、操作路由、设备、策略路由和隧道"></a>4.5.4 显示、操作路由、设备、策略路由和隧道</h4><p><code>ip</code> 命令的格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">adb shell ip <span class="hljs-selector-attr">[ options ]</span> <span class="hljs-selector-tag">object</span><br></code></pre></td></tr></table></figure><ul><li>options :&#x3D; { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] { inet | inet6 | ipx | dnet | link } |-l[oops] { maximum-addr-flush-attempts } |-o[neline] | -t[imestamp] | -b[atch] [filename] |-rc[vbuf] [size]}</li><li>object :&#x3D; { link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp }</li></ul><p><code>options</code> 是一些修改ip行为或者改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式，支持的可选参数及含义如下：</p><table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-V,-Version</td><td align="left">打印ip的版本并退出</td></tr><tr><td align="left">-s,-stats,-statistics</td><td align="left">输出更为详尽的信息(如果这个选项出现两次或者多次，输出的信息将更为详尽)</td></tr><tr><td align="left">-f,-family</td><td align="left">强调使用的协议种类(包括：inet、inet6或者link)</td></tr><tr><td align="left">-4</td><td align="left">是-family inet的简写</td></tr><tr><td align="left">-6</td><td align="left">是-family inet6的简写</td></tr><tr><td align="left">-0</td><td align="left">是-family link的简写</td></tr><tr><td align="left">-o,-oneline</td><td align="left">对每行记录都使用单行输出，回行用字符代替</td></tr><tr><td align="left">-r,-resolve</td><td align="left">查询域名解析系统，用获得的主机名代替主机IP地址</td></tr></tbody></table><p><code>object</code> 是你要管理或者获取信息的对象。目前ip认识的对象包括：</p><table><thead><tr><th align="left">参数</th><th align="left">显示列表</th></tr></thead><tbody><tr><td align="left">link</td><td align="left">网络设备</td></tr><tr><td align="left">address</td><td align="left">一个设备的协议(IP或者IPV6)地址</td></tr><tr><td align="left">neighbour</td><td align="left">ARP或者NDISC缓冲区条目</td></tr><tr><td align="left">route</td><td align="left">路由表条目</td></tr><tr><td align="left">rule</td><td align="left">路由策略数据库中的规则</td></tr><tr><td align="left">maddress</td><td align="left">多播地址</td></tr><tr><td align="left">mroute</td><td align="left">多播路由缓冲区条目</td></tr><tr><td align="left">tuntap</td><td align="left">管理 TUN&#x2F;TAP 设备</td></tr><tr><td align="left">netns</td><td align="left">管理网络空间</td></tr></tbody></table><p>例如，查看 <code>WiFi IP</code> 地址：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">adb <span class="hljs-keyword">shell </span>ip -f inet <span class="hljs-keyword">addr </span><span class="hljs-keyword">show </span>wlan0<br></code></pre></td></tr></table></figure><h3 id="4-6日志打印"><a href="#4-6日志打印" class="headerlink" title="4.6日志打印"></a>4.6日志打印</h3><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 &#x2F;proc&#x2F;kmsg，Android 的日志输出到 &#x2F;dev&#x2F;log。</p><h4 id="4-6-1-Android-日志"><a href="#4-6-1-Android-日志" class="headerlink" title="4.6.1 Android 日志"></a>4.6.1 Android 日志</h4><p>查看 Android 设备系统属性的基本命令格式是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">adb logcat <span class="hljs-selector-attr">[option]</span> <span class="hljs-selector-attr">[filter-specs]</span><br></code></pre></td></tr></table></figure><p>如果需要停止 <code>logcat</code> 日志打印，可以按 <code>Ctrl + C</code> 停止日志监控。</p><h5 id="4-6-1-1-按级别过滤日志"><a href="#4-6-1-1-按级别过滤日志" class="headerlink" title="4.6.1.1 按级别过滤日志"></a>4.6.1.1 按级别过滤日志</h5><p>按级别过滤日志的基本命令格式是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> logcat<span class="hljs-meta"> [filter-specs]</span><br></code></pre></td></tr></table></figure><p>Android 的日志分为如下几个优先级（priority）：</p><table><thead><tr><th align="left">级别</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">*:V</td><td align="left">过滤只显示 Verbose 及以上级别(优先级最低)</td></tr><tr><td align="left">*:D</td><td align="left">过滤只显示 Debug 及以上级别</td></tr><tr><td align="left">*:I</td><td align="left">过滤只显示 Info 及以上级别</td></tr><tr><td align="left">*:W</td><td align="left">过滤只显示 Warning 及以上级别</td></tr><tr><td align="left">*:E</td><td align="left">过滤只显示 Error 及以上级别</td></tr><tr><td align="left">*:F</td><td align="left">过滤只显示 Fatal 及以上级别</td></tr><tr><td align="left">*:S</td><td align="left">过滤只显示 Silent 及以上级别(优先级最高，什么也不输出)</td></tr></tbody></table><p>按某级别过滤日志则会将该级别及以上的日志输出。</p><p>比如，命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat *:W<br>复制代码<br></code></pre></td></tr></table></figure><p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p><p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p><h5 id="4-7-1-2-按-tag-和级别过滤日志"><a href="#4-7-1-2-按-tag-和级别过滤日志" class="headerlink" title="4.7.1.2 按 tag 和级别过滤日志"></a>4.7.1.2 按 tag 和级别过滤日志</h5><p>按 tag 和级别过滤日志的基本命令格式是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat [tag:level] [tag:level] ...<br>复制代码<br></code></pre></td></tr></table></figure><p>比如，命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat ActivityManager:I MyApp:D *:S<br>复制代码<br></code></pre></td></tr></table></figure><p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p><h5 id="4-6-1-3-将日志格式化输出"><a href="#4-6-1-3-将日志格式化输出" class="headerlink" title="4.6.1.3 将日志格式化输出"></a>4.6.1.3 将日志格式化输出</h5><p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p><p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p><table><thead><tr><th align="left">参数</th><th align="left">显示格式</th></tr></thead><tbody><tr><td align="left">brief</td><td align="left"><code>&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</code></td></tr><tr><td align="left">process</td><td align="left"><code>&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;</code></td></tr><tr><td align="left">tag</td><td align="left"><code>&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;</code></td></tr><tr><td align="left">raw</td><td align="left"><code>&lt;message&gt;</code></td></tr><tr><td align="left">time</td><td align="left"><code>&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</code></td></tr><tr><td align="left">threadtime</td><td align="left"><code>&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;</code></td></tr><tr><td align="left">long</td><td align="left"><code>[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ] &lt;message&gt;</code></td></tr></tbody></table><p>日志格式默认为 <code>brief</code>，指定格式可与上面的过滤同时使用。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat -v long ActivityManager:I *:S<br>复制代码<br></code></pre></td></tr></table></figure><h5 id="4-6-1-3-清空已存在的日志"><a href="#4-6-1-3-清空已存在的日志" class="headerlink" title="4.6.1.3 清空已存在的日志"></a>4.6.1.3 清空已存在的日志</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat -c<br>复制代码<br></code></pre></td></tr></table></figure><h5 id="4-6-1-4-将日志显示在控制台"><a href="#4-6-1-4-将日志显示在控制台" class="headerlink" title="4.6.1.4 将日志显示在控制台"></a>4.6.1.4 将日志显示在控制台</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat -d<br>复制代码<br></code></pre></td></tr></table></figure><h5 id="4-6-1-5-将日志输出到文件"><a href="#4-6-1-5-将日志输出到文件" class="headerlink" title="4.6.1.5 将日志输出到文件"></a>4.6.1.5 将日志输出到文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat -f &lt;file-path&gt;<br>复制代码<br></code></pre></td></tr></table></figure><h5 id="4-6-1-6-加载一个可使用的日志缓冲区供查看"><a href="#4-6-1-6-加载一个可使用的日志缓冲区供查看" class="headerlink" title="4.6.1.6 加载一个可使用的日志缓冲区供查看"></a>4.6.1.6 加载一个可使用的日志缓冲区供查看</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat -b &lt;Buffer&gt;<br>复制代码<br></code></pre></td></tr></table></figure><p><code>Android log</code> 输出量巨大，特别是通信系统的log，因此，Android把log输出到不同的缓冲区中，目前定义了四个log缓冲区：</p><table><thead><tr><th align="left">缓冲区</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Radio</td><td align="left">输出通信系统的 log</td></tr><tr><td align="left">System</td><td align="left">输出系统组件的 log</td></tr><tr><td align="left">Event</td><td align="left">输出 event 模块的 log</td></tr><tr><td align="left">Main</td><td align="left">所有 java 层的 log 以及不属于上面3层的 log</td></tr></tbody></table><p>缓冲区主要给系统组件使用，一般的应用不需要关心，应用的log都输出到main缓冲区中。默认log输出（不指定缓冲区的情况下）是输出System和Main缓冲区的log。</p><h5 id="4-6-1-7-打印指定日志缓冲区的大小"><a href="#4-6-1-7-打印指定日志缓冲区的大小" class="headerlink" title="4.6.1.7 打印指定日志缓冲区的大小"></a>4.6.1.7 打印指定日志缓冲区的大小</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb logcat -g<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="4-6-2-内核日志"><a href="#4-6-2-内核日志" class="headerlink" title="4.6.2 内核日志"></a>4.6.2 内核日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell dmesg<br>复制代码<br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs<br>&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs<br>&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs<br>&lt;4&gt;[14201.755954] Restarting tasks ... done.<br>&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC<br>&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC<br>&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done.<br>复制代码<br></code></pre></td></tr></table></figure><p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p><p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p><h3 id="4-8-查看-Android-设备系统属性"><a href="#4-8-查看-Android-设备系统属性" class="headerlink" title="4.8 查看 Android 设备系统属性"></a>4.8 查看 Android 设备系统属性</h3><p>查看 Android 设备系统属性的基本命令格式是：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> getprop [<span class="hljs-keyword">options</span>]<br></code></pre></td></tr></table></figure><p>除了可以查看 Android 设备系统属性之外，还可以设置系统属性，设置系统属性的基本命令格式是：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> setprop <span class="hljs-symbol">&lt;key&gt;</span> <span class="hljs-symbol">&lt;value&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-8-1-查看设备型号"><a href="#4-8-1-查看设备型号" class="headerlink" title="4.8.1 查看设备型号"></a>4.8.1 查看设备型号</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> getprop ro.product.model</span><br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">huawei mate 30 pro<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="4-8-2-查看设备电池状况"><a href="#4-8-2-查看设备电池状况" class="headerlink" title="4.8.2 查看设备电池状况"></a>4.8.2 查看设备电池状况</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> dumpsys battery</span><br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">Current Battery Service state:<br>  AC powered: false<br>  USB powered: true<br>  Wireless powered: false<br>  status: 2<br>  health: 2<br>  present: true<br>  level: 44<br>  scale: 100<br>  voltage: 3872<br>  temperature: 280<br>  technology: Li-poly<br>复制代码<br></code></pre></td></tr></table></figure><p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p><h4 id="4-8-3-查看设备屏幕分辨率"><a href="#4-8-3-查看设备屏幕分辨率" class="headerlink" title="4.8.3 查看设备屏幕分辨率"></a>4.8.3 查看设备屏幕分辨率</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">adb shell wm size<br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Physical</span> size: <span class="hljs-number">1080</span>x1920<br></code></pre></td></tr></table></figure><p>该设备屏幕分辨率为 1080px * 1920px。</p><p>如果使用命令修改过，那输出可能是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Physical size: 1080x1920<br>Override size: 480x1024<br>复制代码<br></code></pre></td></tr></table></figure><p>表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。</p><h4 id="4-8-4-查看设备屏幕密度"><a href="#4-8-4-查看设备屏幕密度" class="headerlink" title="4.8.4 查看设备屏幕密度"></a>4.8.4 查看设备屏幕密度</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> wm density</span><br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Physical density: 360<br></code></pre></td></tr></table></figure><p>该设备屏幕密度为 360dpi。</p><p>如果使用命令修改过，那输出可能是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Physical</span> density: <span class="hljs-number">420</span><br><span class="hljs-attribute">Override</span> density: <span class="hljs-number">360</span><br></code></pre></td></tr></table></figure><p>表明设备的屏幕密度原来是 420dpi，当前被修改为 360dpi。</p><h4 id="4-8-5-查看设备显示屏参数"><a href="#4-8-5-查看设备显示屏参数" class="headerlink" title="4.8.5 查看设备显示屏参数"></a>4.8.5 查看设备显示屏参数</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">adb <span class="hljs-built_in">shell</span> dumpsys <span class="hljs-built_in">window</span> displays<br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)<br>  Display: mDisplayId=0<br>    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731<br>    deferred=false layoutNeeded=false<br>复制代码<br></code></pre></td></tr></table></figure><p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 &#x3D; 126px 合 42dp。</p><h4 id="4-8-6-查看设备-android-id"><a href="#4-8-6-查看设备-android-id" class="headerlink" title="4.8.6 查看设备 android_id"></a>4.8.6 查看设备 android_id</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">adb shell<span class="hljs-built_in"> settings </span><span class="hljs-built_in">get</span> secure android_id <br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">5a3a3aa2c3042184<br></code></pre></td></tr></table></figure><h4 id="4-8-7-查看设备IMEI"><a href="#4-8-7-查看设备IMEI" class="headerlink" title="4.8.7 查看设备IMEI"></a>4.8.7 查看设备IMEI</h4><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> dumpsys iphonesubinfo</span><br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Phone Subscriber Info:<br>  Phone Type = GSM<br>  Device ID = 860955027785041<br></code></pre></td></tr></table></figure><p>其中的 <code>Device ID</code> 就是 IMEI。</p><p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell<br>su<br>service call iphonesubinfo 1<br></code></pre></td></tr></table></figure><p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>890956027785041</code>。</p><p>参考：<a href="http://stackoverflow.com/questions/27002663/adb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p><h4 id="4-8-8-查看设备-Android-系统版本"><a href="#4-8-8-查看设备-Android-系统版本" class="headerlink" title="4.8.8 查看设备 Android 系统版本"></a>4.8.8 查看设备 Android 系统版本</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">adb <span class="hljs-built_in">shell</span> getprop ro.build.<span class="hljs-built_in">version</span>.release<br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">7.1.2<br></code></pre></td></tr></table></figure><h4 id="4-8-9-查看设备-IP-地址"><a href="#4-8-9-查看设备-IP-地址" class="headerlink" title="4.8.9 查看设备 IP 地址"></a>4.8.9 查看设备 IP 地址</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> ifconfig | <span class="hljs-keyword">grep</span> Mask<br></code></pre></td></tr></table></figure><p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> ifconfig wlan0</span><br></code></pre></td></tr></table></figure><p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> netcfg</span><br></code></pre></td></tr></table></figure><h4 id="4-8-10-查看设备-Mac-地址"><a href="#4-8-10-查看设备-Mac-地址" class="headerlink" title="4.8.10 查看设备 Mac 地址"></a>4.8.10 查看设备 Mac 地址</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">adb shell cat <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/net/</span>wlan0/address <br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">36:0f:a5:9a:c7:7d<br></code></pre></td></tr></table></figure><p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p><h4 id="4-8-11-查看设备-CPU-信息"><a href="#4-8-11-查看设备-CPU-信息" class="headerlink" title="4.8.11 查看设备 CPU 信息"></a>4.8.11 查看设备 CPU 信息</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">cat</span> /proc/cpuinfo</span><br></code></pre></td></tr></table></figure><h4 id="4-8-12-查看设备内存信息"><a href="#4-8-12-查看设备内存信息" class="headerlink" title="4.8.12 查看设备内存信息"></a>4.8.12 查看设备内存信息</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">cat</span> /proc/meminfo</span><br></code></pre></td></tr></table></figure><h4 id="4-8-13-查看设备更多硬件与系统属性"><a href="#4-8-13-查看设备更多硬件与系统属性" class="headerlink" title="4.8.13 查看设备更多硬件与系统属性"></a>4.8.13 查看设备更多硬件与系统属性</h4><p>设备的更多硬件与系统属性可以通过如下命令查看：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">cat</span> /system/build.prop</span><br></code></pre></td></tr></table></figure><p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p><p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p><table><thead><tr><th align="left">属性名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ro.build.version.sdk</td><td align="left">SDK 版本</td></tr><tr><td align="left">ro.build.version.release</td><td align="left">Android 系统版本</td></tr><tr><td align="left">ro.build.version.security_patch</td><td align="left">Android 安全补丁程序级别</td></tr><tr><td align="left">ro.product.model</td><td align="left">型号</td></tr><tr><td align="left">ro.product.brand</td><td align="left">品牌</td></tr><tr><td align="left"><a href="http://ro.product.name/">ro.product.name</a></td><td align="left">设备名</td></tr><tr><td align="left">ro.product.board</td><td align="left">处理器型号</td></tr><tr><td align="left">ro.product.cpu.abilist</td><td align="left">CPU 支持的 abi 列表[<em>节注一</em>]</td></tr><tr><td align="left">persist.sys.isUsbOtgEnabled</td><td align="left">是否支持 OTG</td></tr><tr><td align="left">dalvik.vm.heapsize</td><td align="left">每个应用程序的内存上限</td></tr><tr><td align="left">ro.sf.lcd_density</td><td align="left">屏幕密度</td></tr></tbody></table><p><em>节注一：</em></p><p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">cat</span> /<span class="hljs-built_in">system</span>/build.prop | <span class="hljs-keyword">grep</span> ro.product.cpu.abi<br></code></pre></td></tr></table></figure><p>示例输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ro.product.cpu.abi=armeabi-v7a<br>ro.product.cpu.abi2=armeabi<br></code></pre></td></tr></table></figure><h3 id="4-9-修改设置"><a href="#4-9-修改设置" class="headerlink" title="4.9 修改设置"></a>4.9 修改设置</h3><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p><p>修改设置的原理主要是通过 settings 命令修改 &#x2F;data&#x2F;data&#x2F;com.android.providers.settings&#x2F;databases&#x2F;settings.db 里存放的设置值。</p><h4 id="4-9-1-修改分辨率"><a href="#4-9-1-修改分辨率" class="headerlink" title="4.9.1 修改分辨率"></a>4.9.1 修改分辨率</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> shell wm size <span class="hljs-number">480</span>x1024<br></code></pre></td></tr></table></figure><p>表示将分辨率修改为 480px * 1024px。</p><p>恢复原分辨率命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">adb shell wm size reset<br></code></pre></td></tr></table></figure><h4 id="4-9-2-修改屏幕密度"><a href="#4-9-2-修改屏幕密度" class="headerlink" title="4.9.2 修改屏幕密度"></a>4.9.2 修改屏幕密度</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> shell wm density <span class="hljs-number">160</span><br></code></pre></td></tr></table></figure><p>表示将屏幕密度修改为 160dpi。</p><p>恢复原屏幕密度命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> wm density reset</span><br></code></pre></td></tr></table></figure><h4 id="4-9-3-修改显示区域"><a href="#4-9-3-修改显示区域" class="headerlink" title="4.9.3 修改显示区域"></a>4.9.3 修改显示区域</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> shell wm overscan <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p><p>恢复原显示区域命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb <span class="hljs-keyword">shell</span><span class="language-bash"> wm overscan reset</span><br></code></pre></td></tr></table></figure><h4 id="4-9-4-修改关闭-USB-调试模式"><a href="#4-9-4-修改关闭-USB-调试模式" class="headerlink" title="4.9.4 修改关闭 USB 调试模式"></a>4.9.4 修改关闭 USB 调试模式</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">adb <span class="hljs-built_in">shell</span> settings <span class="hljs-built_in">put</span> <span class="hljs-built_in">global</span> adb_enabled <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p><h4 id="4-9-5-修改允许-x2F-禁止访问非-SDK-API"><a href="#4-9-5-修改允许-x2F-禁止访问非-SDK-API" class="headerlink" title="4.9.5 修改允许&#x2F;禁止访问非 SDK API"></a>4.9.5 修改允许&#x2F;禁止访问非 SDK API</h4><p>允许访问非 SDK API：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell settings put global hidden_api_policy_pre_p_apps 1<br>adb shell settings put global hidden_api_policy_p_apps 1<br>复制代码<br></code></pre></td></tr></table></figure><p>禁止访问非 SDK API：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell settings delete global hidden_api_policy_pre_p_apps<br>adb shell settings delete global hidden_api_policy_p_apps<br>复制代码<br></code></pre></td></tr></table></figure><p>不需要设备获得 Root 权限。</p><p>命令最后的数字的含义：</p><table><thead><tr><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td></tr><tr><td align="left">1</td><td align="left">仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td></tr><tr><td align="left">2</td><td align="left">禁止调用深灰名单和黑名单中的接口。</td></tr><tr><td align="left">3</td><td align="left">禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td></tr></tbody></table><h4 id="4-9-6-修改状态栏和导航栏的显示隐藏"><a href="#4-9-6-修改状态栏和导航栏的显示隐藏" class="headerlink" title="4.9.6 修改状态栏和导航栏的显示隐藏"></a>4.9.6 修改状态栏和导航栏的显示隐藏</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> settings <span class="hljs-keyword">put</span> <span class="hljs-keyword">global</span> policy_control <span class="hljs-symbol">&lt;key-values&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p><table><thead><tr><th align="left">key</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">immersive.full</td><td align="left">同时隐藏</td></tr><tr><td align="left">immersive.status</td><td align="left">隐藏状态栏</td></tr><tr><td align="left">immersive.navigation</td><td align="left">隐藏导航栏</td></tr><tr><td align="left">immersive.preconfirms</td><td align="left">?</td></tr></tbody></table><p>这些键对应的值可则如下值用逗号组合：</p><table><thead><tr><th align="left">value</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>apps</code></td><td align="left">所有应用</td></tr><tr><td align="left"><code>*</code></td><td align="left">所有界面</td></tr><tr><td align="left"><code>package-name</code></td><td align="left">指定应用</td></tr><tr><td align="left"><code>-package-name</code></td><td align="left">排除指定应用</td></tr></tbody></table><p>例如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">adb <span class="hljs-built_in">shell</span> settings <span class="hljs-built_in">put</span> <span class="hljs-built_in">global</span> policy_control immersive.full=*<br></code></pre></td></tr></table></figure><p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> settings <span class="hljs-keyword">put</span> <span class="hljs-keyword">global</span> policy_control immersive.status=<span class="hljs-keyword">com</span>.package1,<span class="hljs-keyword">com</span>.package2:immersive.navigation=apps,-<span class="hljs-keyword">com</span>.package3<br></code></pre></td></tr></table></figure><p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p><h3 id="4-11-实用功能"><a href="#4-11-实用功能" class="headerlink" title="4.11 实用功能"></a>4.11 实用功能</h3><h4 id="4-11-1-屏幕截图"><a href="#4-11-1-屏幕截图" class="headerlink" title="4.11.1 屏幕截图"></a>4.11.1 屏幕截图</h4><p>截图保存到电脑：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">adb <span class="hljs-keyword">exec</span><span class="hljs-operator">-</span><span class="hljs-keyword">out</span> screencap <span class="hljs-operator">-</span>p <span class="hljs-operator">&gt;</span> sc.png<br></code></pre></td></tr></table></figure><p>如果 adb 版本较老，无法使用 <code>exec-out</code> 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p><p>先截图保存到设备里：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb shell screencap -p <span class="hljs-regexp">/sdcard/</span>sc.png<br></code></pre></td></tr></table></figure><p>然后将 png 文件导出到电脑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb pull <span class="hljs-regexp">/sdcard/</span>sc.png<br></code></pre></td></tr></table></figure><p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-p</td><td align="left">指定保存文件为 png 格式</td></tr><tr><td align="left">-d display-id</td><td align="left">指定截图的显示屏编号（有多显示屏的情况下）</td></tr></tbody></table><p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p><p>另外一种一行命令截图并保存到电脑的方法： <em>Linux 和 Windows</em></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">adb <span class="hljs-keyword">shell</span> screencap -p | sed <span class="hljs-string">&quot;s/\r$//&quot;</span> &gt; <span class="hljs-keyword">sc</span>.png<br></code></pre></td></tr></table></figure><p><em>Mac OS X</em></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">adb <span class="hljs-keyword">shell</span> screencap -p | gsed <span class="hljs-string">&quot;s/\r$//&quot;</span> &gt; <span class="hljs-keyword">sc</span>.png<br></code></pre></td></tr></table></figure><p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p><p>而在 Mac 下使用系统自带的 sed 命令会报错：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">sed:</span> RE <span class="hljs-keyword">error</span>: illegal <span class="hljs-type">byte</span> sequence<br></code></pre></td></tr></table></figure><p>需要安装 gnu-sed，然后使用 gsed 命令：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>gnu-sed<br></code></pre></td></tr></table></figure><h4 id="4-11-2-录制屏幕"><a href="#4-11-2-录制屏幕" class="headerlink" title="4.11.2 录制屏幕"></a>4.11.2 录制屏幕</h4><p>录制屏幕以 mp4 格式保存到 &#x2F;sdcard：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb shell screenrecord <span class="hljs-regexp">/sdcard/</span>filename.mp4<br></code></pre></td></tr></table></figure><p>需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p><p>如果需要导出到电脑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb pull <span class="hljs-regexp">/sdcard/</span>filename.mp4<br></code></pre></td></tr></table></figure><p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">–size WIDTHxHEIGHT</td><td align="left">视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td></tr><tr><td align="left">–bit-rate RATE</td><td align="left">视频的比特率，默认是 4Mbps。</td></tr><tr><td align="left">–time-limit TIME</td><td align="left">录制时长，单位秒。</td></tr><tr><td align="left">–verbose</td><td align="left">输出更多信息。</td></tr></tbody></table><h4 id="4-11-3-查看连接过的-WiFi-密码"><a href="#4-11-3-查看连接过的-WiFi-密码" class="headerlink" title="4.11.3 查看连接过的 WiFi 密码"></a>4.11.3 查看连接过的 WiFi 密码</h4><p><strong>注：需要 root 权限。</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb shell<br>su<br>cat <span class="hljs-regexp">/data/mi</span>sc<span class="hljs-regexp">/wifi/</span>*.conf<br></code></pre></td></tr></table></figure><h4 id="4-11-4-设置系统日期和时间"><a href="#4-11-4-设置系统日期和时间" class="headerlink" title="4.11.4 设置系统日期和时间"></a>4.11.4 设置系统日期和时间</h4><p><strong>注：需要 root 权限。</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> shell<br><span class="hljs-attribute">su</span><br><span class="hljs-attribute">date</span> -s <span class="hljs-number">20160823</span>.<span class="hljs-number">131500</span><br></code></pre></td></tr></table></figure><p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p><h4 id="4-11-5-重启手机"><a href="#4-11-5-重启手机" class="headerlink" title="4.11.5 重启手机"></a>4.11.5 重启手机</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adb reboot</span><br></code></pre></td></tr></table></figure><h4 id="4-11-6-检测设备是否已-root"><a href="#4-11-6-检测设备是否已-root" class="headerlink" title="4.11.6 检测设备是否已 root"></a>4.11.6 检测设备是否已 root</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">adb <span class="hljs-keyword">shell</span><br><span class="hljs-keyword">su</span><br></code></pre></td></tr></table></figure><p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p><h4 id="4-11-7-使用-Monkey-进行压力测试"><a href="#4-11-7-使用-Monkey-进行压力测试" class="headerlink" title="4.11.7 使用 Monkey 进行压力测试"></a>4.11.7 使用 Monkey 进行压力测试</h4><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p><p>简单用法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> monkey -<span class="hljs-keyword">p</span> <span class="hljs-symbol">&lt;packagename&gt;</span> -v <span class="hljs-number">500</span><br></code></pre></td></tr></table></figure><p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html">官方文档</a>。</p><h4 id="4-11-8-开启-x2F-关闭-WiFi"><a href="#4-11-8-开启-x2F-关闭-WiFi" class="headerlink" title="4.11.8 开启&#x2F;关闭 WiFi"></a>4.11.8 开启&#x2F;关闭 WiFi</h4><p><strong>注：需要 root 权限。</strong></p><ul><li>开启 WiFi：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb root<br>adb <span class="hljs-keyword">shell</span><span class="language-bash"> svc wifi <span class="hljs-built_in">enable</span></span><br></code></pre></td></tr></table></figure><ul><li>关闭 WiFi：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">adb root<br>adb <span class="hljs-keyword">shell</span><span class="language-bash"> svc wifi <span class="hljs-built_in">disable</span></span><br></code></pre></td></tr></table></figure><p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p><h3 id="4-12-安全相关命令"><a href="#4-12-安全相关命令" class="headerlink" title="4.12 安全相关命令"></a>4.12 安全相关命令</h3><h4 id="4-12-1-启用-x2F-禁用-SELinux"><a href="#4-12-1-启用-x2F-禁用-SELinux" class="headerlink" title="4.12.1 启用&#x2F;禁用 SELinux"></a>4.12.1 启用&#x2F;禁用 SELinux</h4><p>启用 SELinux</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> root<br><span class="hljs-attribute">adb</span> shell setenforce <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>禁用 SELinux</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> root<br><span class="hljs-attribute">adb</span> shell setenforce <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="4-12-2-启用-x2F-禁用-dm-verity"><a href="#4-12-2-启用-x2F-禁用-dm-verity" class="headerlink" title="4.12.2 启用&#x2F;禁用 dm_verity"></a>4.12.2 启用&#x2F;禁用 dm_verity</h4><p>启用 dm_verity</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adb root</span><br><span class="hljs-attribute">adb enable-verity</span><br></code></pre></td></tr></table></figure><p>禁用 dm_verity</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adb root</span><br><span class="hljs-attribute">adb disable-verity</span><br></code></pre></td></tr></table></figure><h3 id="4-13-更多-adb-shell-命令"><a href="#4-13-更多-adb-shell-命令" class="headerlink" title="4.13 更多 adb shell 命令"></a>4.13 更多 adb shell 命令</h3><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p><h4 id="4-14-1-查看进程状态"><a href="#4-14-1-查看进程状态" class="headerlink" title="4.14.1 查看进程状态"></a>4.14.1 查看进程状态</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">ps</span><br></code></pre></td></tr></table></figure><p>输出信息各列含义：</p><table><thead><tr><th align="left">列名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">USER</td><td align="left">所属用户</td></tr><tr><td align="left">PID</td><td align="left">进程 ID</td></tr><tr><td align="left">PPID</td><td align="left">父进程 ID</td></tr><tr><td align="left">NAME</td><td align="left">进程名</td></tr></tbody></table><h4 id="4-14-2-查看处理器实时状态"><a href="#4-14-2-查看处理器实时状态" class="headerlink" title="4.14.2 查看处理器实时状态"></a>4.14.2 查看处理器实时状态</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">adb shell <span class="hljs-attribute">top</span> <span class="hljs-selector-attr">[-m max_procs]</span> <span class="hljs-selector-attr">[-n iterations]</span> <span class="hljs-selector-attr">[-d delay]</span> <span class="hljs-selector-attr">[-s sort_column]</span> <span class="hljs-selector-attr">[-t]</span> <span class="hljs-selector-attr">[-h]</span><br></code></pre></td></tr></table></figure><p><code>adb shell top</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-m</td><td align="left">最多显示多少个进程</td></tr><tr><td align="left">-n</td><td align="left">刷新多少次后退出</td></tr><tr><td align="left">-d</td><td align="left">刷新时间间隔(单位秒，默认值5)</td></tr><tr><td align="left">-s</td><td align="left">按某列排序(可用col值：cpu, vss, rss, thr)</td></tr><tr><td align="left">-t</td><td align="left">显示线程信息</td></tr><tr><td align="left">-h</td><td align="left">显示帮助文档</td></tr></tbody></table><p>输出信息各列含义：</p><table><thead><tr><th align="left">列名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">PID</td><td align="left">进程 ID</td></tr><tr><td align="left">PR</td><td align="left">优先级</td></tr><tr><td align="left">CPU%</td><td align="left">当前瞬间占用 CPU 百分比</td></tr><tr><td align="left">S</td><td align="left">进程状态（R&#x3D;运行，S&#x3D;睡眠，T&#x3D;跟踪&#x2F;停止，Z&#x3D;僵尸进程）</td></tr><tr><td align="left">#THR</td><td align="left">线程数</td></tr><tr><td align="left">VSS</td><td align="left">Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td></tr><tr><td align="left">RSS</td><td align="left">Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td></tr><tr><td align="left">PCY</td><td align="left">调度策略优先级，SP_BACKGROUND&#x2F;SPFOREGROUND</td></tr><tr><td align="left">UID</td><td align="left">进程所有者的用户 ID</td></tr><tr><td align="left">NAME</td><td align="left">进程名</td></tr></tbody></table><h4 id="4-14-3-查看进程-UID"><a href="#4-14-3-查看进程-UID" class="headerlink" title="4.14.3 查看进程 UID"></a>4.14.3 查看进程 UID</h4><p>有两种方案：</p><p>方案一：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> dumpsys package <span class="hljs-symbol">&lt;packagename&gt;</span> | <span class="hljs-keyword">grep</span> userId= 如：<br> adb <span class="hljs-keyword">shell</span> dumpsys package org.mazhuang.guanggoo | <span class="hljs-keyword">grep</span> userId=<br>  userId=<span class="hljs-number">10394</span><br></code></pre></td></tr></table></figure><p>方案二：</p><p>通过 ps 命令找到对应进程的 pid 之后 <code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid</code> 如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> shell<br><span class="hljs-attribute">gemini</span>:/ $ ps | grep org.mazhuang.guanggoo<br><span class="hljs-attribute">u0_a394</span>   <span class="hljs-number">28635</span> <span class="hljs-number">770</span>   <span class="hljs-number">1795812</span> <span class="hljs-number">78736</span> SyS_epoll_ <span class="hljs-number">0000000000</span> S org.mazhuang.guanggoo<br><span class="hljs-attribute">gemini</span>:/ $ cat /proc/<span class="hljs-number">28635</span>/status | grep Uid<br><span class="hljs-attribute">Uid</span>:    <span class="hljs-number">10394</span>   <span class="hljs-number">10394</span>   <span class="hljs-number">10394</span>   <span class="hljs-number">10394</span><br><span class="hljs-attribute">gemini</span>:/ $<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具知识</category>
      
      <category>adb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CameraX实时预览+拍照</title>
    <link href="/CameraX%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88-%E6%8B%8D%E7%85%A7/"/>
    <url>/CameraX%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88-%E6%8B%8D%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="预览-图片拍摄"><a href="#预览-图片拍摄" class="headerlink" title="预览+图片拍摄"></a>预览+图片拍摄</h1><h2 id="实时预览"><a href="#实时预览" class="headerlink" title="实时预览"></a>实时预览</h2><p>1.编辑<code>activity_main</code> layout 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/camera_capture_button&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;fitCenter&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Take Photo&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:elevation</span>=<span class="hljs-string">&quot;2dp&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.camera.view.PreviewView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/viewFinder&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="1-请求-CameraProvider"><a href="#1-请求-CameraProvider" class="headerlink" title="1.请求 CameraProvider"></a>1.请求 CameraProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ListenableFuture&lt;ProcessCameraProvider&gt; cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure><h3 id="2-检查-CameraProvider-可用性"><a href="#2-检查-CameraProvider-可用性" class="headerlink" title="2.检查 CameraProvider 可用性"></a>2.检查 CameraProvider 可用性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">cameraProviderFuture.addListener(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将你的相机和当前生命周期的所有者绑定所需的对象</span><br>        <span class="hljs-type">ProcessCameraProvider</span> <span class="hljs-variable">cameraProvider</span> <span class="hljs-operator">=</span> cameraProviderFuture.get();<br>        <span class="hljs-comment">//绑定相机，具体代码见下面部分</span><br>        bindPreview(cameraProvider);<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException | InterruptedException e) &#123;<br>        <span class="hljs-comment">// No errors need to be handled for this Future.</span><br>        <span class="hljs-comment">// This should never be reached.</span><br>    &#125;<br>&#125;, ContextCompat.getMainExecutor(<span class="hljs-built_in">this</span>));<br></code></pre></td></tr></table></figure><h3 id="3-选择相机并绑定生命周期和用例"><a href="#3-选择相机并绑定生命周期和用例" class="headerlink" title="3.选择相机并绑定生命周期和用例"></a>3.选择相机并绑定生命周期和用例</h3><ol><li>创建 <code>Preview</code>。</li><li>指定所需的相机 <code>LensFacing</code> 选项。</li><li>将所选相机和任意用例绑定到生命周期。</li><li>将 <code>Preview</code> 连接到 <code>PreviewView</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bindPreview</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ProcessCameraProvider cameraProvider)</span> &#123;<br>    <br>    <span class="hljs-comment">//创建一个Preview 实例，并设置该实例的 surface 提供者（provider）。</span><br>    <span class="hljs-type">Preview</span> <span class="hljs-variable">preview</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preview</span>.Builder().build();<br>    <span class="hljs-type">PreviewView</span> <span class="hljs-variable">previewView</span> <span class="hljs-operator">=</span> (PreviewView)findViewById(R.id.viewFinder);<br>    preview.setSurfaceProvider(previewView.getSurfaceProvider());<br>    <br>    <span class="hljs-comment">//选择默认的摄像头（后置/前置）</span><br>    <span class="hljs-type">CameraSelector</span> <span class="hljs-variable">cameraSelector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CameraSelector</span>.Builder()<br>            .requireLensFacing(CameraSelector.LENS_FACING_BACK)<br>            .build();<br><br>    <span class="hljs-comment">// 重新绑定用例前先解绑</span><br>processCameraProvider.unbindAll();<br>    <span class="hljs-comment">// 绑定用例至相机</span><br>    <span class="hljs-type">Camera</span> <span class="hljs-variable">camera</span> <span class="hljs-operator">=</span> cameraProvider.bindToLifecycle((LifecycleOwner)<span class="hljs-built_in">this</span>, cameraSelector, preview);<br>&#125;<br></code></pre></td></tr></table></figure><p>到此为止：如何实现实时预览已经说明完毕。</p><h2 id="图片拍摄："><a href="#图片拍摄：" class="headerlink" title="图片拍摄："></a>图片拍摄：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建拍照所需的实例</span><br>          imageCapture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageCapture</span>.Builder().setTargetRotation(mViewFinder.getDisplay().getRotation()).build();<br><br><br></code></pre></td></tr></table></figure><ul><li>首先，检查 <code>imageCapture</code> 对象是否已经实例化，以避免空指针异常。</li><li>创建一个带时间戳的输出文件，用于保存照片，确保文件名的唯一性。</li><li>创建 <code>OutputFileOptions</code> 对象，用于指定照片的输出方式。</li><li>调用 <code>takePicture()</code> 方法进行拍照操作，传入输出文件选项和保存照片的回调函数。</li><li>在保存照片的回调函数中，可以获取保存的照片的 <code>Uri</code>，显示成功的提示消息，并将消息打印到日志中。</li><li>如果在保存照片时发生错误，会在回调函数的 <code>onError()</code> 方法中进行处理，打印错误消息到日志中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">.  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拍照，并保存照片</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> luxi</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023/5/23 14:09</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takePhoto</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 确保imageCapture 已经被实例化, 否则程序将可能崩溃</span><br>        <span class="hljs-keyword">if</span> (imageCapture != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 创建带时间戳的输出文件以保存图片，带时间戳是为了保证文件名唯一</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">photoFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(outputDirectory,<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(Configuration.FILENAME_FORMAT,<br>                            Locale.SIMPLIFIED_CHINESE).format(System.currentTimeMillis())<br>                            + <span class="hljs-string">&quot;.jpg&quot;</span>);<br><br>            <span class="hljs-comment">// 创建 output option 对象，用以指定照片的输出方式</span><br>            ImageCapture.<span class="hljs-type">OutputFileOptions</span> <span class="hljs-variable">outputFileOptions</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageCapture</span>.OutputFileOptions<br>                    .Builder(photoFile)<br>                    .build();<br><br>            <span class="hljs-comment">// 执行takePicture（拍照）方法</span><br>            imageCapture.takePicture(outputFileOptions,<br>                    ContextCompat.getMainExecutor(<span class="hljs-built_in">this</span>),<br>                    <span class="hljs-comment">// 保存照片时的回调</span><br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageCapture</span>.OnImageSavedCallback() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onImageSaved</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ImageCapture.OutputFileResults outputFileResults)</span> &#123;<br>                            <span class="hljs-type">Uri</span> <span class="hljs-variable">savedUri</span> <span class="hljs-operator">=</span> Uri.fromFile(photoFile);<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;照片捕获成功! &quot;</span> + savedUri;<br>                            Toast.makeText(getBaseContext(), msg, Toast.LENGTH_SHORT).show();<br>                            Log.d(Configuration.TAG, msg);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ImageCaptureException exception)</span> &#123;<br>                            Log.e(Configuration.TAG, <span class="hljs-string">&quot;Photo capture failed: &quot;</span> + exception.getMessage());<br>                        &#125;<br>                    &#125;);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="特殊功能实现："><a href="#特殊功能实现：" class="headerlink" title="特殊功能实现："></a>特殊功能实现：</h2><h4 id="前后摄像头的切换"><a href="#前后摄像头的切换" class="headerlink" title="前后摄像头的切换"></a>前后摄像头的切换</h4><p>我们之前使用<code>cameraProvider.bindToLifecycle()</code>的时候，有一个参数是<code>CameraSelector</code>。<br><code>CameraX</code>默认给我们提供了前置摄像头和后置摄像头的<code>CameraSelector</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//选择默认的摄像头（后置/前置）</span><br> <span class="hljs-type">CameraSelector</span> <span class="hljs-variable">cameraSelector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CameraSelector</span>.Builder()<br>         .requireLensFacing(CameraSelector.LENS_FACING_BACK)<br>         .build();<br></code></pre></td></tr></table></figure><p>切换摄像头的时候，就是重新调用一下<code>bindPreview</code>方法，传入新的<code>cameraSelector</code>值就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//解除所有绑定，防止CameraProvider重复绑定到Lifecycle发生异常</span><br>processCameraProvider.unbindAll();<br>   <span class="hljs-comment">// 绑定用例至相机</span><br>   <span class="hljs-type">Camera</span> <span class="hljs-variable">camera</span> <span class="hljs-operator">=</span> cameraProvider.bindToLifecycle((LifecycleOwner)<span class="hljs-built_in">this</span>, cameraSelector, preview);<br></code></pre></td></tr></table></figure><h4 id="手势放大缩小"><a href="#手势放大缩小" class="headerlink" title="手势放大缩小"></a>手势放大缩小</h4><p>这里使用<code>ScaleGestureDetector</code>类来实现手势缩放功能。</p><p><code>ScaleGestureDetector</code>用于处理缩放的工具类，用法与GestureDetector类似，都是通过onTouchEvent()关联相应的MotionEvent的。使用该类时，用户需要传入一个完整的连续不断地motion事件（包含ACTION_DOWN,ACTION_MOVE和ACTION_UP事件）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">scaleGestureDetector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScaleGestureDetector</span>(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScaleGestureDetector</span>. OnScaleGestureListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onScale</span><span class="hljs-params">(ScaleGestureDetector detector)</span> &#123;<br>        <span class="hljs-comment">//你可以根据缩放手势的因子来执行适当的操作。当前的代码中，我们返回了 true，表示我们处理了                     缩放操作，并消费了该事件。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onScaleBegin</span><span class="hljs-params">(ScaleGestureDetector detector)</span> &#123;<br>    <span class="hljs-comment">//返回true，你可以执行一些准备工作，或者返回 false 来指示不处理缩放操作。一般都设为true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onScaleEnd</span><span class="hljs-params">(ScaleGestureDetector detector)</span> &#123;<br>    <span class="hljs-comment">//这里是缩放结束后做的操作，具体的使用效果可以参考微信，你把图片缩小之后（80%），你松手，图片会回               弹到原来的大小。 </span><br><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ol><li>在该方法中，我们首先获取缩放因子 <code>scaleFactor</code>，它表示缩放手势的影响因子。</li><li>我们获取当前的缩放状态，然后获取当前的缩放比例</li><li>我们获取新的缩放级别。<code>Math.max()</code> 和 <code>Math.min()</code> 方法来限制缩放级别在最小值和最大值之间</li><li>将新的缩放级别应用到相机控制器中，并打印出当前的缩放比例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onScale</span><span class="hljs-params">(ScaleGestureDetector detector)</span> &#123;<br>    <span class="hljs-comment">//缩放级别的影响因子</span><br>    <span class="hljs-type">float</span> <span class="hljs-variable">scaleFactor</span> <span class="hljs-operator">=</span> detector.getScaleFactor();<br>    LiveData&lt;ZoomState&gt; zoomState = mCameraInfo.getZoomState();<br>    <span class="hljs-comment">//返回当前缩放比例</span><br>    <span class="hljs-type">float</span> <span class="hljs-variable">zoomRatio</span> <span class="hljs-operator">=</span> zoomState.getValue().getZoomRatio();<br>    <span class="hljs-type">float</span> <span class="hljs-variable">minZoomRatio</span> <span class="hljs-operator">=</span> zoomState.getValue().getMinZoomRatio();<br>    <span class="hljs-type">float</span> <span class="hljs-variable">maxZoomRatio</span> <span class="hljs-operator">=</span> zoomState.getValue().getMaxZoomRatio();<br>    <span class="hljs-comment">//根据缩放手势的因子调整缩放级别</span><br>    <span class="hljs-type">float</span> <span class="hljs-variable">newZoomLevel</span> <span class="hljs-operator">=</span> zoomRatio * scaleFactor;<br>    <span class="hljs-comment">//限制缩放级别在最小值和最大值之间</span><br>    newZoomLevel = Math.max(<span class="hljs-number">1.0f</span>, Math.min(newZoomLevel, <span class="hljs-number">10</span>));<br><br>     mCameraControl.setZoomRatio(newZoomLevel);<br>     Log.d(TAG, <span class="hljs-string">&quot;当前缩放比例: &quot;</span> + newZoomLevel);<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="点击手动对焦"><a href="#点击手动对焦" class="headerlink" title="点击手动对焦"></a>点击手动对焦</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">mGestureDetector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GestureDetector</span>(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GestureDetector</span>. SimpleOnGestureListener() &#123;<br>         <span class="hljs-comment">//点击</span><br>         <span class="hljs-meta">@SuppressLint(&quot;RestrictedApi&quot;)</span><br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onSingleTapUp</span><span class="hljs-params">(MotionEvent e)</span> &#123;<br>             <span class="hljs-type">float</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> e.getX();<br>             <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> e.getY();<br>             <span class="hljs-type">MeteringPointFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> mViewFinder.getMeteringPointFactory();<br>             <span class="hljs-type">MeteringPoint</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> factory.createPoint(x, y);<br>             <span class="hljs-type">FocusMeteringAction</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FocusMeteringAction</span>.Builder(point, FocusMeteringAction.FLAG_AF).build();<br>             <span class="hljs-comment">//启动对焦和测光</span><br>             ListenableFuture&lt;FocusMeteringResult&gt; focusMeteringResultListenableFuture = mCameraControl.startFocusAndMetering(action);<br>             focusMeteringResultListenableFuture.addListener(() -&gt; &#123;<br>                 <span class="hljs-keyword">try</span> &#123;<br>                     <span class="hljs-type">FocusMeteringResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> focusMeteringResultListenableFuture.get();<br>                     <span class="hljs-keyword">if</span> (result.isFocusSuccessful()) &#123;<br>                         Log.d(TAG, <span class="hljs-string">&quot;对焦成功&quot;</span>);<br><br>                         runOnUiThread(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                             <span class="hljs-meta">@Override</span><br>                             <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                                 <span class="hljs-comment">//自定义矩形方框，对焦成功显示</span><br>                                 customBoxView.setBoxPosition(x, y);<br>                                 <span class="hljs-comment">//这是toast显示对焦成功</span><br>                                 showFocusSuccessToast();<br>                             &#125;<br>                         &#125;);<br><br>                     &#125; <span class="hljs-keyword">else</span> &#123;<br>                         Log.d(TAG, <span class="hljs-string">&quot;对焦失败&quot;</span>);<br>                         showFocusFailedToast();<br>                     &#125;<br>                 &#125; <span class="hljs-keyword">catch</span> (ExecutionException | InterruptedException ex) &#123;<br>                     Log.e(<span class="hljs-string">&quot;YourCameraActivity&quot;</span>, <span class="hljs-string">&quot;对焦操作失败: &quot;</span> + ex.getMessage());<br>                 &#125;<br>             &#125;, CameraXExecutors.directExecutor());<br><br><br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125;<br><br>     &#125;);<br></code></pre></td></tr></table></figure><p>为 <code>mViewFinder</code> 设置了一个触摸监听器，并在触摸事件中调用了 <code>scaleGestureDetector</code> 和 <code>mGestureDetector</code> 的对应方法。<code>scaleGestureDetector.onTouchEvent(event)</code> 是用于处理缩放手势的触摸事件，它将触摸事件传递给 <code>scaleGestureDetector</code> 对象来处理缩放操作。<code>mGestureDetector.onTouchEvent(event)</code> 是用于处理其他手势的触摸事件，它将触摸事件传递给 <code>mGestureDetector</code> 对象来处理其他手势操作，比如单击操作或者双击等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">mViewFinder = (PreviewView) findViewById(R.id.viewFinder); <br>mViewFinder.setOnTouchListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnTouchListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouch</span><span class="hljs-params">(View v, MotionEvent event)</span> &#123;<br>                    scaleGestureDetector.onTouchEvent(event);<br>                    mGestureDetector.onTouchEvent(event);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;);<br></code></pre></td></tr></table></figure><h4 id="手机紧急晃动拍照"><a href="#手机紧急晃动拍照" class="headerlink" title="手机紧急晃动拍照"></a>手机紧急晃动拍照</h4><p>使用加速度传感器（Accelerometer Sensor）来检测手机的晃动，并在达到一定阈值时触发拍照操作。</p><ol><li>注册加速度传感器监听</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SensorManager</span> <span class="hljs-variable">sensorManager</span> <span class="hljs-operator">=</span> (SensorManager) getSystemService(Context.SENSOR_SERVICE);<br><span class="hljs-type">Sensor</span> <span class="hljs-variable">accelerometerSensor</span> <span class="hljs-operator">=</span> sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);<br><br>sensorManager.registerListener(sensorEventListener, accelerometerSensor, SensorManager.SENSOR_DELAY_NORMAL);<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个 SensorEventListener 对象，并实现其 onSensorChanged() 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">SensorEventListener</span> <span class="hljs-variable">sensorEventListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SensorEventListener</span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">SHAKE_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.5f</span>; <span class="hljs-comment">// 设置晃动的阈值</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> lastX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> lastY;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> lastZ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lastShakeTime;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSensorChanged</span><span class="hljs-params">(SensorEvent event)</span> &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> event.values[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> event.values[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">float</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> event.values[<span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">// 计算加速度的变化量</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> x - lastX;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> y - lastY;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">deltaZ</span> <span class="hljs-operator">=</span> z - lastZ;<br><br>        <span class="hljs-comment">// 更新上一次的加速度值</span><br>        lastX = x;<br>        lastY = y;<br>        lastZ = z;<br><br>        <span class="hljs-comment">// 计算当前加速度的模</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">acceleration</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);<br><br>        <span class="hljs-comment">// 判断是否达到晃动阈值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">if</span> (acceleration &gt; SHAKE_THRESHOLD &amp;&amp; currentTime - lastShakeTime &gt; <span class="hljs-number">1000</span>) &#123;<br>            <span class="hljs-comment">// 触发拍照操作</span><br>            takePhoto();<br>            lastShakeTime = currentTime;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAccuracyChanged</span><span class="hljs-params">(Sensor sensor, <span class="hljs-type">int</span> accuracy)</span> &#123;<br>        <span class="hljs-comment">// 当传感器的精度发生变化时触发，不需要处理</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>销毁监听</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.onDestroy();<br>    sensorManager.unregisterListener(sensorEventListener);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="给拍照图片加水印"><a href="#给拍照图片加水印" class="headerlink" title="给拍照图片加水印"></a>给拍照图片加水印</h4><p>在 <code>public void onImageSaved(@NonNull ImageCapture.OutputFileResults outputFileResults) &#123;&#125;</code>里调用下面的方法。WaterMarkingUtility是一个添加水印的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWatermarkToPhoto</span><span class="hljs-params">(File photoFile)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>     <span class="hljs-type">Bitmap</span> <span class="hljs-variable">originalBitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeFile(photoFile.getAbsolutePath());<br>     <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(photoFile);<br><br>     <span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> WaterMarkingUtility.drawTextToCenter(originalBitmap, <span class="hljs-string">&quot;水印&quot;</span>, <span class="hljs-number">500</span>);<br>     bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="hljs-number">100</span>, outputStream);<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android进阶知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CameraX 的基础</title>
    <link href="/CameraX-%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
    <url>/CameraX-%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="CameraX实现相机功能"><a href="#CameraX实现相机功能" class="headerlink" title="CameraX实现相机功能"></a>CameraX实现相机功能</h1><p>预计实现功能：</p><ol><li>实时预览（缩放、点击聚焦）</li><li>拍照（晃动拍照）、录像</li><li>实现左右滑动，切换拍照、录像</li><li>给拍照的图片加水印</li></ol><h2 id="CameraX是什么，能解决什么问题"><a href="#CameraX是什么，能解决什么问题" class="headerlink" title="CameraX是什么，能解决什么问题"></a>CameraX是什么，能解决什么问题</h2><ul><li>Jetpack的一个支持库，最低版本要求Android5.0</li><li>默认的相机功能还是Camera2的能力，当然API都变了，同时提供CameraX Extensions拓展库可以添加各种特效，例如人像、HDR、夜间和美颜模式(从上图也可以看出，这是依赖OEM的)</li><li>绑定生命周期，所以Camera本身无需在生命周期中调用什么onPause onResume之类的样板代码，且忘记后会造成各种问题</li><li>抹平设备兼容性问题，无需在代码库中添加设备专属代码</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h4 id="1-注意事项"><a href="#1-注意事项" class="headerlink" title="1. 注意事项"></a>1. 注意事项</h4><ul><li>最低支持API是21</li><li>Android Studio 至少是3.6版本</li><li>Java8环境</li></ul><h4 id="2-导入依赖"><a href="#2-导入依赖" class="headerlink" title="2.导入依赖"></a>2.导入依赖</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  <span class="hljs-comment">// CameraX core library using the camera2 implementation</span><br>  <span class="hljs-keyword">def</span> camerax_version = <span class="hljs-string">&quot;1.3.0-alpha06&quot;</span><br>  <span class="hljs-comment">// The following line is optional, as the core library is included indirectly by camera-camera2</span><br>  implementation <span class="hljs-string">&quot;androidx.camera:camera-core:$&#123;camerax_version&#125;&quot;</span><br>  implementation <span class="hljs-string">&quot;androidx.camera:camera-camera2:$&#123;camerax_version&#125;&quot;</span><br>  <span class="hljs-comment">// If you want to additionally use the CameraX Lifecycle library</span><br>  implementation <span class="hljs-string">&quot;androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;&quot;</span><br>  <span class="hljs-comment">// If you want to additionally use the CameraX VideoCapture library</span><br>  implementation <span class="hljs-string">&quot;androidx.camera:camera-video:$&#123;camerax_version&#125;&quot;</span><br>  <span class="hljs-comment">// If you want to additionally use the CameraX View class</span><br>  implementation <span class="hljs-string">&quot;androidx.camera:camera-view:$&#123;camerax_version&#125;&quot;</span><br>  <span class="hljs-comment">// If you want to additionally add CameraX ML Kit Vision Integration</span><br>  implementation <span class="hljs-string">&quot;androidx.camera:camera-mlkit-vision:$&#123;camerax_version&#125;&quot;</span><br>  <span class="hljs-comment">// If you want to additionally use the CameraX Extensions library</span><br>  implementation <span class="hljs-string">&quot;androidx.camera:camera-extensions:$&#123;camerax_version&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-申请一些必要的权限"><a href="#3-申请一些必要的权限" class="headerlink" title="3.申请一些必要的权限"></a>3.申请一些必要的权限</h4><blockquote><!--摄像头权限--><uses-permission android:name="android.permission.CAMERA"><!--具备摄像头--><uses-feature android:name="android.hardware.camera.any"><!--存储图像或者视频权限--><uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"><uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"><!--录制音频权限--><uses-permission android:name="android.permission.RECORD_AUDIO"></uses-permission></uses-permission></uses-permission></uses-feature></uses-permission></blockquote><h2 id="CameraX-结构"><a href="#CameraX-结构" class="headerlink" title="CameraX 结构"></a>CameraX 结构</h2><p>您可以使用 CameraX，借助名为“用例”的抽象概念与设备的相机进行交互。提供的用例如下：</p><ul><li><strong>预览</strong>：接受用于显示预览的 Surface，例如 <code>PreviewView</code>。</li><li><strong>图片分析</strong>：为分析（例如机器学习）提供 CPU 可访问的缓冲区。</li><li><strong>图片拍摄</strong>：拍摄并保存照片。</li><li><strong>视频拍摄</strong>：通过 <a href="https://developer.android.google.cn/reference/androidx/camera/video/VideoCapture?hl=zh-cn"><code>VideoCapture</code></a> 拍摄视频和音频</li></ul><p>我理解：cameraX给我们封装了四个不同的功能：实时预览、拍照、录像和图片分析。这些不同的功能可以组合到一起使用。</p><p>例如，应用中可以加入预览用例，以便让用户查看进入相机视野的画面；加入图片分析用例，以确定照片里的人物是否在微笑；还可以加入图片拍摄用例，以在人物微笑时拍摄照片。</p><h2 id="配置-CameraX-用例"><a href="#配置-CameraX-用例" class="headerlink" title="配置 CameraX 用例"></a>配置 CameraX 用例</h2><p>可以自行配置下面的内容：<a href="https://developer.android.google.cn/training/camerax/configuration?hl=zh-cn">配置选项  | Android 开发者  | Android Developers (google.cn)</a></p><p><img src="/2023/05/26/CameraX-%E7%9A%84%E5%9F%BA%E7%A1%80/image-20230526164804855.png" alt="image-20230526164804855"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android进阶知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义圆形图片</title>
    <link href="/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87/"/>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>官方推荐使用AppCompatImageView来实现自定义ImagView。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppCompatImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ImageView</span> <br>    <span class="hljs-keyword">implements</span> <br>  <span class="hljs-title class_">TintableBackgroundView</span>, TintableImageSourceView <br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import android.annotation.SuppressLint;<br>import android.content.Context;<br>import android.graphics.Bitmap;<br>import android.graphics.BitmapShader;<br>import android.graphics.Canvas;<br>import android.graphics.Matrix;<br>import android.graphics.Paint;<br>import android.graphics.Shader;<br>import android.graphics.drawable.BitmapDrawable;<br>import android.graphics.drawable.Drawable;<br>import android.util.AttributeSet;<br>import androidx.annotation.Nullable;<br>import androidx.appcompat.widget.AppCompatImageView;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author luxi</span><br><span class="hljs-comment"> * @email luxi2@mychery.com</span><br><span class="hljs-comment"> * @date 2023/5/11 15:12</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> CircleImageView extends AppCompatImageView &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 画笔；mPaint</span><br><span class="hljs-comment">     * 图片半径；mRadius</span><br><span class="hljs-comment">     * 缩放比例：mScale</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Paint mPaint;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> mRadius;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mScale;<br><br>    public <span class="hljs-constructor">CircleImageView(Context <span class="hljs-params">context</span>)</span> &#123;<br>        super(context);<br>    &#125;<br><br>    public <span class="hljs-constructor">CircleImageView(Context <span class="hljs-params">context</span>, @Nullable AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;<br>        super(context, attrs);<br>    &#125;<br><br>    public <span class="hljs-constructor">CircleImageView(Context <span class="hljs-params">context</span>, @Nullable AttributeSet <span class="hljs-params">attrs</span>, <span class="hljs-params">int</span> <span class="hljs-params">defStyleAttr</span>)</span> &#123;<br>        super(context, attrs, defStyleAttr);<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Measure(<span class="hljs-params">int</span> <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">int</span> <span class="hljs-params">heightMeasureSpec</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Measure(<span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        <span class="hljs-comment">//因为是圆形图片，所以应该让宽高保持一致</span><br>        <span class="hljs-built_in">int</span> size = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(get<span class="hljs-constructor">MeasuredWidth()</span>, get<span class="hljs-constructor">MeasuredHeight()</span>);<br>        mRadius = size<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//存储合适的宽高</span><br>        set<span class="hljs-constructor">MeasuredDimension(<span class="hljs-params">size</span>, <span class="hljs-params">size</span>)</span>;<br>    &#125;<br><br>    @<span class="hljs-constructor">SuppressLint(<span class="hljs-string">&quot;DrawAllocation&quot;</span>)</span><br>    @Override<br>    protected void on<span class="hljs-constructor">Draw(Canvas <span class="hljs-params">canvas</span>)</span> &#123;<br>        mPaint = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;<br>        Bitmap bitmap = drawable<span class="hljs-constructor">ToBitmap(<span class="hljs-params">getDrawable</span>()</span>);<br>        <span class="hljs-comment">//初始化BitmapShader，传入bitmap对象</span><br>        @<span class="hljs-constructor">SuppressLint(<span class="hljs-string">&quot;DrawAllocation&quot;</span>)</span> BitmapShader bitmapShader=<span class="hljs-keyword">new</span> <span class="hljs-constructor">BitmapShader(<span class="hljs-params">bitmap</span>, Shader.TileMode.CLAMP,Shader.TileMode.CLAMP)</span>;<br><br>        <span class="hljs-comment">//计算缩放比例</span><br>        mScale=(mRadius*<span class="hljs-number">2.0</span>f)/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(bitmap.get<span class="hljs-constructor">Height()</span>,bitmap.get<span class="hljs-constructor">Width()</span>);<br><br>        Matrix matrix=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Matrix()</span>;<br>        matrix.set<span class="hljs-constructor">Scale(<span class="hljs-params">mScale</span>,<span class="hljs-params">mScale</span>)</span>;<br>        bitmapShader.set<span class="hljs-constructor">LocalMatrix(<span class="hljs-params">matrix</span>)</span>;<br><br><br>        mPaint.set<span class="hljs-constructor">Shader(<span class="hljs-params">bitmapShader</span>)</span>;<br><br>        <span class="hljs-comment">//画圆形，指定好中心点坐标、半径、画笔</span><br>        canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mRadius</span>,<span class="hljs-params">mRadius</span>,<span class="hljs-params">mRadius</span>,<span class="hljs-params">mPaint</span>)</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将drawable转化成bitmap</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param drawable drawable</span><br><span class="hljs-comment">     * @author luxi</span><br><span class="hljs-comment">     * @date 2023/5/11 15:30</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Bitmap drawable<span class="hljs-constructor">ToBitmap(Drawable <span class="hljs-params">drawable</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (drawable instanceof BitmapDrawable) &#123;<br>            BitmapDrawable bd = (BitmapDrawable) drawable;<br>            return bd.get<span class="hljs-constructor">Bitmap()</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> w = drawable.get<span class="hljs-constructor">IntrinsicWidth()</span>;<br>        <span class="hljs-built_in">int</span> h = drawable.get<span class="hljs-constructor">IntrinsicHeight()</span>;<br>        Bitmap bitmap = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bitmap</span>.</span></span>create<span class="hljs-constructor">Bitmap(<span class="hljs-params">w</span>, <span class="hljs-params">h</span>, Bitmap.Config.ARGB_8888)</span>;<br>        Canvas canvas = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Canvas(<span class="hljs-params">bitmap</span>)</span>;<br>        drawable.set<span class="hljs-constructor">Bounds(0, 0, <span class="hljs-params">w</span>, <span class="hljs-params">h</span>)</span>;<br>        drawable.draw(canvas);<br>        return bitmap;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滤镜效果</title>
    <link href="/%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C/"/>
    <url>/%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="滤镜效果"><a href="#滤镜效果" class="headerlink" title="滤镜效果"></a>滤镜效果</h1><p>先说一下，我要完成的效果：</p><p><img src="/2023/05/16/%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C/image-20230516135644852.png" alt="image-20230516135644852"></p><p>给上面的的图片加上一层透明度25的黑色蒙层，或者说是一层淡黑色的滤镜。达到下面的效果。</p><p><img src="/2023/05/16/%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C/image-20230516135627211.png" alt="image-20230516135627211"></p><p>我现在已知的有两种方法：</p><h2 id="1-使用ImageView-的api"><a href="#1-使用ImageView-的api" class="headerlink" title="1.使用ImageView 的api"></a>1.使用ImageView 的api</h2><p>当设置<strong>setBackgroundDrawable</strong>时，整个ImageView的控件背景色会变。<br>当设置<strong>setImageDrawable</strong>时，ImageView中间内容区会被图片填充。但是周围会有一些边距，默认无法填充整个控件（当然，这也是有属性设置的）。</p><p><strong>ScaleType的值分别代表的意义： ImageView是Android中的基础图片显示控件，该控件有个重要的属性是ScaleType，该属性用以表示显示图片的方式，共有8种取值</strong> 　</p><blockquote><p>ScaleType.CENTER：：图片大小为原始大小，如果图片大小大于ImageView控件，则截取图片中间部分，若小于，则直接将图片居中显示。 </p></blockquote><blockquote><p>ScaleType.CENTER_CROP：将图片等比例缩放，让图像的短边与ImageView的边长度相同，即不能留有空白，缩放后截取中间部分进行显示。</p></blockquote><blockquote><p>ScaleType.CENTER_INSIDE：将图片大小大于ImageView的图片进行等比例缩小，直到整幅图能够居中显示在ImageView中，小于ImageView的图片不变，直接居中显示。</p></blockquote><blockquote><p>ScaleType.FIT_CENTER：ImageView的默认状态，大图等比例缩小，使整幅图能够居中显示在ImageView中，小图等比例放大，同样要整体居中显示在ImageView中。 　　 </p></blockquote><blockquote><p>ScaleType.FIT_END：缩放方式同FIT_CENTER，只是将图片显示在右方或下方，而不是居中。 　</p></blockquote><blockquote><p>ScaleType.FIT_START：缩放方式同FIT_CENTER，只是将图片显示在左方或上方，而不是居中。 　</p></blockquote><blockquote><p>ScaleType.FIT_XY：将图片非等比例缩放到大小与ImageView相同。 　　 </p></blockquote><blockquote><p>ScaleType.MATRIX：是根据一个3x3的矩阵对其中图片进行缩放</p></blockquote><ol><li>我们将真正要显示的图片作为背景。也就是使用setBackgroundDrawable方法</li><li>透明底色的图片使用setImageDrawable方法，它会覆盖在要显示的图片上，因为是透明的，会在上面看起来是一层黑色滤镜。</li><li>如果遇到无法填充完整，就使用ScaleType属性。</li></ol><blockquote><p>将bitmap转化成drawable：BitmapDrawable bd&#x3D;new BitmapDrawable(getResources(),bitmap);</p><p>BitmapDrawable是drawable的子类</p></blockquote><h2 id="2-使用setColorFilter方法"><a href="#2-使用setColorFilter方法" class="headerlink" title="2.使用setColorFilter方法"></a>2.使用setColorFilter方法</h2><p>官方定义是给图片添加一个着色选项：Sets a tinting option for the image.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">通过setColorFilter可以实现滤镜效果。 如： <span class="hljs-keyword">final</span> <span class="hljs-type">WallpaperManager</span> <span class="hljs-variable">wallpaperManager</span> <span class="hljs-operator">=</span> WallpaperManager.getInstance(<span class="hljs-built_in">this</span>);<br>         <span class="hljs-comment">//获取壁纸</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">Drawable</span> <span class="hljs-variable">wallpaperDrawable</span> <span class="hljs-operator">=</span> wallpaperManager.getDrawable();<br> <span class="hljs-comment">//指定滤镜颜色以及混合模式</span><br>wallpaperDrawable.setColorFilter(Color.RED, PorterDuff.Mode.MULTIPLY); <br><br><span class="hljs-comment">/*注意：PorterDuff.Mode枚举值： </span><br><span class="hljs-comment"> 1.PorterDuff.Mode.CLEAR 所绘制不会提交到画布上。</span><br><span class="hljs-comment"> 2.PorterDuff.Mode.SRC 显示上层绘制图片</span><br><span class="hljs-comment"> 3.PorterDuff.Mode.DST 显示下层绘制图片</span><br><span class="hljs-comment"> 4.PorterDuff.Mode.SRC_OVER 正常绘制显示，上下层绘制叠盖。</span><br><span class="hljs-comment"> 5.PorterDuff.Mode.DST_OVER 上下层都显示。下层居上显示。</span><br><span class="hljs-comment"> 6.PorterDuff.Mode.SRC_IN 取两层绘制交集。显示上层。 </span><br><span class="hljs-comment"> 7.PorterDuff.Mode.DST_IN 取两层绘制交集。显示下层。</span><br><span class="hljs-comment"> 8.PorterDuff.Mode.SRC_OUT 取上层绘制非交集部分。 </span><br><span class="hljs-comment"> 9.PorterDuff.Mode.DST_OUT 取下层绘制非交集部分。 </span><br><span class="hljs-comment"> 10.PorterDuff.Mode.SRC_ATOP 取下层非交集部分与上层交集部分 </span><br><span class="hljs-comment"> 11.PorterDuff.Mode.DST_ATOP 取上层非交集部分与下层交集部分 </span><br><span class="hljs-comment"> 12.PorterDuff.Mode.XOR //变暗 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如何使用：</p><ol><li>添加滤镜：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">binding.image.setColorFilter(getResources().getColor(R.color.black, <span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure><ol start="2"><li>去除滤镜：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">binding.image.clearColorFilter();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bitmap基础使用</title>
    <link href="/Bitmap%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/Bitmap%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Bitmap的一些应用场景"><a href="#Bitmap的一些应用场景" class="headerlink" title="Bitmap的一些应用场景"></a>Bitmap的一些应用场景</h2><hr><h3 id="1-使用Bitmap时防止OOM的有效方法：高效压缩图片"><a href="#1-使用Bitmap时防止OOM的有效方法：高效压缩图片" class="headerlink" title="1. 使用Bitmap时防止OOM的有效方法：高效压缩图片"></a>1. 使用Bitmap时防止OOM的有效方法：高效压缩图片</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 谷歌推荐使用方法，从资源中加载图像，并高效压缩，有效降低OOM的概率</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> res 资源</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resId 图像资源的资源id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> reqWidth 要求图像压缩后的宽度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> reqHeight 要求图像压缩后的高度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Bitmap <span class="hljs-title function_">decodeSampledBitmapFromResource</span><span class="hljs-params">(Resources res, <span class="hljs-type">int</span> resId, <span class="hljs-type">int</span> reqWidth, <span class="hljs-type">int</span> reqHeight)</span> &#123;<br>    <span class="hljs-comment">// 设置inJustDecodeBounds = true ,表示获取图像信息，但是不将图像的像素加入内存</span><br>    <span class="hljs-keyword">final</span> BitmapFactory.<span class="hljs-type">Options</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitmapFactory</span>.Options();<br>    options.inJustDecodeBounds = <span class="hljs-literal">true</span>;<br>    BitmapFactory.decodeResource(res, resId, options);<br><br>    <span class="hljs-comment">// 调用方法计算合适的 inSampleSize</span><br>    options.inSampleSize = calculateInSampleSize(options, reqWidth,<br>            reqHeight);<br><br>    <span class="hljs-comment">// inJustDecodeBounds 置为 false 真正开始加载图片</span><br>    options.inJustDecodeBounds = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//将options.inPreferredConfig改成Bitmap.Config.RGB_565，</span><br>    <span class="hljs-comment">// 是默认情况Bitmap.Config.ARGB_8888占用内存的一般</span><br>    options.inPreferredConfig= Bitmap.Config.RGB_565;<br>    <span class="hljs-keyword">return</span> BitmapFactory.decodeResource(res, resId, options);<br>&#125;<br><br><span class="hljs-comment">// 计算 BitmapFactpry 的 inSimpleSize的值的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateInSampleSize</span><span class="hljs-params">(BitmapFactory.Options options,</span><br><span class="hljs-params">                                 <span class="hljs-type">int</span> reqWidth, <span class="hljs-type">int</span> reqHeight)</span> &#123;<br>    <span class="hljs-keyword">if</span> (reqWidth == <span class="hljs-number">0</span> || reqHeight == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取图片原生的宽和高</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> options.outHeight;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> options.outWidth;<br>    Log.d(TAG, <span class="hljs-string">&quot;origin, w= &quot;</span> + width + <span class="hljs-string">&quot; h=&quot;</span> + height);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">inSampleSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 如果原生的宽高大于请求的宽高,那么将原生的宽和高都置为原来的一半</span><br>    <span class="hljs-keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">halfHeight</span> <span class="hljs-operator">=</span> height / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">halfWidth</span> <span class="hljs-operator">=</span> width / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 主要计算逻辑</span><br>        <span class="hljs-comment">// Calculate the largest inSampleSize value that is a power of 2 and</span><br>        <span class="hljs-comment">// keeps both</span><br>        <span class="hljs-comment">// height and width larger than the requested height and width.</span><br>        <span class="hljs-keyword">while</span> ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123;<br>            inSampleSize *= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    Log.d(TAG, <span class="hljs-string">&quot;sampleSize:&quot;</span> + inSampleSize);<br>    <span class="hljs-keyword">return</span> inSampleSize;<br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="2-绘制圆角矩形Bitmap"><a href="#2-绘制圆角矩形Bitmap" class="headerlink" title="2. 绘制圆角矩形Bitmap"></a>2. 绘制圆角矩形Bitmap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> bitmap 需要修改的图片</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> pixels 圆角的弧度</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> 圆角图片</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-comment">//参考资料:</span><br> <span class="hljs-comment">//http://blog.csdn.net/c8822882/article/details/6906768</span><br> <span class="hljs-keyword">public</span> Bitmap <span class="hljs-title function_">toRoundCorner</span><span class="hljs-params">(Bitmap bitmap, <span class="hljs-type">int</span> pixels)</span> &#123;<br>     <span class="hljs-type">Bitmap</span> <span class="hljs-variable">roundCornerBitmap</span> <span class="hljs-operator">=</span> Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);<br>     <span class="hljs-type">Canvas</span> <span class="hljs-variable">canvas</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Canvas</span>(roundCornerBitmap);<span class="hljs-comment">//生成画布</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xff424242</span>;<span class="hljs-comment">//int color = 0xff424242;</span><br>     <span class="hljs-type">Paint</span> <span class="hljs-variable">paint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>();<br>     paint.setColor(color);<br>     <span class="hljs-comment">//防止锯齿</span><br>     paint.setAntiAlias(<span class="hljs-literal">true</span>);<br>     <span class="hljs-comment">//定义一个矩形区域用于绘制bitmap</span><br>     <span class="hljs-type">Rect</span> <span class="hljs-variable">rect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bitmap.getWidth(), bitmap.getHeight());<br>     <span class="hljs-comment">//再定义一个矩形用于绘制圆角矩形</span><br>     <span class="hljs-type">RectF</span> <span class="hljs-variable">rectF</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RectF</span>(rect);<br>     <span class="hljs-comment">//获取圆角的半径</span><br>     <span class="hljs-type">float</span> <span class="hljs-variable">roundPx</span> <span class="hljs-operator">=</span> pixels;<br>     <span class="hljs-comment">//相当于清屏</span><br>     canvas.drawARGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>     <span class="hljs-comment">//先画了一个带圆角的矩形</span><br>     canvas.drawRoundRect(rectF, roundPx, roundPx, paint);<br>     <span class="hljs-comment">//取两层绘制交集。显示上层。</span><br>     paint.setXfermode(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PorterDuffXfermode</span>(PorterDuff.Mode.SRC_IN));<br>     <span class="hljs-comment">//再把原来的bitmap画到现在的bitmap！！！注意这个理解</span><br>     canvas.drawBitmap(bitmap, rect, rect, paint);<br>     <span class="hljs-keyword">return</span> roundCornerBitmap;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="3-绘制圆形Bitmap"><a href="#3-绘制圆形Bitmap" class="headerlink" title="3. 绘制圆形Bitmap"></a>3. 绘制圆形Bitmap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将图片处理成圆形</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> res </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> drawableId </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> luxi</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2023/5/12 13:21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">createCircleBitmap</span><span class="hljs-params">(Resources res, <span class="hljs-type">int</span> drawableId)</span> &#123;<br>    <span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeResource(res, drawableId);<br>    <span class="hljs-comment">//获取图片的宽度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> bitmap.getWidth();<br>    <span class="hljs-type">Paint</span> <span class="hljs-variable">paint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>();<br>    <span class="hljs-comment">//设置抗锯齿</span><br>    paint.setAntiAlias(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">//创建一个与原bitmap一样宽度的正方形bitmap</span><br>    <span class="hljs-type">Bitmap</span> <span class="hljs-variable">circleBitmap</span> <span class="hljs-operator">=</span> Bitmap.createBitmap(width, width, Bitmap.Config.ARGB_8888);<br>    <span class="hljs-comment">//以该bitmap为低创建一块画布</span><br>    <span class="hljs-type">Canvas</span> <span class="hljs-variable">canvas</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Canvas</span>(circleBitmap);<br>    <span class="hljs-comment">//以（width/2, width/2）为圆心，width/2为半径画一个圆</span><br>    canvas.drawCircle(width / <span class="hljs-number">2</span>, width / <span class="hljs-number">2</span>, width / <span class="hljs-number">2</span>, paint);<br><br>    <span class="hljs-comment">//设置画笔为取交集模式</span><br>    paint.setXfermode(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PorterDuffXfermode</span>(PorterDuff.Mode.SRC_IN));<br>    <span class="hljs-comment">//裁剪图片</span><br>    canvas.drawBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, paint);<br><br>    <span class="hljs-keyword">return</span> circleBitmap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-裁剪、缩放、旋转、移动"><a href="#4-裁剪、缩放、旋转、移动" class="headerlink" title="4.裁剪、缩放、旋转、移动"></a>4.裁剪、缩放、旋转、移动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Matrix</span> <span class="hljs-variable">matrix</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>();  <br><span class="hljs-comment">// 缩放 </span><br>matrix.postScale(<span class="hljs-number">0.8f</span>, <span class="hljs-number">0.9f</span>);  <br><span class="hljs-comment">// 左旋，参数为正则向右旋</span><br>matrix.postRotate(-<span class="hljs-number">45</span>);  <br><span class="hljs-comment">// 平移, 在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作</span><br>matrix.postTranslate(<span class="hljs-number">100</span>, <span class="hljs-number">80</span>);<br><span class="hljs-comment">// 裁剪并执行以上操作</span><br><span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> Bitmap.createBitmap(source, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, source.getWidth(), source.getHeight(), matrix, <span class="hljs-literal">true</span>);<br><br></code></pre></td></tr></table></figure><ol><li><p>图片缩小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缩小图片</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> bitmap 需要缩小的图片</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 缩小的图片</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">small</span><span class="hljs-params">(Bitmap bitmap)</span> &#123;<br>    <span class="hljs-type">Matrix</span> <span class="hljs-variable">matrix</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>();<br>    matrix.postScale(<span class="hljs-number">0.25f</span>, <span class="hljs-number">0.25f</span>);<br>    <span class="hljs-type">Bitmap</span> <span class="hljs-variable">resizeBmp</span> <span class="hljs-operator">=</span> Bitmap.createBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> resizeBmp;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>图片放大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 放大图片</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> bitmap 需要放大的图片</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 放大的图片</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">big</span><span class="hljs-params">(Bitmap bitmap)</span> &#123;<br>      <span class="hljs-type">Matrix</span> <span class="hljs-variable">matrix</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>();<br>      matrix.postScale(<span class="hljs-number">4f</span>, <span class="hljs-number">4f</span>);<br>      <span class="hljs-type">Bitmap</span> <span class="hljs-variable">resizeBmp</span> <span class="hljs-operator">=</span> Bitmap.createBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">return</span> resizeBmp;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android进阶知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bitmap里面的常见方法</title>
    <link href="/Bitmap%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/"/>
    <url>/Bitmap%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="BitMap的基本使用"><a href="#BitMap的基本使用" class="headerlink" title="BitMap的基本使用"></a>BitMap的基本使用</h1><p>我们创建一个BItMap有几种方式？</p><p>答：两种：一种是使用<strong>BitmapFactory</strong>类去加载，另一种是使用<strong>Bitmap类</strong>加载。</p><h2 id="一、BitmapFactory"><a href="#一、BitmapFactory" class="headerlink" title="一、BitmapFactory"></a>一、BitmapFactory</h2><p><img src="/2023/05/15/Bitmap%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASk1XMTQwNw==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><h3 id="1-1-BitmapFactory提供了多种创建bitmap的静态方法"><a href="#1-1-BitmapFactory提供了多种创建bitmap的静态方法" class="headerlink" title="1.1 BitmapFactory提供了多种创建bitmap的静态方法"></a>1.1 <strong>BitmapFactory提供了多种创建bitmap的静态方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从资源文件中通过id加载bitmap</span><br><span class="hljs-comment">//Resources res:资源文件，可以context.getResources()获得</span><br><span class="hljs-comment">//id:资源文件的id，如R.drawable.xxx</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">decodeResources</span><span class="hljs-params">(Resources res,<span class="hljs-type">int</span> id)</span><br><span class="hljs-comment">//第二种只是第一种的重载方法，多了个Options参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">decodeResources</span><span class="hljs-params">(Resources res,<span class="hljs-type">int</span> id,Options opt)</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//传入文件路径加载，比如加载sd卡中的文件</span><br><span class="hljs-comment">//pathName:文件的全路径名</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">decodeFile</span><span class="hljs-params">(String pathName)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">decodeFile</span><span class="hljs-params">(String pathName,Options opt)</span>;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从byte数组中加载</span><br><span class="hljs-comment">//offset:对应data数组的起始下标</span><br><span class="hljs-comment">//length:截取的data数组的长度</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">decodeByteArray</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data,<span class="hljs-type">int</span> offset , <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">decodeByteArray</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data,<span class="hljs-type">int</span> offset , <span class="hljs-type">int</span> length,Options opt)</span>;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FileDescriptor :包含解码位图的数据文件的路径</span><br><span class="hljs-comment">//通过该方式从路径加载bitmap比decodeFile更节省内存，原因不解释了。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">decodeFileDescriptor</span><span class="hljs-params">(FileDescriptor fd)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">decodeFileDescriptor</span><span class="hljs-params">(FileDescriptor fd,Rect outPadding,Options opt)</span>;<br><br></code></pre></td></tr></table></figure><p>decodeFile、 decodeResource、decodeStream和decodeByteArray,分别用于支持从文件系统、资源、输入流以及字节数组中加载出一个Bitmap对象，其中decodeFile和decodeResource又间接调用了decodeStream方法，这四类方法最终是在Android的底层实现的，对应着BitmapFactory类的几个native 方法。</p><blockquote><p>一个native方法就是一个Java调用非Java代码的接口。一个native方法是指该方法的实现由非Java语言实现，比如用C或C++实现。</p></blockquote><h3 id="1-2-Bitmap-Options"><a href="#1-2-Bitmap-Options" class="headerlink" title="1.2 Bitmap.Options"></a>1.2 Bitmap.Options</h3><p>想要创建一个<code>Bitmap</code>有很多种方法，其中很多方法都要求传入一个<code>Bitmap.Options</code>，它是什么呢，有什么作用呢？</p><p>这个参数的作用非常大，他可以设置Bitmap的<strong>采样率</strong>，通过改变图片的宽度高度和缩放比例等，以达到<strong>减少图片像素数的目的</strong>，一言以蔽之，通过设置这个参数我们可以很好的控制显示和使用<code>Bitmap</code>。实际开发过程中，可以灵活设置该值，以降低<code>OOM</code>发生的概率。</p><ol><li>如何高效地加载bitmap?</li></ol><p>通过<code>BitmapFactory.Options</code>按一定的<code>采样率</code>来加载缩小后的图片，将缩小后的图片在<code>ImageView</code>中显示，这样就会降低内存占用从而在一定程度上避免OOM，提高了Bitmap 加载时的性能。BitmapFactory提供的加载图片的四类方法都支持BitmapFactory.Options参数</p><ol start="2"><li>通过BitmapFactory.Options 来缩放图片，主要用到了inSampleSize参数，即采样率。</li></ol><p>当inSampleSize为1时，采样后的图片大小为图片的原始大小;<br>当inSampleSize大于1时，比如为2,那么采样后的图片其宽&#x2F;高均为原图大小的1&#x2F;2,而像素数为原图的1&#x2F;4,其占有的内存大小也为原图的1&#x2F;4。</p><blockquote><p>拿一张1024×1024像素的图片来说，假定采用ARGB8888格式存储，那么它占有的内存为1024×1024×4即4MB，如果inSampleSize为2，那么采样后的图片其内存占用只有512×512×4，即1MB。</p></blockquote><p>采样率同时作用于宽&#x2F;高，这将导致缩放后的图片大小以采样率的2次方形式递减，即缩放比例为1&#x2F; (inSampleSize的2次方)</p><p>​比如inSampleSize为4,那么缩放比例就是1&#x2F;16。<br>​有一种特殊情况，那就是当inSampleSize 小于1时，其作用相当于1,即无缩放效果。</p><p><strong>参数说明：</strong></p><p><img src="/2023/05/15/Bitmap%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASk1XMTQwNw==,size_20,color_FFFFFF,t_70,g_se,x_16-16841591976211.png" alt="在这里插入图片描述"></p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">BitmapFactory.<span class="hljs-type">Options</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitmapFactory</span>.Options();<br><span class="hljs-comment">// 设置inJustDecodeBounds为true后，再使用decodeFile()等方法，并不会真正的分配空间，</span><br><span class="hljs-comment">//即解码出来的Bitmap为null，但是可计算出原始图片的宽度和高度，即options.outWidth和options.outHeight</span><br>options.inJustDecodeBounds = <span class="hljs-literal">true</span>;<br>BitmapFactory.decodeResource(getResources(), R.drawable.img3, options);<br><span class="hljs-type">float</span>  <span class="hljs-variable">srcWidth</span> <span class="hljs-operator">=</span> options.outWidth;<br><span class="hljs-type">float</span>  <span class="hljs-variable">srcHeight</span> <span class="hljs-operator">=</span> options.outHeight;<br><span class="hljs-type">int</span> <span class="hljs-variable">inSampleSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span>  <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">float</span>  <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> <span class="hljs-number">528</span>;<br><br><span class="hljs-keyword">if</span> (srcHeight &gt; height || srcWidth &gt; width) &#123;<br>    <span class="hljs-keyword">if</span> (srcWidth &gt; srcHeight) &#123;<br>        inSampleSize = Math.round(srcHeight / height);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        inSampleSize = Math.round(srcWidth / width);<br>    &#125;<br>&#125;<br><br>options.inJustDecodeBounds = <span class="hljs-literal">false</span>;<br>options.inSampleSize = inSampleSize;<br><br><span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeResource(getResources(), R.drawable.img3, options);<br><span class="hljs-type">float</span>  <span class="hljs-variable">outWidth</span> <span class="hljs-operator">=</span> options.outWidth;<br><span class="hljs-type">float</span>  <span class="hljs-variable">outHeight</span> <span class="hljs-operator">=</span> options.outHeight;<br>binding.image.setImageBitmap(bitmap);<br><br><br>Log.d(TAG, <span class="hljs-string">&quot;图片的内存: &quot;</span> + bitmap.getAllocationByteCount());<br>Log.d(TAG, <span class="hljs-string">&quot;图片的采樣率: &quot;</span> + inSampleSize);<br>Log.d(TAG, <span class="hljs-string">&quot;原來图片的宽度/高度: &quot;</span> + srcWidth + <span class="hljs-string">&quot; / &quot;</span> + srcHeight);<br>Log.d(TAG, <span class="hljs-string">&quot;現在图片的宽度/高度: &quot;</span> + outWidth + <span class="hljs-string">&quot; / &quot;</span> + outHeight);<br></code></pre></td></tr></table></figure><p><img src="/2023/05/15/Bitmap%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/image-20230515220322103.png" alt="image-20230515220322103"></p><h2 id="二-Bitmap静态方法"><a href="#二-Bitmap静态方法" class="headerlink" title="二. Bitmap静态方法"></a>二. Bitmap静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//width和height是长和宽单位px,config是存储格式</span><br><span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">createBitmap</span><span class="hljs-params">(<span class="hljs-type">int</span> width , <span class="hljs-type">int</span> height Bitmap.Config config)</span><br><span class="hljs-comment">// 根据一幅图像创建一份一模一样的实例</span><br><span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">createBitmap</span><span class="hljs-params">(Bitmap bm)</span><br><span class="hljs-comment">//截取一幅bitmap，起点是（x，y）,width和height分别对应宽高</span><br><span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">createBitmap</span><span class="hljs-params">(Bitmap bm,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> width,<span class="hljs-type">int</span> height)</span><br><span class="hljs-comment">//比上面的裁剪函数多了两个参数，Matrix:给裁剪后的图像添加矩阵 boolean filter:是否给图像添加滤波效果</span><br><span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">createBitmap</span><span class="hljs-params">(Bitmap bm,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> width,<span class="hljs-type">int</span> height，Matrix m,<span class="hljs-type">boolean</span> filter)</span>;<br><span class="hljs-comment">//用于缩放bitmap,dstWidth和dstHeight分别是目标宽高</span><br>createScaledBitmap(Bitmap bm,<span class="hljs-type">int</span> dstWidth,<span class="hljs-type">int</span> dstHeight,<span class="hljs-type">boolean</span> filter)<br></code></pre></td></tr></table></figure><p><img src="/2023/05/15/Bitmap%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/image-20230515220522631.png" alt="image-20230515220522631"></p><p><strong>这些方法大致可以分为三类：</strong></p><ul><li>1、根据已有的Bitmap来创建新Bitmap</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 通过矩阵的方式，返回原始 Bitmap 中的一个不可变子集。新 Bitmap 可能返回的就是原始的 Bitmap，也可能还是复制出来的。</span><br><span class="hljs-comment">* 新 Bitmap 与原始 Bitmap 具有相同的密度（density）和颜色空间;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> source   原始 Bitmap</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> x        在原始 Bitmap 中 x方向的其起始坐标（你可能只需要原始 Bitmap x方向上的一部分）</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> y        在原始 Bitmap 中 y方向的其起始坐标（你可能只需要原始 Bitmap y方向上的一部分）</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> width    需要返回 Bitmap 的宽度（px）（如果超过原始Bitmap宽度会报错）</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> height   需要返回 Bitmap 的高度（px）（如果超过原始Bitmap高度会报错）</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> m        Matrix类型，表示需要做的变换操作</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> filter   是否需要过滤，只有 matrix 变换不只有平移操作才有效</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">createBitmap</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bitmap source, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Matrix m, <span class="hljs-type">boolean</span> filter)</span> <br><br><br></code></pre></td></tr></table></figure><ul><li>2、通过像素点数组创建空的Bitmap</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 返回具有指定宽度和高度的不可变位图，每个像素值设置为colors数组中的对应值。</span><br><span class="hljs-comment">     * 其初始密度由给定的确定DisplayMetrics。新创建的位图位于sRGB 颜色空间中。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> display  显示将显示此位图的显示的度量标准</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colors   用于初始化像素的sRGB数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset   颜色数组中第一个颜色之前要跳过的值的数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stride   行之间数组中的颜色数（必须&gt; = width或&lt;= -width）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> width    位图的宽度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> height   位图的高度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> config   要创建的位图配置。如果配置不支持每像素alpha（例如RGB_565），</span><br><span class="hljs-comment">     * 那么colors []中的alpha字节将被忽略（假设为FF）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">createBitmap</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> DisplayMetrics display,</span><br><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@ColorInt</span> <span class="hljs-type">int</span>[] colors, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> stride,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-meta">@NonNull</span> Config config)</span> <br><br><br></code></pre></td></tr></table></figure><ul><li>3、 创建缩放的Bitmap</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 对Bitmap进行缩放，缩放成宽 dstWidth、高 dstHeight 的新Bitmap</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">createScaledBitmap</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bitmap src, <span class="hljs-type">int</span> dstWidth, <span class="hljs-type">int</span> dstHeight,<span class="hljs-type">boolean</span> filter)</span><br><br></code></pre></td></tr></table></figure><h2 id="三-创建Bitmap的总结"><a href="#三-创建Bitmap的总结" class="headerlink" title="三.创建Bitmap的总结"></a>三.创建Bitmap的总结</h2><ol><li>加载图像可以使用BitmapFactory和Bitmap.create系列方法</li><li>可以通过Options实现缩放图片，获取图片信息，配置缩放比例等功能</li><li>如果需要裁剪或者缩放图片，只能使用create系列函数</li><li>注意加载和创建bitmap事通过try catch捕捉OOM异常</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android进阶知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Bitmap 全面详解</title>
    <link href="/Android-Bitmap-%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/"/>
    <url>/Android-Bitmap-%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-Bitmap-全面详解"><a href="#Android-Bitmap-全面详解" class="headerlink" title="Android Bitmap 全面详解"></a>Android Bitmap 全面详解</h1><p>明确整理这篇博客的目的：</p><ol><li>对自己了解的bitmap知识做一个梳理；</li><li>进一步了解OOM；</li><li>主要对是介绍怎么使用bitmap，可能会对部分重要的方法进行源码的解读</li></ol><h2 id="一-Bitmap的定义"><a href="#一-Bitmap的定义" class="headerlink" title="一.Bitmap的定义"></a>一.Bitmap的定义</h2><p>Bitmap是Android系统中的图像处理的最重要类之一。用它可以获取图像文件信息，进行图像剪切、旋转、缩放等操作，并可以指定格式保存图像文件。</p><p>首先让我们开始对一张图片转化成Bitmap 后，占用内存分析，开始这次的技术总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeResource(getResources(), R.drawable.img3);<br>binding.image.setImageBitmap(bitmap);<br>Log.d(TAG, <span class="hljs-string">&quot;onCreate: &quot;</span>+bitmap.getAllocationByteCount());<br></code></pre></td></tr></table></figure><p>我们可以通过 Bitmap.getAllocationByteCount() 方法获取 Bitmap 占用的字节大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">D/路茜: onCreate: <span class="hljs-number">2534464</span><br></code></pre></td></tr></table></figure><p>我在drawablewe文件夹下保存的是一张796*796的图片</p><p><img src="/2023/05/15/Android-Bitmap-%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/image-20230515215603113.png" alt="image-20230515215603113"></p><p><strong>解释</strong>：</p><p>默认情况下 BitmapFactory 使用 Bitmap.Config.ARGB_8888 的存储方式来加载图片内容，而在这种存储模式下，每一个像素需要占用 4 个字节。因此上面图片 rodman 的内存大小可以使用如下公式来计算：</p><blockquote><p>796 * 796 * 4&#x3D; 2,534,464 bity&#x3D;2.4 MB</p></blockquote><p>原本就216kb的图片转化成bitmap之后竟然就有2.4MB，那么当我们加载很多图片的时候，就不奇怪为什么程序会奔溃了！！是我我也奔溃，自己写出来什么垃圾。</p><p>上面的引入，可以看出使用bitmap的两个需要的常规操作：对像素点的存储、对图片的压缩。</p><h2 id="二-Bitmap的格式"><a href="#二-Bitmap的格式" class="headerlink" title="二.Bitmap的格式"></a>二.Bitmap的格式</h2><p>我们知道<code>Bitmap</code>是位图，是由像素点组成的，这就涉及到两个问题，</p><ul><li><strong>第一：如何存储每个像素点？</strong></li><li><strong>第二：怎么压缩像素点？</strong></li></ul><p>Bitmap 中有两个内部枚举类：</p><blockquote><p><code>Config</code> 和 <code>CompressFormat</code>，<code>Config</code> 是用来设置颜色配置信息的，<code>CompressFormat</code> 是用来设置压缩方式的</p></blockquote><p><img src="/2023/05/15/Android-Bitmap-%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/1736058-d530c7d0bb8e8cf6.png" alt="img"></p><h3 id="2-1-存储格式"><a href="#2-1-存储格式" class="headerlink" title="2.1 存储格式"></a>2.1 存储格式</h3><p><code>Bitmap</code>有常见的有前面四种存储方式，对应<code>Bitmap.Config</code>中的四个常量</p><p><img src="/2023/05/15/Android-Bitmap-%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/image-20230515221256296.png" alt="image-20230515221256296"></p><p><img src="/2023/05/15/Android-Bitmap-%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASk1XMTQwNw==,size_20,color_FFFFFF,t_70,g_se,x_16-16841590469981.png" alt="在这里插入图片描述"></p><h2 id="2-2-压缩格式"><a href="#2-2-压缩格式" class="headerlink" title="2.2 压缩格式"></a>2.2 压缩格式</h2><blockquote><p><strong>Bitmap.CompressFormat.JPEG</strong>:采用JPEG压缩算法，是一种有损压缩格式，会在压缩过程中改变图像原本质量，画质越差，对原来的图片质量损伤越大，但是得到的文件比较小，而且JPEG不支持透明度，当遇到透明度像素时，会以黑色背景填充。</p></blockquote><blockquote><p><strong>Bitmap.CompressFormat.PNG</strong>:采用PNG算法，是一种支持透明度的无损压缩格式。</p></blockquote><blockquote><p><strong>Bitmap.CompressFormat.WEBP</strong>:WEBP是一种同时提供了有损压缩和无损压缩的图片文件格式，在14&lt;&#x3D;api&lt;&#x3D;17时，WEBP是一种有损压缩格式，而且不支持透明度，在api18以后WEBP是一种无损压缩格式，而且支持透明度，有损压缩时，在质量相同的情况下，WEBP格式的图片体积比JPEG小40%，但是编码时间比JPEG长8倍。在无损压缩时，无损的WEBP图片比PNG压缩小26%，但是WEBP的压缩时间是PNG格式压缩时间的5倍。</p></blockquote><p><img src="/2023/05/15/Android-Bitmap-%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASk1XMTQwNw==,size_20,color_FFFFFF,t_70,g_se,x_16-16841590469992.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android进阶知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collection接口</title>
    <link href="/Collection%E6%8E%A5%E5%8F%A3/"/>
    <url>/Collection%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>因为接口无法创建对象。接口是抽象化的，无法实例化对象。所以下面将使用collection的子类来介绍collection里面的方法。</p><blockquote><p>这是多态，父类型的引用指向子类型的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Collection</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>return</strong></th><th>method</th><th>description</th></tr></thead><tbody><tr><td align="left">iterator&lt; &gt;</td><td>iterator()</td><td>返回在此 collection 的元素上进行迭代的迭代器</td></tr><tr><td align="left">boolean</td><td>add(E o)</td><td>向集合中添加元素。</td></tr><tr><td align="left">int</td><td>size()</td><td>返回此 collection 中的元素数。</td></tr><tr><td align="left">void</td><td>clear()</td><td>清空集合</td></tr><tr><td align="left">void</td><td>isEmpty()</td><td>判断集合是否为空，个数是否为0；</td></tr><tr><td align="left">boolean</td><td>remov(Object o)</td><td>删除集合中的某个元素</td></tr><tr><td align="left">boolean</td><td>contains(Object o)</td><td>判断集合中是否包含元素o，包含返回true</td></tr><tr><td align="left">Objec[ ]</td><td>toArray()</td><td>将集合转化成数组</td></tr><tr><td align="left">boolean</td><td>addAll(Collection&lt; ? extend E  &gt;)</td><td>向集合中添加一个集合</td></tr><tr><td align="left">boolean</td><td>retainAll(Collecyion  &lt; ? &gt;  o )</td><td>两个集合合并，取交集。</td></tr></tbody></table><p>开始测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//自动装箱，集合中只能存储对象的地址，不能存放基本数据类型和对象。</span><br>        list.add(<span class="hljs-number">212</span>);<br>        list.add(<span class="hljs-string">&#x27;3&#x27;</span>);<br>        list.add(<span class="hljs-number">2.454</span>);<br>        list.add(<span class="hljs-string">&quot;夸克&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> list.size();<br>        System.out.println(a);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> list.contains(<span class="hljs-string">&quot;夸克&quot;</span>);<br>        System.out.println(b);<br>        list.clear();<br>        System.out.println(list.isEmpty());<br>        Collection&lt;Object&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list2.add(<span class="hljs-string">&quot;浩克&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;浩克&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;夸克&quot;</span>);<br>        list.addAll(list2);<br>        list.retainAll(list2);<br>        <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>            System.out.println(o);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重点：iterator迭代器"><a href="#重点：iterator迭代器" class="headerlink" title="重点：iterator迭代器"></a>重点：iterator迭代器</h2><p>迭代器是一个对象，里面的方法有：</p><table><thead><tr><th><strong>方法摘要</strong></th><th></th><th></th></tr></thead><tbody><tr><td><code> boolean</code></td><td>hasNext()</td><td>如果仍有元素可以迭代，则返回 <code>true</code>。</td></tr><tr><td><code> E</code></td><td>next()</td><td>返回迭代的下一个元素。</td></tr><tr><td><code> void</code></td><td>remove() 。</td><td>从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）</td></tr></tbody></table><img src="/2023/04/24/Collection%E6%8E%A5%E5%8F%A3/004-迭代集合的原理.png" alt="004-迭代集合的原理" style="zoom: 200%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">//自动装箱，集合中只能存储对象的地址，不能存放基本数据类型和对象。</span><br>        list.add(<span class="hljs-number">212</span>);<br>        list.add(<span class="hljs-string">&#x27;3&#x27;</span>);<br>        list.add(<span class="hljs-number">2.454</span>);<br>        list.add(<span class="hljs-string">&quot;夸克&quot;</span>);<br>        Iterator&lt;Object&gt; iterator = list.iterator();<br>       <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> iterator.next();<br>            System.out.println(a.toString());<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/%E9%9B%86%E5%90%88/"/>
    <url>/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其它类型的数据。</p><ol><li><p>集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，</p></li><li><p>集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）<br>    list.add(100); &#x2F;&#x2F;自动装箱Integer<br>       注意：<br>           集合在java中本身是一个容器，是一个对象。<br>           集合中任何时候存储的都是“引用”。</p></li><li><p>在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。</p><p>什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。例如：<br>数组、二叉树、链表、哈希表…</p></li><li><p>在java中集合分为两大类：<br>    一类是单个方式存储元素：单个方式存储元素，这一类集合中超级父接口：java.util.Collection;</p></li></ol><img src="/2023/04/19/%E9%9B%86%E5%90%88/image-20230419145302429.png" alt="image-20230419145302429"><p>一类是以键值对儿的方式存储元素：以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;</p><p><img src="/2023/04/19/%E9%9B%86%E5%90%88/image-20230419160047240.png" alt="image-20230419160047240"></p><p>注意：</p><ol><li>Map集合和Collection集合没有任何关系</li><li>Map集合以key和value这种键值对的方式存储元素</li><li>key和value都是存储java对象的内存地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中字符串的拼接</title>
    <link href="/Java%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5/"/>
    <url>/Java%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>Java中字符串一旦创建，就是不可变的。</p><h1 id="一、“-”-操作符"><a href="#一、“-”-操作符" class="headerlink" title="一、“+” 操作符"></a>一、“+” 操作符</h1><p>“+” 操作符是字符串拼接最常用的方法之一。</p><p>使用“+”，字符串的发生拼接时候，会创建一个新的字符串，如果发生大量的字符串的拼接，就会在方法区里面的字符串常量池内不断的出现新的字符串。导致内存大量的浪费。给Java的方法区常量池带来很大的压力。</p><h1 id="二、StringBuffer"><a href="#二、StringBuffer" class="headerlink" title="二、StringBuffer"></a>二、StringBuffer</h1><p>构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br></code></pre></td></tr></table></figure><p>底层是一个char类型的数组。如果char类型的数组满了，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">AbstractStringBuilder(<span class="hljs-params">int</span> <span class="hljs-params">capacity</span>)</span> &#123;<br>    value = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span><span class="hljs-literal">[<span class="hljs-identifier">capacity</span>]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>append方法是追加的意思，如果char类型的数组满了，append方法会给数组扩容。</p><p>简要分析一下append的底层逻辑：</p><ol><li>可以看到append方法，这个是追加String类型的字符。方法重载，对应的还有int、float、long、boolean等类型的append方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>    toStringCache = <span class="hljs-literal">null</span>;<br>    <span class="hljs-built_in">super</span>.append(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>append方法调用的是父类的方法。我们可以看到方法体里面有一个ensureCapasityInternal方法——确保内部容量。在它的底层就有数组扩容的逻辑。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> appendNull();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> str.length();<br>    ensureCapacityInternal(count + len);<br>    str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>    count += len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，我们可以看到str&#x3D;&#x3D;null时候，这时候会给字符串追加一个null的字符串。如下：<img src="/2023/04/19/Java%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5/image-20230419021203366.png" alt="image-20230419021203366"></p><p>将这个字符串中的字符复制到目标字符数组中： str.getChars(0, len, value, count);</p><ol start="3"><li>如果我们研究ensureCapasityInternal的底层逻辑，会发现它是通过数组复制实现的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span>[] copyOf(<span class="hljs-type">char</span>[] original, <span class="hljs-type">int</span> newLength) &#123;<br>    <span class="hljs-type">char</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[newLength];<br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                     Math.min(original.length, newLength));<br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><p>总之，append方法当追加的字符超过数组容量时，会自动扩容。</p><h3 id="如何优化StringBuffer的性能？"><a href="#如何优化StringBuffer的性能？" class="headerlink" title="如何优化StringBuffer的性能？"></a>如何优化StringBuffer的性能？</h3><p>在创建StringBuffer时候尽可能的给定一个初始化容量，最好减少底层数组的扩容次数，与估计一下，给出一个合适的数组容量。</p><p>可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-number">44</span>);<br></code></pre></td></tr></table></figure><h1 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h1><p>为什么String字符串，使用“+”会创建一个新的字符串，而不是使用之前的字符串？</p><p>String底层也是一个char数组，但是使用了fina修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** The value is used for character storage. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br></code></pre></td></tr></table></figure><p>但是StringBuffer底层的char数组没有使用final修饰。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The value is used for character storage.</span><br><span class="hljs-comment"> */</span><br>char<span class="hljs-selector-attr">[]</span> value;<br></code></pre></td></tr></table></figure><p><a href="https://www.5axxw.com/tools/api/jdk_cn_6.html">StringBuffer的相关方法</a></p><h1 id="三、StringBuilder"><a href="#三、StringBuilder" class="headerlink" title="三、StringBuilder"></a>三、StringBuilder</h1><p>使用和StringBuffer类似，里面的方法也类似。</p><p>区别：  StringBuilder的方法线程不安全；</p><p>​            StringBuffer的方法都有synchronized关键字修饰，是线程安全的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android 里面的Context</title>
    <link href="/android-%E9%87%8C%E9%9D%A2%E7%9A%84Context/"/>
    <url>/android-%E9%87%8C%E9%9D%A2%E7%9A%84Context/</url>
    
    <content type="html"><![CDATA[<h1 id="Context都没弄明白，还怎么做Android开发？"><a href="#Context都没弄明白，还怎么做Android开发？" class="headerlink" title="Context都没弄明白，还怎么做Android开发？"></a>Context都没弄明白，还怎么做Android开发？</h1><p><strong>Activity mActivity &#x3D;new Activity()</strong></p><p>作为Android开发者，不知道你有没有思考过这个问题，Activity可以new吗？Android的应用程序开发采用JAVA语言，Activity本质上也是一个对象，那上面的写法有什么问题呢？估计很多人说不清道不明。Android程序不像Java程序一样，随便创建一个类，写个main()方法就能运行，Android应用模型是基于组件的应用设计模式，组件的运行要有一个完整的Android工程环境，在这个环境下，Activity、Service等系统组件才能够正常工作，而这些组件并不能采用普通的Java对象创建方式，new一下就能创建实例了，而是要有它们各自的上下文环境，也就是我们这里讨论的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。</p><h2 id="Context到底是什么"><a href="#Context到底是什么" class="headerlink" title="Context到底是什么"></a>Context到底是什么</h2><p>Context的中文翻译为：语境; 上下文; 背景; 环境，在开发中我们经常说称之为“上下文”，那么这个“上下文”到底是指什么意思呢？在语文中，我们可以理解为语境，在程序中，我们可以理解为当前对象在程序中所处的一个环境，一个与系统交互的过程。比如微信聊天，此时的“环境”是指聊天的界面以及相关的数据请求与传输，Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。</p><p>那Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android程序员把“场景”抽象为Context类，他们认为用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个环境中会切换到不同的场景，这就像一个前台秘书，她可能需要接待客人，可能要打印文件，还可能要接听客户电话，而这些就称之为不同的场景，前台秘书可以称之为一个应用程序。</p><h2 id="如何生动形象的理解Context"><a href="#如何生动形象的理解Context" class="headerlink" title="如何生动形象的理解Context"></a>如何生动形象的理解Context</h2><p>上面的概念中采用了通俗的理解方式，将Context理解为“上下文”或者“场景”，如果你仍然觉得很抽象，不好理解。在这里我给出一个可能不是很恰当的比喻，希望有助于大家的理解：一个Android应用程序，可以理解为一部电影或者一部电视剧，Activity，Service，Broadcast Receiver，Content Provider这四大组件就好比是这部戏里的四个主角：胡歌，霍建华，诗诗，Baby。他们是由剧组（系统）一开始就定好了的，整部戏就是由这四位主演领衔担纲的，所以这四位主角并不是大街上随随便便拉个人（new 一个对象）都能演的。有了演员当然也得有摄像机拍摄啊，他们必须通过镜头（Context）才能将戏传递给观众，这也就正对应说四大组件（四位主角）必须工作在Context环境下（摄像机镜头）。那Button，TextView，LinearLayout这些控件呢，就好比是这部戏里的配角或者说群众演员，他们显然没有这么重用，随便一个路人甲路人乙都能演（可以new一个对象），但是他们也必须要面对镜头（工作在Context环境下），所以<code>Button mButton=new Button（Context）</code>是可以的。虽然不很恰当，但还是很容易理解的，希望有帮助。</p><h3 id="源码中的Context"><a href="#源码中的Context" class="headerlink" title="源码中的Context"></a>源码中的Context</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment"><span class="language-markdown">/**</span></span><br><span class="language-markdown"><span class="hljs-comment"> <span class="hljs-emphasis">*</span></span> Interface to global <span class="language-markdown"><span class="hljs-emphasis">information about an application environment.  This is</span></span></span><br><span class="hljs-emphasis"><span class="language-markdown"><span class="hljs-comment"> *</span> an</span> abstract class whose <span class="language-markdown">implementation is provided by</span></span><br><span class="language-markdown"><span class="hljs-comment"> <span class="hljs-emphasis">*</span></span> the Android system. <span class="language-markdown"><span class="hljs-emphasis"> It</span></span></span><br><span class="hljs-emphasis"><span class="language-markdown"><span class="hljs-comment"> *</span></span> allows access to <span class="language-markdown">application-specific resources and classes, as well as</span></span><br><span class="language-markdown"><span class="hljs-comment"> <span class="hljs-emphasis">*</span></span> up-calls for application-level <span class="language-markdown"><span class="hljs-emphasis">operations such as launching activities,</span></span></span><br><span class="hljs-emphasis"><span class="language-markdown"><span class="hljs-comment"> *</span></span> broadcasting and receiving <span class="language-markdown">intents, etc.</span></span><br><span class="language-markdown"><span class="hljs-comment"> <span class="hljs-emphasis">*/</span></span></span><br>public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-comment"><span class="language-markdown"><span class="hljs-emphasis">/*</span>*</span></span><br><span class="language-markdown"><span class="hljs-comment"><span class="hljs-code">     *</span></span> File creation mode: <span class="language-markdown"><span class="hljs-code">the default mode,</span></span> where the created <span class="language-markdown"><span class="hljs-code">file can only</span></span></span><br><span class="hljs-code"><span class="language-markdown"><span class="hljs-comment">     * be accessed by</span></span> the calling application <span class="language-markdown"><span class="hljs-code">(or</span></span> all applications sharing <span class="language-markdown"><span class="hljs-code">the</span></span></span><br><span class="hljs-code"><span class="language-markdown"><span class="hljs-comment">     * same user ID).</span></span></span><br><span class="hljs-code"><span class="language-markdown"><span class="hljs-comment">     * @see #MODE_WORLD_READABLE</span></span></span><br><span class="hljs-code"><span class="language-markdown"><span class="hljs-comment">     * @see #MODE_WORLD_WRITEABLE</span></span></span><br><span class="hljs-code"><span class="language-markdown"><span class="hljs-comment">     */</span></span></span><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MODE_PRIVATE = <span class="hljs-number">0x0000</span>;<br>    <br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MODE_WORLD_WRITEABLE = <span class="hljs-number">0x0002</span>;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MODE_APPEND = <span class="hljs-number">0x8000</span>;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MODE_MULTI_PROCESS = <span class="hljs-number">0x0004</span>;<br><br>    .<br>    .<br>    .<br>    &#125;<br></code></pre></td></tr></table></figure><p>源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类咯，我们在Context的源码中通过IDE可以查看到他的子类最终可以得到如下关系图：</p><p><img src="/2023/04/15/android-%E9%87%8C%E9%9D%A2%E7%9A%84Context/1187237-1b4c0cd31fd0193f-16814889776081.webp" alt="Context.png"></p><p>Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。</p><h2 id="一个应用程序有几个Context"><a href="#一个应用程序有几个Context" class="headerlink" title="一个应用程序有几个Context"></a>一个应用程序有几个Context</h2><p>其实这个问题本身并没有什么意义，关键还是在于对Context的理解，从上面的关系图我们已经可以得出答案了，在应用程序中Context的具体实现子类就是：Activity，Service，Application。那么<code>Context数量=Activity数量+Service数量+1</code>。当然如果你足够细心，可能会有疑问：我们常说四大组件，这里怎么只有Activity，Service持有Context，那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。上面的关系图也从另外一个侧面告诉我们Context类在整个Android系统中的地位是多么的崇高，因为很显然Activity，Service，Application都是其子类，其地位和作用不言而喻。</p><h2 id="Context能干什么"><a href="#Context能干什么" class="headerlink" title="Context能干什么"></a>Context能干什么</h2><p>Context到底可以实现哪些功能呢？这个就实在是太多了，弹出Toast、启动Activity、启动Service、发送广播、操作数据库等等都需要用到Context。</p><h2 id="Context作用域"><a href="#Context作用域" class="headerlink" title="Context作用域"></a>Context作用域</h2><p>虽然Context神通广大，但并不是随便拿到一个Context实例就可以为所欲为，它的使用还是有一些规则限制的。由于Context的具体实例是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。</p><p><img src="/2023/04/15/android-%E9%87%8C%E9%9D%A2%E7%9A%84Context/1187237-fb32b0f992da4781.webp" alt="Context作用域.png"></p><p>从上图我们可以发现Activity所持有的Context的作用域最广，无所不能。因为Activity继承自ContextThemeWrapper，而Application和Service继承自ContextWrapper，很显然ContextThemeWrapper在ContextWrapper的基础上又做了一些操作使得Activity变得更强大，这里我就不再贴源码给大家分析了，有兴趣的童鞋可以自己查查源码。上图中的YES和NO我也不再做过多的解释了，这里我说一下上图中Application和Service所不推荐的两种使用情况。</p><p>1：如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错<code>android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</code>这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。<br> 2：在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。<br> 一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p><h2 id="如何获取Context"><a href="#如何获取Context" class="headerlink" title="如何获取Context"></a>如何获取Context</h2><p>通常我们想要获取Context对象，主要有以下四种方法<br> 1：View.getContext,返回当前View对象的Context对象，通常是当前正在展示的Activity对象。<br> 2：Activity.getApplicationContext,获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。<br> 3：ContextWrapper.getBaseContext():用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，这个方法在实际开发中使用并不多，也不建议使用。<br> 4：Activity.this 返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。</p><h3 id="getApplication-和getApplicationContext"><a href="#getApplication-和getApplicationContext" class="headerlink" title="getApplication()和getApplicationContext()"></a>getApplication()和getApplicationContext()</h3><p>上面说到获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？相信这个问题会难倒不少开发者。</p><p>![getApplication(C:&#x2F;Users&#x2F;sc&#x2F;Desktop&#x2F;新建文件夹&#x2F;android 里面的Context&#x2F;1187237-593b912ecd199046.webp)&amp;getApplicationContext().png](android 里面的Context&#x2F;1187237-593b912ecd199046.webp)</p><p>程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">publicclassMyReceiverextendsBroadcastReceiver&#123;<br><br><span class="hljs-meta">@Override</span><br>publicvoidonReceive(Contextcontext,Intentintent)&#123;<br>ApplicationmyApp=(Application)context.getApplicationContext();<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Context引起的内存泄露"><a href="#Context引起的内存泄露" class="headerlink" title="Context引起的内存泄露"></a>Context引起的内存泄露</h2><p>但Context并不能随便乱用，用的不好有可能会引起内存泄露的问题，下面就示例两种错误的引用方式。</p><h3 id="错误的单例模式"><a href="#错误的单例模式" class="headerlink" title="错误的单例模式"></a>错误的单例模式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-keyword">private</span> Context mContext;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params">Context context</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.mContext = context;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>(<span class="hljs-params">Context context</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton(context);<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，假如Activity A去getInstance获得instance对象，传入this，常驻内存的Singleton保存了你传入的Activity A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。</p><h3 id="View持有Activity引用"><a href="#View持有Activity引用" class="headerlink" title="View持有Activity引用"></a>View持有Activity引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Drawable mDrawable;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle saveInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(saveInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-type">ImageView</span> <span class="hljs-variable">iv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageView</span>(<span class="hljs-built_in">this</span>);<br>        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);<br>        iv.setImageDrawable(mDrawable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有一个静态的Drawable对象当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。</p><h2 id="正确使用Context"><a href="#正确使用Context" class="headerlink" title="正确使用Context"></a>正确使用Context</h2><p>一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：<br> 1：当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。<br> 2：不要让生命周期长于Activity的对象持有到Activity的引用。<br> 3：尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</p><p>本文参考阅读：<br> <a href="https://link.jianshu.com/?t=http://blog.csdn.net/guolin_blog/article/details/47028975">Android Context完全解析，你所不知道的Context的各种细节</a><br> <a href="https://link.jianshu.com/?t=http://blog.csdn.net/yanbober/article/details/45967639">Android应用Context详解及源码解析</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android进阶知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android下的资源目录</title>
    <link href="/Android%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95/"/>
    <url>/Android%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Android项目后会产生assets与res的两个文件夹。"><a href="#Android项目后会产生assets与res的两个文件夹。" class="headerlink" title="Android项目后会产生assets与res的两个文件夹。"></a>Android项目后会产生assets与res的两个文件夹。</h1><p>相同：理论上他们都是存放资源的文件夹。</p><p>区别： 1.assets:不会在R.java文件下生成相应的标记，存放到这里的资源在运行打包的时候都会打入程序安装包中。<strong>无法通过R资源清单访问的原生资源</strong></p><p>​2.res：会在R.java文件下生成标记，这里的资源会在运行打包操作的时候判断哪些被使用到了，没有被使用到的文件资源是不会打包到安装包中的。<strong>可通过R资源清单类访问的资源</strong></p><h1 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h1><p>assets 目录是专门用于保存各种外部文件的。常见的有：图像、音视频、配置文件、字体、自带数据库等。之所以说它适合用来管理这些文件，是因为应用程序在编译时不会去处理这个目录下的文件，但是却会将它们打包进 APK 中。而其它你随便创建的目录在编译时就会被直接忽略掉。同时，你可以在 assets 目录内任意创建目录层级关系，这对于有大量外部文件需要集成的应用来说，就能很方便地分类管理了。</p><p>在 APK 开发中，有一种管理配置信息的做法比较常见：直接将配置信息文件放入 assets 目录中管理，程序首次运行时将这里面的配置信息拷贝到外部的可操作的目录下，后续程序的运行均靠这份保存在外部的配置信息为准，assets 中的信息仅作为原始配置信息的备份。</p><p>但是，assets 目录在使用上也还是有一点小缺憾的。</p><p>assets 目录内的文件在程序打包发布以后就是只读的。就是你只能读取那里面的文件，而无法修改或增加文件。这条特性其实也可以理解，因为应用程序一旦打包发布了，它就应该是只读的。而 assets 目录又是直接保存在 APK 内部的，所以它自然也不能修改或增加内容了。实在要想增加内容，通过 Database 或者 SharedPreferences 往 &#x2F;data&#x2F;data 目录下保存就好了嘛。再或者这两者不能满足你的要求，你也可以直接将它们保存在 sdcard 下面嘛。反正现在市面上的 APK 在 sdcard 里创建自己的数据文件夹的可不少。</p><h1 id="res"><a href="#res" class="headerlink" title="res"></a>res</h1><p>在res文件夹下其实还可以定义子目录：</p><p>资源文件</p><blockquote><p>&#x2F;res&#x2F;drawable：存放各种位图文件或者对应的可使用的 XML 文件。</p></blockquote><p>存放布局文件</p><blockquote><p>&#x2F;res&#x2F;layout：存放各种用户界面的布局文件</p></blockquote><p>存放动画资源</p><blockquote><p>&#x2F;res&#x2F;anim：存放定义补间动画的xml文件</p></blockquote><p>放基于XML的菜单描述</p><blockquote><p>res&#x2F;menu：存放为应用程序定义各种菜单的资源，包括选项菜单，子菜单，上下文菜单的资源</p></blockquote><p>存放通用的文件， 该文件夹内的文件将不会被编译成二进制文件，按原样复制到设备上。</p><blockquote><p>res&#x2F;raw： 该文件夹内的文件将不会被编译成二进制文件，按原样复制到设备上。使用方法是getResource().OpenRawResources(ID),其中参数ID的形式是R.raw.XXX.。</p></blockquote><p>存放字符串、尺寸值</p><blockquote><p>res&#x2F;values：存放各种简单值的xml文件。这些简单值包括字符串值，整数值，颜色值，数组等</p></blockquote><p>存放通用的XML文件</p><blockquote><p>res&#x2F;xml：可以在Activity中使用getResource().getXML()读取这里的资源文件</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短句</title>
    <link href="/%E7%9F%AD%E5%8F%A5/"/>
    <url>/%E7%9F%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>人生是旷野而非轨道。</p><p>盲目冒险，不是勇敢，而是愚蠢。</p><p>我们都是平凡的小人，我们都想要走出平凡的深渊。</p><p>千万不要低估旁人的智慧，往往只有蠢才会认为别人愚蠢。</p><p>但凡上当受骗的人，难道真的是他们愚蠢吗？不是，只是他们内心愿意去相信罢了。</p><p>事情既然已经发生，就无法阻止。我需要积极的改变自己，哪怕最终所有的事情都面目全非，也不会因为顾及这些。而放缓自己成长的脚步。</p><p>其实真正禁锢一个人成就的，往往不是天资，而是思想。</p><p>生死是世间最大的公平。</p><p>心胸浅薄之人，常会因为谩骂而愤怒，因为夸赞而喜悦。但其实这不过都是旁人对你的看法罢了。因为旁人的看法，而活着的人，注定是可怜的人。</p><p>有时候，阻止人行动的，往往不是物质上的难题，而是心灵上的枷锁。</p><p>命是定数，运是变数。</p><p>态度是心的面具。</p><p>面对困境，就把心交给希望。</p><p>雄关漫道真如铁，如今迈步从头越。险就一身乾坤精，我心依旧望苍天。</p>]]></content>
    
    
    
    <tags>
      
      <tag>文字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现图片模糊</title>
    <link href="/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A/"/>
    <url>/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="1-项目需求："><a href="#1-项目需求：" class="headerlink" title="1.项目需求："></a>1.项目需求：</h1><p>​当系统软件弹出dialog时候，将当前的页面背景设置成dialog的模糊背景。</p><h1 id="2-实现思路："><a href="#2-实现思路：" class="headerlink" title="2.实现思路："></a>2.实现思路：</h1><ol><li>截屏，获取当前activity的界面</li><li>对截取到的图片做高斯模糊处理</li><li>将处理好的图片作为背景图</li></ol><h2 id="1-截屏的方法"><a href="#1-截屏的方法" class="headerlink" title="1.截屏的方法"></a>1.截屏的方法</h2><p>Android 截屏分为四种：<strong>View 截屏</strong>、<strong>WebView 截屏</strong>、<strong>系统截屏</strong> 和 <strong>adb 截屏</strong></p><h3 id="1-View-截屏"><a href="#1-View-截屏" class="headerlink" title="1.View 截屏"></a>1.View 截屏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 截屏</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activity 截屏的activity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 截屏图片</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">takeScreenShot</span><span class="hljs-params">(Activity activity)</span> &#123;<br>        <span class="hljs-comment">/*获取windows中最顶层的view*/</span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> activity.getWindow().getDecorView();<br><br>        <span class="hljs-comment">//允许当前窗口保存缓存信息</span><br>        view.setDrawingCacheEnabled(<span class="hljs-literal">true</span>);<br>        view.buildDrawingCache();<br><br>        <span class="hljs-comment">//获取状态栏高度</span><br>        <span class="hljs-type">Rect</span> <span class="hljs-variable">rect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>();<br>        view.getWindowVisibleDisplayFrame(rect);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">statusBarHeight</span> <span class="hljs-operator">=</span> rect.top;<br><br>        <span class="hljs-type">WindowManager</span> <span class="hljs-variable">windowManager</span> <span class="hljs-operator">=</span> activity.getWindowManager();<br><br>        <span class="hljs-comment">//获取屏幕宽和高</span><br>        <span class="hljs-type">DisplayMetrics</span> <span class="hljs-variable">outMetrics</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayMetrics</span>();<br>        windowManager.getDefaultDisplay().getMetrics(outMetrics);<br><span class="hljs-comment">//        int width = outMetrics.widthPixels;</span><br><span class="hljs-comment">//        int height = outMetrics.heightPixels;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span>  activity.getWindow().getDecorView().getRootView().getWidth();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span>  activity.getWindow().getDecorView().getRootView().getHeight();<br><br>        <span class="hljs-comment">//去掉状态栏</span><br><span class="hljs-comment">//        Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache(), 0, statusBarHeight, width,</span><br><span class="hljs-comment">//                height - statusBarHeight);</span><br>        <span class="hljs-keyword">if</span> (HideBottomMenuUtils.hasNavBar(activity)) &#123;<br>            HideBottomMenuUtils.hideBottomUIMenu(activity.getWindow());<br>        &#125;<br><br>        <span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> Bitmap.createBitmap( width, height, Bitmap.Config.ARGB_8888);<br>        <span class="hljs-type">Canvas</span> <span class="hljs-variable">canvas</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Canvas</span>(bitmap);<br>        view.draw(canvas);<br><br>        <span class="hljs-comment">//销毁缓存信息</span><br>        view.destroyDrawingCache();<br>        view.setDrawingCacheEnabled(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-keyword">return</span> bitmap;<br>    &#125;<br></code></pre></td></tr></table></figure><p>View 截图是将当前 View 界面截取下来，而对于屏幕上其他信息比如：状态栏或其他应用的界面将无法截取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> android.graphics.Bitmap;<br><span class="hljs-keyword">import</span> android.graphics.Canvas;<br><span class="hljs-keyword">import</span> android.graphics.Matrix;<br><span class="hljs-keyword">import</span> android.graphics.Rect;<br><span class="hljs-keyword">import</span> android.util.DisplayMetrics;<br><span class="hljs-keyword">import</span> android.util.Log;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.view.WindowManager;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@desc</span>  设置模糊背景 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> luxi </span><br><span class="hljs-comment">* <span class="hljs-doctag">@date</span> 2023/3/14 9:09</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastBlurUtility</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   * 获得模糊化的背景图片</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> activity 获取模糊化的背景activity</span><br><span class="hljs-comment">           <span class="hljs-doctag">@return</span> 模糊化的背景图片</span><br><span class="hljs-comment">               */</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">getBlurBackgroundDrawer</span><span class="hljs-params">(Activity activity)</span> &#123;<br>          <span class="hljs-type">Bitmap</span> <span class="hljs-variable">bmp</span> <span class="hljs-operator">=</span> takeScreenShot(activity);<br>          <span class="hljs-keyword">return</span> startBlurBackground(bmp);<br>              &#125;<br><br>​    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   * 截屏</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> activity 截屏的activity</span><br><span class="hljs-comment">           <span class="hljs-doctag">@return</span> 截屏图片</span><br><span class="hljs-comment">               */</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">takeScreenShot</span><span class="hljs-params">(Activity activity)</span> &#123;<br>          <span class="hljs-comment">/*获取windows中最顶层的view*/</span><br>          <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> activity.getWindow().getDecorView();<br><br>     <span class="hljs-comment">//允许当前窗口保存缓存信息</span><br>     view.setDrawingCacheEnabled(<span class="hljs-literal">true</span>);<br>     view.buildDrawingCache();<br><br>     <span class="hljs-comment">//获取状态栏高度</span><br>     <span class="hljs-type">Rect</span> <span class="hljs-variable">rect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>();<br>     view.getWindowVisibleDisplayFrame(rect);<br>     <span class="hljs-type">int</span> <span class="hljs-variable">statusBarHeight</span> <span class="hljs-operator">=</span> rect.top;<br><br>     <span class="hljs-type">WindowManager</span> <span class="hljs-variable">windowManager</span> <span class="hljs-operator">=</span> activity.getWindowManager();<br><br>     <span class="hljs-comment">//获取屏幕宽和高</span><br>     <span class="hljs-type">DisplayMetrics</span> <span class="hljs-variable">outMetrics</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayMetrics</span>();<br>     windowManager.getDefaultDisplay().getMetrics(outMetrics);<br>     <span class="hljs-comment">//        int width = outMetrics.widthPixels;</span><br>     <span class="hljs-comment">//        int height = outMetrics.heightPixels;</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span>  activity.getWindow().getDecorView().getRootView().getWidth();<br>     <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span>  activity.getWindow().getDecorView().getRootView().getHeight();<br><br>     <span class="hljs-comment">//去掉状态栏</span><br>     <span class="hljs-comment">//        Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache(), 0, statusBarHeight, width,</span><br>     <span class="hljs-comment">//                height - statusBarHeight);</span><br>     <span class="hljs-keyword">if</span> (HideBottomMenuUtils.hasNavBar(activity)) &#123;<br>         HideBottomMenuUtils.hideBottomUIMenu(activity.getWindow());<br>     &#125;<br><br>     <span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> Bitmap.createBitmap( width, height, Bitmap.Config.ARGB_8888);<br>     <span class="hljs-type">Canvas</span> <span class="hljs-variable">canvas</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Canvas</span>(bitmap);<br>     view.draw(canvas);<br><br>     <span class="hljs-comment">//销毁缓存信息</span><br>     view.destroyDrawingCache();<br>     view.setDrawingCacheEnabled(<span class="hljs-literal">false</span>);<br><br>     <span class="hljs-keyword">return</span> bitmap;<br>         &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">startBlurBackground</span><span class="hljs-params">(Bitmap bkg)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startMs</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">float</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>; <span class="hljs-comment">//模糊程度</span><br>        <span class="hljs-type">Bitmap</span> <span class="hljs-variable">overlay</span> <span class="hljs-operator">=</span> fastblur(small(bkg), (<span class="hljs-type">int</span>) radius);<br>        Log.i(<span class="hljs-string">&quot;FastBlurUtility&quot;</span>, <span class="hljs-string">&quot;=====blur time:&quot;</span> + (System.currentTimeMillis() - startMs));<br>        <span class="hljs-keyword">return</span> big(overlay);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   * 放大图片</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> bitmap 需要放大的图片</span><br><span class="hljs-comment">           <span class="hljs-doctag">@return</span> 放大的图片</span><br><span class="hljs-comment">               */</span><br>              <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">big</span><span class="hljs-params">(Bitmap bitmap)</span> &#123;<br>          <span class="hljs-type">Matrix</span> <span class="hljs-variable">matrix</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>();<br>          matrix.postScale(<span class="hljs-number">4f</span>, <span class="hljs-number">4f</span>);<br>          <span class="hljs-type">Bitmap</span> <span class="hljs-variable">resizeBmp</span> <span class="hljs-operator">=</span> Bitmap.createBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="hljs-literal">true</span>);<br>          <span class="hljs-keyword">return</span> resizeBmp;<br>              &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   * 缩小图片</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> bitmap 需要缩小的图片</span><br><span class="hljs-comment">           <span class="hljs-doctag">@return</span> 缩小的图片</span><br><span class="hljs-comment">               */</span><br>              <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title function_">small</span><span class="hljs-params">(Bitmap bitmap)</span> &#123;<br>          <span class="hljs-type">Matrix</span> <span class="hljs-variable">matrix</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>();<br>          matrix.postScale(<span class="hljs-number">0.25f</span>, <span class="hljs-number">0.25f</span>);<br>          <span class="hljs-type">Bitmap</span> <span class="hljs-variable">resizeBmp</span> <span class="hljs-operator">=</span> Bitmap.createBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="hljs-literal">true</span>);<br>          <span class="hljs-keyword">return</span> resizeBmp;<br>              &#125;<br><br>​    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   * 将图片模糊化</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> sentBitmap 需要模糊的图片</span><br><span class="hljs-comment">           <span class="hljs-doctag">@param</span> radius     模糊程度</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@return</span> 模糊后的图片</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">                   private static Bitmap fastblur(Bitmap sentBitmap, int radius) &#123;</span><br><span class="hljs-comment">               Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true);</span><br><span class="hljs-comment">               if (radius &lt; 1) &#123;</span><br><span class="hljs-comment">                   return (null);</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">               int w = bitmap.getWidth();</span><br><span class="hljs-comment">               int h = bitmap.getHeight();</span><br><span class="hljs-comment">               int[] pix = new int[w * h];</span><br><span class="hljs-comment">               bitmap.getPixels(pix, 0, w, 0, 0, w, h);</span><br><span class="hljs-comment">               int wm = w - 1;</span><br><span class="hljs-comment">               int hm = h - 1;</span><br><span class="hljs-comment">               int wh = w * h;</span><br><span class="hljs-comment">               int div = radius + radius + 1;</span><br><span class="hljs-comment">               int r[] = new int[wh];</span><br><span class="hljs-comment">               int g[] = new int[wh];</span><br><span class="hljs-comment">               int b[] = new int[wh];</span><br><span class="hljs-comment">               int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;</span><br><span class="hljs-comment">               int vmin[] = new int[Math.max(w, h)];</span><br><span class="hljs-comment">               int divsum = (div + 1) &gt;&gt; 1;</span><br><span class="hljs-comment">               divsum *= divsum;</span><br><span class="hljs-comment">               int dv[] = new int[256 * divsum];</span><br><span class="hljs-comment">               for (i = 0; i &lt; 256 * divsum; i++) &#123;</span><br><span class="hljs-comment">                   dv[i] = (i / divsum);</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">               yw = yi = 0;</span><br><span class="hljs-comment">               int[][] stack = new int[div][3];</span><br><span class="hljs-comment">               int stackpointer;</span><br><span class="hljs-comment">               int stackstart;</span><br><span class="hljs-comment">               int[] sir;</span><br><span class="hljs-comment">               int rbs;</span><br><span class="hljs-comment">               int r1 = radius + 1;</span><br><span class="hljs-comment">               int routsum, goutsum, boutsum;</span><br><span class="hljs-comment">               int rinsum, ginsum, binsum;</span><br><span class="hljs-comment">               for (y = 0; y &lt; h; y++) &#123;</span><br><span class="hljs-comment">                   rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;</span><br><span class="hljs-comment">                   for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="hljs-comment">               p = pix[yi + Math.min(wm, Math.max(i, 0))];</span><br><span class="hljs-comment">               sir = stack[i + radius];</span><br><span class="hljs-comment">               sir[0] = (p &amp; 0xff0000) &gt;&gt; 16;</span><br><span class="hljs-comment">               sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8;</span><br><span class="hljs-comment">               sir[2] = (p &amp; 0x0000ff);</span><br><span class="hljs-comment">               rbs = r1 - Math.abs(i);</span><br><span class="hljs-comment">               rsum += sir[0] * rbs;</span><br><span class="hljs-comment">               gsum += sir[1] * rbs;</span><br><span class="hljs-comment">               bsum += sir[2] * rbs;</span><br><span class="hljs-comment">               if (i &gt; 0) &#123;</span><br><span class="hljs-comment">                   rinsum += sir[0];</span><br><span class="hljs-comment">                   ginsum += sir[1];</span><br><span class="hljs-comment">                   binsum += sir[2];</span><br><span class="hljs-comment">               &#125; else &#123;</span><br><span class="hljs-comment">                   routsum += sir[0];</span><br><span class="hljs-comment">                   goutsum += sir[1];</span><br><span class="hljs-comment">                   boutsum += sir[2];</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">                   &#125;</span><br><span class="hljs-comment">                   stackpointer = radius;</span><br><span class="hljs-comment">                   for (x = 0; x &lt; w; x++) &#123;</span><br><span class="hljs-comment">               r[yi] = dv[rsum];</span><br><span class="hljs-comment">               g[yi] = dv[gsum];</span><br><span class="hljs-comment">               b[yi] = dv[bsum];</span><br><span class="hljs-comment">               rsum -= routsum;</span><br><span class="hljs-comment">               gsum -= goutsum;</span><br><span class="hljs-comment">               bsum -= boutsum;</span><br><span class="hljs-comment">               stackstart = stackpointer - radius + div;</span><br><span class="hljs-comment">               sir = stack[stackstart % div];</span><br><span class="hljs-comment">               routsum -= sir[0];</span><br><span class="hljs-comment">               goutsum -= sir[1];</span><br><span class="hljs-comment">               boutsum -= sir[2];</span><br><span class="hljs-comment">               if (y == 0) &#123;</span><br><span class="hljs-comment">                   vmin[x] = Math.min(x + radius + 1, wm);</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">               p = pix[yw + vmin[x]];</span><br><span class="hljs-comment">               sir[0] = (p &amp; 0xff0000) &gt;&gt; 16;</span><br><span class="hljs-comment">               sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8;</span><br><span class="hljs-comment">               sir[2] = (p &amp; 0x0000ff);</span><br><span class="hljs-comment">               rinsum += sir[0];</span><br><span class="hljs-comment">               ginsum += sir[1];</span><br><span class="hljs-comment">               binsum += sir[2];</span><br><span class="hljs-comment">               rsum += rinsum;</span><br><span class="hljs-comment">               gsum += ginsum;</span><br><span class="hljs-comment">               bsum += binsum;</span><br><span class="hljs-comment">               stackpointer = (stackpointer + 1) % div;</span><br><span class="hljs-comment">               sir = stack[(stackpointer) % div];</span><br><span class="hljs-comment">               routsum += sir[0];</span><br><span class="hljs-comment">               goutsum += sir[1];</span><br><span class="hljs-comment">               boutsum += sir[2];</span><br><span class="hljs-comment">               rinsum -= sir[0];</span><br><span class="hljs-comment">               ginsum -= sir[1];</span><br><span class="hljs-comment">               binsum -= sir[2];</span><br><span class="hljs-comment">               yi++;</span><br><span class="hljs-comment">                   &#125;</span><br><span class="hljs-comment">                   yw += w;</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">               for (x = 0; x &lt; w; x++) &#123;</span><br><span class="hljs-comment">                   rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;</span><br><span class="hljs-comment">                   yp = -radius * w;</span><br><span class="hljs-comment">                   for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="hljs-comment">               yi = Math.max(0, yp) + x;</span><br><span class="hljs-comment">               sir = stack[i + radius];</span><br><span class="hljs-comment">               sir[0] = r[yi];</span><br><span class="hljs-comment">               sir[1] = g[yi];</span><br><span class="hljs-comment">               sir[2] = b[yi];</span><br><span class="hljs-comment">               rbs = r1 - Math.abs(i);</span><br><span class="hljs-comment">               rsum += r[yi] * rbs;</span><br><span class="hljs-comment">               gsum += g[yi] * rbs;</span><br><span class="hljs-comment">               bsum += b[yi] * rbs;</span><br><span class="hljs-comment">               if (i &gt; 0) &#123;</span><br><span class="hljs-comment">                   rinsum += sir[0];</span><br><span class="hljs-comment">                   ginsum += sir[1];</span><br><span class="hljs-comment">                   binsum += sir[2];</span><br><span class="hljs-comment">               &#125; else &#123;</span><br><span class="hljs-comment">                   routsum += sir[0];</span><br><span class="hljs-comment">                   goutsum += sir[1];</span><br><span class="hljs-comment">                   boutsum += sir[2];</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">               if (i &lt; hm) &#123;</span><br><span class="hljs-comment">                   yp += w;</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">                   &#125;</span><br><span class="hljs-comment">                   yi = x;</span><br><span class="hljs-comment">                   stackpointer = radius;</span><br><span class="hljs-comment">                   for (y = 0; y &lt; h; y++) &#123;</span><br><span class="hljs-comment">               pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum];</span><br><span class="hljs-comment">               rsum -= routsum;</span><br><span class="hljs-comment">               gsum -= goutsum;</span><br><span class="hljs-comment">               bsum -= boutsum;</span><br><span class="hljs-comment">               stackstart = stackpointer - radius + div;</span><br><span class="hljs-comment">               sir = stack[stackstart % div];</span><br><span class="hljs-comment">               routsum -= sir[0];</span><br><span class="hljs-comment">               goutsum -= sir[1];</span><br><span class="hljs-comment">               boutsum -= sir[2];</span><br><span class="hljs-comment">               if (x == 0) &#123;</span><br><span class="hljs-comment">                   vmin[y] = Math.min(y + r1, hm) * w;</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">               p = x + vmin[y];</span><br><span class="hljs-comment">               sir[0] = r[p];</span><br><span class="hljs-comment">               sir[1] = g[p];</span><br><span class="hljs-comment">               sir[2] = b[p];</span><br><span class="hljs-comment">               rinsum += sir[0];</span><br><span class="hljs-comment">               ginsum += sir[1];</span><br><span class="hljs-comment">               binsum += sir[2];</span><br><span class="hljs-comment">               rsum += rinsum;</span><br><span class="hljs-comment">               gsum += ginsum;</span><br><span class="hljs-comment">               bsum += binsum;</span><br><span class="hljs-comment">               stackpointer = (stackpointer + 1) % div;</span><br><span class="hljs-comment">               sir = stack[stackpointer];</span><br><span class="hljs-comment">               routsum += sir[0];</span><br><span class="hljs-comment">               goutsum += sir[1];</span><br><span class="hljs-comment">               boutsum += sir[2];</span><br><span class="hljs-comment">               rinsum -= sir[0];</span><br><span class="hljs-comment">               ginsum -= sir[1];</span><br><span class="hljs-comment">               binsum -= sir[2];</span><br><span class="hljs-comment">               yi += w;</span><br><span class="hljs-comment">                   &#125;</span><br><span class="hljs-comment">               &#125;</span><br><span class="hljs-comment">               bitmap.setPixels(pix, 0, w, 0, 0, w, h);</span><br><span class="hljs-comment">               return (bitmap);</span><br><span class="hljs-comment">                   &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导入litepal依赖遇到的问题</title>
    <link href="/%E5%AF%BC%E5%85%A5litepal%E4%BE%9D%E8%B5%96%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/%E5%AF%BC%E5%85%A5litepal%E4%BE%9D%E8%B5%96%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>添加litepal时候遇到了这个问题。</p><p><img src="/2023/03/31/%E5%AF%BC%E5%85%A5litepal%E4%BE%9D%E8%B5%96%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/litepal%E9%97%AE%E9%A2%98_1.png" alt="litepal问题_1"></p><p>参考资料：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/22351830">发布库AAR至mavenCentral看这篇文章就可以了</a></p></li><li><p><a href="https://blog.csdn.net/oubin66/article/details/100171069?spm=1001.2014.3001.5502">一篇文章看懂gradle</a></p></li><li><p><a href="https://docs.gradle.org/current/dsl/index.html">Gradle 官方文档</a></p></li></ul><p>那么buildscript中的repositories和allprojects的repositories的作用和区别是什么呢？<br> 答：<br> 1、 <code>buildscript</code>里是gradle脚本执行所需依赖，分别是对应的maven库和插件<br> 2、 <code>allprojects</code>里是项目本身需要的依赖，比如我现在要依赖我自己maven库的<code>toastutils</code>库，那么我应该将<code>maven &#123;url &#39;https://dl.bintray.com/calvinning/maven&#39;&#125;</code>写在这里，而不是<code>buildscript</code>中，不然找不到。</p><p>作者：CalvinNing<br>链接：<a href="https://www.jianshu.com/p/ee57e4de78a3">https://www.jianshu.com/p/ee57e4de78a3</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">pluginManagement</span> &#123;<br>    <span class="hljs-variable">repositories</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">gradlePluginPortal</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">google</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">mavenCentral</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">jcenter</span>()</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//1.功能位置迁移，原来在工程 build.gradle 的 buildscript 和 allprojects 移动至setting.gradle并改名为pluginManagement 和dependencyResolutionManagement。</span><br><span class="hljs-comment">// 里面的东西依旧可以按照原来的copy过来。</span><br><span class="hljs-variable">dependencyResolutionManagement</span> &#123;<br>    <span class="hljs-variable">repositoriesMode.set</span>(<span class="hljs-variable">RepositoriesMode.FAIL_ON_PROJECT_REPOS</span>)<br>    <span class="hljs-variable">repositories</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">google</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">mavenCentral</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">jcenter</span>()</span><br>        <span class="hljs-variable">maven</span> &#123; <span class="hljs-variable">url</span> <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span> &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-variable">rootProject.name</span> = <span class="hljs-string">&quot;WeatherAPP&quot;</span><br><span class="hljs-comment">// 上述字符串换中的冒号是用于分割目录的 , 如果再次创建一个 app2 目录 , 配置文件会自动变为</span><br><span class="hljs-variable">include</span> <span class="hljs-string">&#x27;:app&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git基本命令-1</title>
    <link href="/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-1/"/>
    <url>/git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-1/</url>
    
    <content type="html"><![CDATA[<h2 id="删除所关联的远程仓库地址"><a href="#删除所关联的远程仓库地址" class="headerlink" title="删除所关联的远程仓库地址"></a>删除所关联的远程仓库地址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><h2 id="关联新的远程仓库"><a href="#关联新的远程仓库" class="headerlink" title="关联新的远程仓库"></a>关联新的远程仓库</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add origin https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/youName/y</span>ouName.github.io.git<br></code></pre></td></tr></table></figure><h2 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure><h2 id="提交暂存区到本地仓库。"><a href="#提交暂存区到本地仓库。" class="headerlink" title="提交暂存区到本地仓库。"></a>提交暂存区到本地仓库。</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;commit message&quot;</span><br></code></pre></td></tr></table></figure><h2 id="推送到远程库source分支"><a href="#推送到远程库source分支" class="headerlink" title="推送到远程库source分支"></a>推送到远程库source分支</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">push</span> --<span class="hljs-keyword">set</span>-upstream origin Source<br></code></pre></td></tr></table></figure><h2 id="查看仓库当前的状态，显示有变更的文件。"><a href="#查看仓库当前的状态，显示有变更的文件。" class="headerlink" title="查看仓库当前的状态，显示有变更的文件。"></a>查看仓库当前的状态，显示有变更的文件。</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><h2 id="获取所有-Git-远程分支"><a href="#获取所有-Git-远程分支" class="headerlink" title="获取所有 Git 远程分支"></a>获取所有 Git 远程分支</h2><p>借助以下命令，我们将从其仓库中获取远程分支。origin 是我们定位的远程分支的名称。如果我们有一个 upstream 远程名称，我们可以将其称为 git fetch upstream。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git fetch origin<br></code></pre></td></tr></table></figure><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout "></a>git checkout <name-of-your-branch></name-of-your-branch></h2><p>这也是最常用的 Git 命令之一。要在分支中工作，首先需要切换到该分支。我们通常使用 <strong>git checkou</strong>t 从一个分支切换到另一个分支。我们还可以使用它来检出文件和提交（commits）。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">git checkout remotes<span class="hljs-regexp">/origin/</span><span class="hljs-keyword">Source</span><br>git checkout remotes<span class="hljs-regexp">/origin/m</span>aster<br></code></pre></td></tr></table></figure><h2 id="同时创建并切换到分支"><a href="#同时创建并切换到分支" class="headerlink" title="同时创建并切换到分支"></a><strong>同时创建并切换到分支</strong></h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b</span> &lt;name-of-your-branch&gt;<br></code></pre></td></tr></table></figure><h2 id="列出-Git-可用的分支"><a href="#列出-Git-可用的分支" class="headerlink" title="列出 Git 可用的分支"></a>列出 Git 可用的分支</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git branch -a<br></code></pre></td></tr></table></figure><h2 id="推送到追踪的分支"><a href="#推送到追踪的分支" class="headerlink" title="推送到追踪的分支"></a>推送到追踪的分支</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">git <span class="hljs-keyword">push</span> origin HEAD:<span class="hljs-keyword">Source</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具知识</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+Fluid主题美化</title>
    <link href="/hexo-Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <url>/hexo-Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_43471926/article/details/109798811"> Hexo-Fluid主题美化_hexo fluid_林慕凡的博客-CSDN博客</a></p><p><a href="http://lzqlearn.com/blog/6560820db005/#2-4-2-%E6%A0%87%E9%A2%98%E9%A2%9C%E8%89%B2">hexo博客fluid主题美化 - Gilgamesh’s Blog (lzqlearn.com)</a></p><p><a href="https://jin-yuhan.github.io/posts/60584518/">Fluid 主题美化汇总 - Stalo’s Blog (jin-yuhan.github.io)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidStudio的快捷键</title>
    <link href="/AS%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/AS%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>AS快捷键</p><table><thead><tr><th>作用</th><th>快捷键</th><th>注释</th></tr></thead><tbody><tr><td>格式化代码</td><td>Ctrl + Alt + L</td><td></td></tr><tr><td>隐藏所有面板</td><td>Ctrl + Shift + F12</td><td>切换编辑器铺满整个程序界面，隐藏其他的面板。再次执行该操作，将会回到隐藏前的状态。</td></tr><tr><td>最近访问</td><td>Ctrl + E</td><td>该操作可以得到一个最近访问文件的可搜索的列表。</td></tr><tr><td>最近修改的文件</td><td>Ctrl + Shift + E</td><td>该操作类似于“最近访问（Recents）”弹窗，会显示最近本地修改过的文件列表，根据修改时间排列。可以输入字符来过滤列表结果。</td></tr><tr><td>清除无效包引用</td><td>Alt + Ctrl + O</td><td></td></tr><tr><td>查找</td><td>Ctrl + F</td><td></td></tr><tr><td>查找+替换</td><td>Ctrl + R</td><td></td></tr><tr><td>上下移动代码</td><td>Alt + Shift + Up&#x2F;Down</td><td></td></tr><tr><td>快速查看定义</td><td>Ctrl + Shift + I</td><td>在不离开当前界面，快速查看其原始定义</td></tr><tr><td>语句补全</td><td>Ctrl + Shift + Enter</td><td>这个方法将会生成缺失的代码来补全语句。补全；) }</td></tr><tr><td>行复制</td><td>Ctrl + D</td><td>复制当前行，并粘贴到下一行，这个操作不会影响剪贴板的内容。这个命令配合移动行快捷键非常有用。</td></tr><tr><td>展开全部代            码块</td><td>ctrl+shift+加号</td><td></td></tr><tr><td>折叠全部代码  块</td><td>ctrl+shift+减号</td><td></td></tr><tr><td>Sublime Text            式的多处选择</td><td>Alt + Ｊ</td><td>该操作会识别当前选中字符串，选择下一个同样的字符串，并且添加一个光标。这意味着你可以在同一个文件里拥有多个光标，你可以同时在所有光标处输入任何东西。</td></tr><tr><td>切换器</td><td>Ctrl + Tab</td><td>该快捷键基本上就是IDE的alt+tab&#x2F;cmd+tab命令。你可以用它在导航tab或者面板切换。一旦打开这个窗口，只要一直按着ctrl键，你可以通过对应的数字或者字母快捷键快速选择。你也可以通过backspace键来关闭一个已选中的tab或者面板。</td></tr><tr><td>提取方法</td><td>Ctrl + Alt + M</td><td>提取一段代码块，生成一个新的方法。当你发现某个方法里面过于复杂，需要将某一段代码提取成单独的方法时，该技巧是很有用的。</td></tr><tr><td>重命名</td><td>Shift + F6</td><td>你可以通过该操作重命名变量、字段、方法、类、包。当然了，该操作会确保重命名对上下文有意义，不会无脑替换掉所有文件中的名字；</td></tr><tr><td>书签</td><td>添加&#x2F;移除书签：F11     添加&#x2F;移除书签(带标记)：Ctrl + F11;      显示全部书签：Shift + F11</td><td>这是一个很有用的功能，让你可以在某处做个标记（书签），方便后面再跳转到此处</td></tr></tbody></table><p><a href="https://blog.csdn.net/Pandafz1997/article/details/117716771">快速编程法宝之掌握AS和IDEA快捷键</a></p><p><a href="https://blog.csdn.net/lyp13243189027/article/details/52329991">AS快捷键</a></p>]]></content>
    
    
    <categories>
      
      <category>工具知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidStudio里面gradle相关配置</title>
    <link href="/AndroidStudio%E9%87%8C%E9%9D%A2gradle%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <url>/AndroidStudio%E9%87%8C%E9%9D%A2gradle%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>对我自己掌握的关于gradle相关的知识进行一个整理。</p><p>下面是Android studio里面比较重要的gradle文件。会逐一的进行解析。</p><p><img src="/2023/03/28/AndroidStudio%E9%87%8C%E9%9D%A2gradle%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/AndroidStudio%E9%87%8C%E9%9D%A2gradle%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE_1-16801876551372.jpg"></p><h2 id="1-build-gradle-模块里面"><a href="#1-build-gradle-模块里面" class="headerlink" title="1. build.gradle(模块里面)"></a>1. build.gradle(模块里面)</h2><p>   里面的具体内容参考我之前写的一篇博客：<a href="https://blog.csdn.net/qq_43867812/article/details/126850708">详解build.gradle文件</a>。这个文件里面是对当前的module进行配置。</p><h2 id="2-build-gradle（项目里面）"><a href="#2-build-gradle（项目里面）" class="headerlink" title="2. build.gradle（项目里面）"></a>2. build.gradle（项目里面）</h2><p>   这个文件添加所有子项目&#x2F;模块通用的配置选项。可以看到他自动生成的里面添加了gradle的依赖，我的版本是7.2.1。当我们需要清除gradle生成的配置文件，也就是build文件夹，就会执行<img src="/2023/03/28/AndroidStudio%E9%87%8C%E9%9D%A2gradle%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/e881b49610a0494d97cc290c6eb0da81.png" alt="在这里插入图片描述"><br>   <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span><br>plugins &#123;<br>    id <span class="hljs-string">&#x27;com.android.application&#x27;</span> version <span class="hljs-string">&#x27;7.2.1&#x27;</span> apply <span class="hljs-literal">false</span><br>    id <span class="hljs-string">&#x27;com.android.library&#x27;</span> version <span class="hljs-string">&#x27;7.2.1&#x27;</span> apply <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 运行gradle clean时，执行此处定义的task任务。</span><br><span class="hljs-comment">// 该任务继承自Delete，删除根目录中的build目录。</span><br><span class="hljs-comment">// 相当于执行Delete.delete(rootProject.buildDir)。</span><br><span class="hljs-comment">// gradle使用groovy语言，调用method时可以不用加（）。</span><br>task clean(<span class="hljs-attr">type:</span> Delete) &#123;<br>    delete rootProject.buildDir<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="3-gradle-properties"><a href="#3-gradle-properties" class="headerlink" title="3. gradle.properties"></a>3. gradle.properties</h2><p>   主要是增加和修改一些可以在构建过程中直接使用的参数。具体怎么使用，暂时没有研究，也许未来会进行补充。</p><h2 id="4-setting-gradle"><a href="#4-setting-gradle" class="headerlink" title="4. setting.gradle"></a>4. setting.gradle</h2><p>   这个文件是我今天之前了解最少的，今天查了不少其他人的博客，终于大致弄懂了一些。</p><p>   首先第一个注意事项：在gradle7.1以后的版本中，发生了功能模块迁移。</p><p>   原来在工程build.gradle的buildscript和allprojects移动至setting.gradle并改名为pluginManagement 和dependencyResolutionManagement。里面的东西依旧可以按照原来的copy过来。</p><p>  <a href="https://blog.csdn.net/sinat_38167329/article/details/123175556">Android Gradle 7.1+新版本依赖变化</a></p><p>   下面我讲对里面的相关配置进行解析：</p><ol><li><p>pluginManagement ：</p><p><code>pluginManagement&#123;&#125;</code>语法块是专门用于管理整个项目插件的，只能出现在<code>settings.gradle</code>文件或”初始化脚本“中，并且在<code>settings.gradle</code>文件中<code>pluginManagement&#123;&#125;</code>必须是文件中的第一个块。</p><ul><li>repositories{}语法块，用于指定仓库，有以下常用选项：<ul><li>mavenLocal()：本地Maven仓库（ ${user.home}&#x2F;.m2&#x2F;repository ）</li><li>mavenCentral()：中央Maven仓库（ <a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ）</li><li>maven { url ‘https:&#x2F;&#x2F;…’ }：可用于Maven私服、镜像服务器等</li><li>ivy {url “..&#x2F;local-repo”}：本地的ivy仓库</li><li>ivy {url “<a href="http://repo.mycompany.com/repo%22%7D%EF%BC%9A%E8%BF%9C%E7%A8%8B%E7%9A%84ivy%E4%BB%93%E5%BA%93">http://repo.mycompany.com/repo&quot;}：远程的ivy仓库</a></li><li>google()：google仓库（<a href="https://maven.google.com)/">https://maven.google.com）</a></li></ul></li><li>dependencies{}语法块，用于指定要使用的插件，由classpath关键字指定，格式为：classpath ‘group:name:version’</li></ul><p><a href="https://blog.csdn.net/LiMubai_CN/article/details/102790699">Gradle入门教程</a></p><p>那么buildscript中的repositories和allprojects的repositories的作用和区别是什么呢？</p><ol><li><code>buildscript</code>里是gradle脚本执行所需依赖，分别是对应的maven库和插件</li><li><code>allprojects</code>里是项目本身需要的依赖，比如我现在要依赖我自己maven库的<code>toastutils</code>库，那么我应该将<code>maven &#123;url &#39;https://d l.bin tray.com/calvinning/maven&#39;&#125;</code>写在这里，而不是<code>buildscript</code>中，不然找不到。</li></ol><p>  <strong><a href="https://www.jianshu.com/p/ee57e4de78a3">buildscript和allprojects的作用和区别是什么？</a></strong></p></li></ol><p><img src="/2023/03/28/AndroidStudio%E9%87%8C%E9%9D%A2gradle%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/b0daea2d7185444abe7de6dfe4a188a9.png" alt="在这里插入图片描述"></p><p>上图应该和自动生成的有些许区别。多了下面的代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">jcenter</span><span class="hljs-params">()</span></span><br>maven &#123; url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>这里就是导入了<a href="https://link.zhihu.com/?target=https://jitpack.io/">jitpack.io</a>。</p><p>科普记录：在之前的Android gradle里面生成的应该是jcenter()，但是现在MavenCentral，原因是Jcenter服务即将关闭，谷歌没有收购他，所以改用mavenCentral，所以之前很多第三方库都不能使用了，不过很多个人开发者将自己开发的库也移植到了新的服务器。例如<a href="https://link.zhihu.com/?target=https://jitpack.io/">jitpack.io</a>。所以我们可以通过上面的代码导入地址。</p><p><a href="https://zhuanlan.zhihu.com/p/363156372">Jcenter服务即将关闭，改用mavenCentral</a></p><p>下面的两行代码理解应该是比较简单的。include是groovy里面的代码。<br><img src="/2023/03/28/AndroidStudio%E9%87%8C%E9%9D%A2gradle%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/72dc8fd3d64a4d6a94b0f1f84fd7ece8.png" alt="在这里插入图片描述"></p><p>在 <a href="https://so.csdn.net/so/search?q=Groovy&spm=1001.2101.3001.7020">Groovy</a> 语法中 , 就是调用了 include 方法 , 传入了 ‘:app’ 字符串作为参数 ;</p><p>当我们在项目中new 一个module时，下面会增加一个新的include。<br>附上我看到的别人的博客记录：</p><blockquote><p>AndroidStudio gradle 7.0+配置说明<br>本文链接：<a href="https://blog.csdn.net/Jun_P/article/details/126792012">https://blog.csdn.net/Jun_P/article/details/126792012</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android隐藏头部状态栏</title>
    <link href="/Android%E9%9A%90%E8%97%8F%E5%A4%B4%E9%83%A8%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <url>/Android%E9%9A%90%E8%97%8F%E5%A4%B4%E9%83%A8%E7%8A%B6%E6%80%81%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Android隐藏头部状态栏"><a href="#Android隐藏头部状态栏" class="headerlink" title="Android隐藏头部状态栏"></a>Android隐藏头部状态栏</h1><h3 id="1-onCreate-中通过代码隐藏（MainActivity）"><a href="#1-onCreate-中通过代码隐藏（MainActivity）" class="headerlink" title="1. onCreate 中通过代码隐藏（MainActivity）"></a>1. onCreate 中通过代码隐藏（MainActivity）</h3><p>首先贴上官网介绍的方法</p><p><a href="https://developer.android.google.cn/training/system-ui/status?hl=zh-cn#41">隐藏状态栏  | Android 开发者  | Android Developers</a></p><p>在Android4.1之后，如果Activity继承的是Application，则用官方介绍的办法来隐藏状态栏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">decorView</span> <span class="hljs-operator">=</span> getWindow().getDecorView();<br><span class="hljs-comment">// Hide the status bar.</span><br><span class="hljs-type">int</span> <span class="hljs-variable">uiOptions</span> <span class="hljs-operator">=</span> View.SYSTEM_UI_FLAG_FULLSCREEN;<br>decorView.setSystemUiVisibility(uiOptions);<br><span class="hljs-comment">// Remember that you should never show the action bar if the</span><br><span class="hljs-comment">// status bar is hidden, so hide that too if necessary.</span><br><span class="hljs-type">ActionBar</span> <span class="hljs-variable">actionBar</span> <span class="hljs-operator">=</span> getActionBar();<br>actionBar.hide();<br></code></pre></td></tr></table></figure><p>存下错误：getActionBar的值是null。</p><p><strong>如果Activity继承了Appcompat，则必须使用getSupportActionBar()来获取ActionBar</strong></p><p>我实验之后发现这部分代码有部分废弃了。具体作用也不是很明确。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">View decorView <span class="hljs-operator">=</span> getWindow().getDecorView()<span class="hljs-comment">;</span><br>int uiOptions <span class="hljs-operator">=</span> View.SYSTEM_UI_FLAG_FULLSCREEN<span class="hljs-comment">;</span><br>decorView.setSystemUiVisibility(uiOptions)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ol><li><p>MainActivity 继承 Activity 时<br>如果在 onCreate –&gt; setContentView 方法之后加则会报错。<br>onCreate –&gt; setContentView 方法前加入以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">requestWindowFeature(Window.FEATURE_NO_TITLE);<br></code></pre></td></tr></table></figure></li><li><p>MainActivity 继承 AppCompatActivity 时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ActionBar</span> <span class="hljs-variable">actionBar</span> <span class="hljs-operator">=</span> getSupportActionBar();<br>        <span class="hljs-keyword">if</span> (actionBar!=<span class="hljs-literal">null</span>) &#123;<br>            actionBar.hide();<br>        &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-布局清单中通过-Activity-theme-隐藏（AndroidMainfest）"><a href="#2-布局清单中通过-Activity-theme-隐藏（AndroidMainfest）" class="headerlink" title="2.布局清单中通过 Activity theme 隐藏（AndroidMainfest）"></a>2.布局清单中通过 Activity theme 隐藏（AndroidMainfest）</h3><p>这种方式，MainActivity 继承 Activity 或 AppCompatActivity 都可用</p><p>在 res —&gt; values —&gt; styles —&gt; 中加入以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;HideStyle&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>然后在需要隐藏标题栏的activity标签声明中，加入以下代码即可；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:theme=&quot;@style/HideStyle&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android动态申请权限</title>
    <link href="/Android%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7/"/>
    <url>/Android%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-可以在AndroidManifest里面注册的权限："><a href="#1-可以在AndroidManifest里面注册的权限：" class="headerlink" title="1.可以在AndroidManifest里面注册的权限："></a>1.可以在AndroidManifest里面注册的权限：</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCEPT_HANDOVER&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许呼应用继续在另一个应用中启动的呼叫 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用访问后台的位置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_BLOBS_ACROSS_USERS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序访问跨用户的数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_CHECKIN_PROPERTIES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许阅读/写入检查数据库中的&quot;属性&quot;表，以更改上传的值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序访问大致位置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用访问精确位置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_LOCATION_EXTRA_COMMANDS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许程序访问额外的定位提供者指令 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_MEDIA_LOCATION&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序访问用户共享集合中持续存在的任何地理位置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序访问有关网络的信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_NOTIFICATION_POLICY&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 希望访问通知策略的应用程序的标记权限 此权限不支持托管配置文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序访问有关 Wi-Fi 网络的信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCOUNT_MANAGER&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序调用到帐户授权人 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACTIVITY_RECOGNITION&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序识别身体活动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ADD_VOICEMAIL&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序向系统添加语音信箱 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ANSWER_PHONE_CALLS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序接听来电 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BATTERY_STATS&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序收集电池统计数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 确保只有系统可以绑定它 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BIND_APPWIDGET&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序告诉AppWidget服务哪些应用程序可以访问AppWidget数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BIND_CARRIER_SERVICES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许与运营商应用中的服务绑定的系统过程将获得此权限 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BIND_COMPANION_DEVICE_SERVICE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 任何 s 都必须确保只有系统才能与系统结合 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BIND_CONTROLS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许系统UI请求第三方控制 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BIND_DEVICE_ADMIN&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 设备管理接收器必须要求 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BLUETOOTH&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序连接到配对蓝牙设备 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BLUETOOTH_ADMIN&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序发现和配对蓝牙设备 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BLUETOOTH_ADVERTISE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 需要能够向附近的蓝牙设备做广告 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BLUETOOTH_CONNECT&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 需要能够连接到配对蓝牙设备 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BLUETOOTH_PRIVILEGED&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序在不进行用户交互的情况下对蓝牙设备进行配对，并允许或不允许电话簿访问或消息访问 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BLUETOOTH_SCAN&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 需要能够发现和配对附近的蓝牙设备 --&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BODY_SENSORS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序从用户用来测量体内发生的情况（如心率）的传感器访问数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BROADCAST_PACKAGE_REMOVED&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序广播已删除应用程序包的通知 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BROADCAST_SMS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序广播短信收据通知 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BROADCAST_STICKY&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序广播粘性意图 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.BROADCAST_WAP_PUSH&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序广播 WAP 推送接收通知 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CALL_COMPANION_APP&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许实现 API 的应用有资格作为呼叫伴侣应用启用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CALL_PHONE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序启动电话呼叫，而无需通过拨号器用户界面，以便用户确认呼叫 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CALL_PRIVILEGED&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序拨打任何电话号码（包括紧急号码），而无需通过 Dialer 用户界面为用户确认已放置的呼叫 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 需要能够访问摄像机设备 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CAPTURE_AUDIO_OUTPUT&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序捕获音频输出 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CHANGE_COMPONENT_ENABLED_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序更改应用程序组件（其自身除外）是否启用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CHANGE_CONFIGURATION&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序修改当前配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CHANGE_NETWORK_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序更改网络连接状态 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CHANGE_WIFI_MULTICAST_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序进入 Wi-Fi 多播模式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CHANGE_WIFI_STATE&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序更改 Wi-Fi 连接状态 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CLEAR_APP_CACHE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序清除设备上所有已安装应用程序的缓存 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CONTROL_LOCATION_UPDATES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许启用/禁用来自收音机的位置更新通知 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.DELETE_CACHE_FILES&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 删除应用缓存文件的旧权限不再使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.DELETE_PACKAGES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序删除包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.DIAGNOSTIC&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许将 RW 应用到诊断资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.DISABLE_KEYGUARD&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 如果密钥防护系统不安全，允许应用程序禁用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.DUMP&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序从系统服务中检索状态转储信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.允许应用程序扩展或折叠状态栏&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- EXPAND_STATUS_BAR --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.FACTORY_TEST&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 作为制造商测试应用程序运行 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许使用常规应用程序 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.GET_ACCOUNTS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许访问帐户服务中的帐户列表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.GET_PACKAGE_SIZE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序找出任何包所使用的空间 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.GLOBAL_SEARCH&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 此权限可用于内容提供商，以便全球搜索系统访问其数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.HIDE_OVERLAY_WINDOWS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用在上面绘制非系统覆盖窗口 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.HIGH_SAMPLING_RATE_SENSORS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用访问采样率大于 200 Hz 的传感器数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INSTALL_LOCATION_PROVIDER&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序将位置提供商安装到位置管理器中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INSTALL_PACKAGES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序安装包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INSTALL_SHORTCUT&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序在启动器中安装快捷方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INSTANT_APP_FOREGROUND_SERVICE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许即时应用创建前景服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERACT_ACROSS_PROFILES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许在同一配置文件组中跨配置文件进行交互 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序打开网络 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.KILL_BACKGROUND_PROCESSES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序调用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.LOADER_USAGE_STATS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许数据装载机读取包的访问日志。访问日志包含随着时间推移引用的页面集。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.LOCATION_HARDWARE&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序在硬件中使用位置功能 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MANAGE_DOCUMENTS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序管理对文档的访问，通常作为文档拾取器的一部分 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序在范围存储中广泛访问外部存储 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MANAGE_MEDIA&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序在未经用户确认的情况下修改和删除此设备或任何连接存储设备上的媒体文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MANAGE_ONGOING_CALLS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许查询持续呼叫详细信息并管理持续呼叫 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MANAGE_OWN_CALLS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许通过自我管理的 API 管理自己的呼叫的呼叫应用程序 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MEDIA_CONTENT_CONTROL&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序知道正在播放的内容并控制其播放 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序修改全球音频设置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MODIFY_PHONE_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许修改电话状态 - 打开电源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MOUNT_FORMAT_FILESYSTEMS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许为可移动存储格式化文件系统 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许安装和卸载文件系统以进行可拆卸存储 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.NFC&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序在 NFC 上执行 I/O 操作 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.NFC_PREFERRED_PAYMENT_INFO&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许申请接收 NFC 首选支付服务信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.NFC_TRANSACTION_EVENT&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序接收 NFC 交易事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.PACKAGE_USAGE_STATS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序收集组件使用情况统计 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.QUERY_ALL_PACKAGES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许查询设备上的任何正常应用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_CALENDAR&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序读取用户的日历数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_CALL_LOG&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序读取用户的通话记录。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_CONTACTS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序读取用户的联系人数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 允许应用程序从外部存储中读取 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_LOGS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序读取低级系统日志文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_PHONE_NUMBERS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许读取设备的电话号码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_PHONE_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 仅允许阅读访问电话状态，包括当前的蜂窝网络信息、任何持续呼叫的状态 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_PRECISE_PHONE_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许阅读访问精确的手机状态 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_SMS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序读取短信 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_SYNC_SETTINGS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序读取同步设置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_SYNC_STATS&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序读取同步统计数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_VOICEMAIL&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序在系统中读取语音信箱 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REBOOT&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 需要能够重新启动设备 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序在系统完成启动后接收广播 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.RECEIVE_MMS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序监控传入的彩信 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.RECEIVE_SMS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序接收短信 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.RECEIVE_WAP_PUSH&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序接收 WAP 推送消息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.RECORD_AUDIO&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序录制音频 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_COMPANION_PROFILE_WATCH&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用请求通过&quot;手表&quot;与设备关联 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许配套应用在后台运行 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_COMPANION_START_FOREGROUND_SERVICES_FROM_BACKGROUND&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许配套应用从后台开始前景服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许配套应用在后台使用数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_DELETE_PACKAGES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序请求删除包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 申请必须持有才能使用的权 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序请求安装包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 允许应用程序订阅有关其关联配套设备的存在状态更改的通知 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.REQUEST_PASSWORD_COMPLEXITY&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序请求屏幕锁的复杂性，并提示用户将屏幕锁更新到一定的复杂性级别 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SCHEDULE_EXACT_ALARM&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序使用精确的报警 API --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SEND_RESPOND_VIA_MESSAGE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序 （电话） 向其他应用程序发送请求，以便在来电期间处理响应消息操作 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SEND_SMS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序发送短信 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_ALARM&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序广播意图为用户设置闹钟 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_ALWAYS_FINISH&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序控制在后台后立即完成活动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_ANIMATION_SCALE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 修改全局动画缩放因子 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_DEBUG_APP&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 配置调试应用程序 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_PROCESS_LIMIT&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序设置可以运行的最大数量（不需要）应用程序过程 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_TIME&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序直接设置系统时间 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_TIME_ZONE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序直接设置系统时区 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_WALLPAPER&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序设置壁纸 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SET_WALLPAPER_HINTS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序设置壁纸提示 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SIGNAL_PERSISTENT_PROCESSES&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序请求向所有持久性过程发送信号 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.START_FOREGROUND_SERVICES_FROM_BACKGROUND&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序随时从后台开始前景服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.START_VIEW_PERMISSION_USAGE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许持有人启动应用程序的权限使用屏幕 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.STATUS_BAR&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序打开、关闭或禁用状态栏及其图标 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用使用该类型创建窗口，该类型显示在所有其他应用的顶部 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.TRANSMIT_IR&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 如果可用，允许使用设备的红外发射器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.UPDATE_DEVICE_STATS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序更新设备统计数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.UPDATE_PACKAGES_WITHOUT_USER_ACTION&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序通过该应用程序指示应用更新不需要用户操作 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.USE_BIOMETRIC&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用使用设备支持的生物识别模式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许读取设备标识符并使用基于 ICC 的身份验证（如 EAP-AKA） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.USE_SIP&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序使用 SIP 服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.UWB_RANGING&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 需要能够使用超宽带的设备 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.VIBRATE&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许访问振动器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WAKE_LOCK&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许使用电源经理唤醒锁来防止处理器睡觉或屏幕变暗 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_APN_SETTINGS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序编写 apn 设置并读取现有 apn 设置的敏感字段（如用户和密码） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_CALENDAR&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序编写用户的日历数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_CALL_LOG&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序编写（但未读取）用户的呼叫日志数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_CONTACTS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序编写用户的联系人数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 允许应用程序写入外部存储。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_GSERVICES&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序修改 Google 服务地图 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_SECURE_SETTINGS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序读取或编写安全系统设置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_SETTINGS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序读取或编写系统设置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_SYNC_SETTINGS&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序编写同步设置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_VOICEMAIL&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 允许应用程序修改和删除系统中现有的语音信箱 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-动态申请权限"><a href="#2-动态申请权限" class="headerlink" title="2.动态申请权限"></a>2.动态申请权限</h1><ol><li><h2 id="判断是否有权限"><a href="#判断是否有权限" class="headerlink" title="判断是否有权限"></a>判断是否有权限</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (ContextCompat.checkSelfPermission(<span class="hljs-built_in">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE)<br>        != PackageManager.PERMISSION_GRANTED) &#123;<br>    ActivityCompat.requestPermissions(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h2 id="申请权限"><a href="#申请权限" class="headerlink" title="申请权限"></a>申请权限</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRequestPermissionsResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode, <span class="hljs-meta">@NonNull</span> String[] permissions, <span class="hljs-meta">@NonNull</span> <span class="hljs-type">int</span>[] grantResults)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>    <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (grantResults.length != <span class="hljs-number">0</span> &amp;&amp; grantResults[<span class="hljs-number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;<br>            Toast.makeText(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;权限开启成功&quot;</span>, Toast.LENGTH_SHORT).show();<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Toast.makeText(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;权限开启失败&quot;</span>, Toast.LENGTH_SHORT).show();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LiveData的原理和使用</title>
    <link href="/LiveData%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/LiveData%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h1><h2 id="Livedata是什么？它的作用是什么？我们能用它来干什么？"><a href="#Livedata是什么？它的作用是什么？我们能用它来干什么？" class="headerlink" title="Livedata是什么？它的作用是什么？我们能用它来干什么？"></a>Livedata是什么？它的作用是什么？我们能用它来干什么？</h2><p>首先，LiveData是一种可观察的数据存储类。这句话可以看成两个部分，一个是可观察的类，另一个是数据存储的类。</p><ul><li>LiveData 是可以被观察的， 但是与常规的可观察类不同，Livadata具有感知生命周期的能力。意指它遵循其他应用组件（如 activity、fragment 或 service）的生命周期。有这种感知能力的LiveData ，只会通知活跃生命周期状态的应用组件观察者。</li><li>LiveData是用来存储数据的，这是它最直接的作用。当LiveData的数据发生变化的时候，就会通知应用组建的观察者。</li></ul><p>Observe类的生命周期处于Start或者Resumed状态时候，LiveData就认为Observe类处于活跃状态。也就是说LiveData只会通知活跃的观察者，也就是说处于其他生命周期的观察者，即使LiveData发生了变化，也不会收到通知。这样的好处是避免了内存泄露。</p><h2 id="LiveData的优势："><a href="#LiveData的优势：" class="headerlink" title="LiveData的优势："></a>LiveData的优势：</h2><ol><li>确保界面符合数据状态</li><li>不会发生内存泄漏</li><li>不会因 Activity 停止而导致崩溃</li><li>不再需要手动处理生命周期</li><li>数据始终保持最新状态</li><li>适当的配置更改</li><li>共享资源</li></ol><h2 id="LIveData的使用："><a href="#LIveData的使用：" class="headerlink" title="LIveData的使用："></a>LIveData的使用：</h2><ol><li>创建LiveData实例，用来存储某种类型的数据。我们通常在ViewModel中完成。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NameViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewModel</span> &#123;<br><span class="hljs-comment">// Create a LiveData with a String</span><br><span class="hljs-keyword">private</span> MutableLiveData&lt;String&gt; currentName;<br><br>    <span class="hljs-keyword">public</span> MutableLiveData&lt;String&gt; <span class="hljs-title function_">getCurrentName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//有一个判空</span><br>        <span class="hljs-keyword">if</span> (currentName == <span class="hljs-literal">null</span>) &#123;<br>            currentName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableLiveData</span>&lt;String&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> currentName;<br>    &#125;<br><span class="hljs-comment">// Rest of the ViewModel...</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>我们使用LiveData的方式主要有两种。<ul><li>一种是继承LiveData的子类MutableLIveData。因为LiveData是一个抽象类，我们不能直接继承，所以我们只能继承他的子类。</li><li>一种是创建可定义 onChanged() 方法的 Observer 对象，该方法可以控制当 LiveData 对象存储的数据更改时会发生什么。通常情况下，您可以在界面控制器（如 activity 或 fragment）中创建 Observer 对象。</li></ul></li><li>使用 observe() 方法将 Observer 对象附加到 LiveData 对象。observe() 方法会采用 LifecycleOwner 对象。这样会使 Observer 对象订阅 LiveData 对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 activity 或 fragment）中附加 Observer 对象。</li></ol><h2 id="LiveData的部分源码分析"><a href="#LiveData的部分源码分析" class="headerlink" title="LiveData的部分源码分析"></a>LiveData的部分源码分析</h2><h3 id="MutableLiveData对外公开数据更新"><a href="#MutableLiveData对外公开数据更新" class="headerlink" title="MutableLiveData对外公开数据更新"></a>MutableLiveData对外公开数据更新</h3><p>LiveData的子类MutableLiveData，是我们可以直接使用的子类。在LiveData 里面没有公开的方法来更新存储的数据，但是在MutableLiveData中给我们提供了两个修改LiveData对象值的方法：setValue(T)和postValue(T)。同样这个两个方法也是重写了LiveData里面的方法。这两个方法分别适用在不同的线程里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> androidx.lifecycle;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> LiveData&#125; which publicly exposes &#123;<span class="hljs-doctag">@link</span> #setValue(T)&#125; and &#123;<span class="hljs-doctag">@link</span> #postValue(T)&#125; method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; The type of data hold by this instance</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MutableLiveData</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LiveData</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a MutableLiveData initialized with the given &#123;<span class="hljs-doctag">@code</span> value&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value initial value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MutableLiveData</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">super</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a MutableLiveData with no value assigned to it.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MutableLiveData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果有活动的观察者，值将被发送给他们。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value 新值</span><br><span class="hljs-comment"> * 只能在主线程调用</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postValue</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">super</span>.postValue(value);<br>    &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果有活动的观察者，值将被发送给他们。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value 新值</span><br><span class="hljs-comment"> * 只能在子线程调用</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setValue(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="observe订阅源码分析"><a href="#observe订阅源码分析" class="headerlink" title="observe订阅源码分析"></a>observe订阅源码分析</h3><p>obeserve订阅有两个方法。一个感知生命周期observe（），一个不感知生命周期observeForever（）。</p><p>注册observe的方法需要传入两个参数，分别是生命周期的拥有者（一般是Activity、Fragment、Service）接收事件的观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">observe</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LifecycleOwner owner, <span class="hljs-meta">@NonNull</span> Observer&lt;? <span class="hljs-built_in">super</span> T&gt; observer)</span> &#123;<br>    assertMainThread(<span class="hljs-string">&quot;observe&quot;</span>);<br>    <span class="hljs-keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;<br>        <span class="hljs-comment">// ignore</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">LifecycleBoundObserver</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifecycleBoundObserver</span>(owner, observer);<br>    <span class="hljs-type">ObserverWrapper</span> <span class="hljs-variable">existing</span> <span class="hljs-operator">=</span> mObservers.putIfAbsent(observer, wrapper);<br>    <span class="hljs-keyword">if</span> (existing != <span class="hljs-literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot add the same observer&quot;</span><br>                + <span class="hljs-string">&quot; with different lifecycles&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (existing != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    owner.getLifecycle().addObserver(wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们逐句分析：</p><ol><li>这个方法执行必须在主线程，否则抛出异常。</li><li>生命周期的拥有者不能是destoryed状态，否则结束方法。或者说忽视订阅请求</li><li>对生命周期的拥有者lifecycleOwner和事件的观察者observer进行包装注册成一个LifecycleBoundObserver对象，这就是为什么LiveData能够感知生命周期的原因。</li><li>封包和观察者必须是对应的，一个观察者不能同时观察多个生命周期。但是一个生命周期可以绑定多个观察者</li><li>添加观察者，这里可以很清楚的看到，添加的观察者是wrapper，而不是我们传入的observer参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">observeForever</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Observer&lt;? <span class="hljs-built_in">super</span> T&gt; observer)</span> &#123;<br>    assertMainThread(<span class="hljs-string">&quot;observeForever&quot;</span>);<br>    <span class="hljs-type">AlwaysActiveObserver</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlwaysActiveObserver</span>(observer);<br>    <span class="hljs-type">ObserverWrapper</span> <span class="hljs-variable">existing</span> <span class="hljs-operator">=</span> mObservers.putIfAbsent(observer, wrapper);<br>    <span class="hljs-keyword">if</span> (existing != <span class="hljs-literal">null</span> &amp;&amp; existing <span class="hljs-keyword">instanceof</span> LiveData.LifecycleBoundObserver) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot add the same observer&quot;</span><br>                + <span class="hljs-string">&quot; with different lifecycles&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (existing != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    wrapper.activeStateChanged(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：这个方法创建的观察者，会永远收到数据变化的回调，在组件销毁时，需要用户手动的removObserver（）。</p><p>逐句分析：</p><ol><li><p>这里我们只传入了我们想设定的observer。没有传入生命周期的拥有者。</p></li><li><p>将observer包装成AlwaysActiviteObserver实例。同样wrapper和observer是对应的，如果已经添加到了LIveData，那么就抛出异常。</p></li><li><p>activeStateChanged（）方法传入true。将观察者立刻设置成活动态。它会一直保持在活动态，这就是他一直收到数据变化回调的秘诀。</p></li></ol><h3 id="observe移除源码"><a href="#observe移除源码" class="headerlink" title="observe移除源码"></a>observe移除源码</h3><p>LiveData提供的observe移除方法也有两种，一种是移除removeObserve（）方法传入的观察者。另一种是移除removeObserve（）方法传入的生命周期拥有者，这样就会直接移除该生命周期所有绑定的观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Observer&lt;? <span class="hljs-built_in">super</span> T&gt; observer)</span> &#123;<br>    assertMainThread(<span class="hljs-string">&quot;removeObserver&quot;</span>);<br>    <span class="hljs-type">ObserverWrapper</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> mObservers.remove(observer);<br>    <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    removed.detachObserver();<br>    removed.activeStateChanged(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>源码分析：</p><ol><li>判断主线程</li><li>分离观察者和生命周期拥有者</li><li>将观察者的一直设置成不活动态。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span><br><span class="hljs-meta">@MainThread</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObservers</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> LifecycleOwner owner)</span> &#123;<br>    assertMainThread(<span class="hljs-string">&quot;removeObservers&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Observer&lt;? <span class="hljs-built_in">super</span> T&gt;, ObserverWrapper&gt; entry : mObservers) &#123;<br>        <span class="hljs-keyword">if</span> (entry.getValue().isAttachedTo(owner)) &#123;<br>            removeObserver(entry.getKey());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里明显进行了一次遍历，逐一调用移除单个Observe的方法。</p><h3 id="LIfecycleBoundObserverl-类-和-AlwaysActiveObserver-类"><a href="#LIfecycleBoundObserverl-类-和-AlwaysActiveObserver-类" class="headerlink" title="LIfecycleBoundObserverl 类 和 AlwaysActiveObserver 类"></a>LIfecycleBoundObserverl 类 和 AlwaysActiveObserver 类</h3><p>这两个类就是上面我们包装形成wrapper，他们都继承了ObserWrapper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleBoundObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ObserverWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericLifecycleObserver</span> &#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">final</span> LifecycleOwner mOwner;<br><br>    LifecycleBoundObserver(<span class="hljs-meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="hljs-built_in">super</span> T&gt; observer) &#123;<br>        <span class="hljs-built_in">super</span>(observer);<br>        mOwner = owner;<br>    &#125;<br><span class="hljs-comment">//活动态，返回true</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldBeActive</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStateChanged</span><span class="hljs-params">(LifecycleOwner source, Lifecycle.Event event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;<br>            removeObserver(mObserver);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        activeStateChanged(shouldBeActive());<br>    &#125;<br><span class="hljs-comment">//判断当前的owner是绑定的owner</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAttachedTo</span><span class="hljs-params">(LifecycleOwner owner)</span> &#123;<br>        <span class="hljs-keyword">return</span> mOwner == owner;<br>    &#125;<br><span class="hljs-comment">//分离观察者和生命周期拥有者</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">detachObserver</span><span class="hljs-params">()</span> &#123;<br>        mOwner.getLifecycle().removeObserver(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LifecycleBoundObserver类里面的方法都是继承ObserverWrapper抽象类或者实现GenericLifecycleObserver接口的方法。实现GenericLifecycleObserver的onStateChanged（）方法是LiveData能够观察生命周期的原因，而且使用LiveData不会发生内存泄露，当生命周期处于destoryed状态时候，会移除Observe。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlwaysActiveObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ObserverWrapper</span> &#123;<br><br>    AlwaysActiveObserver(Observer&lt;? <span class="hljs-built_in">super</span> T&gt; observer) &#123;<br>        <span class="hljs-built_in">super</span>(observer);<br>    &#125;<br><span class="hljs-comment">//这里默认返回true，观察者一直收到回调</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldBeActive</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LiveData里面的postValue-和-setValue分析"><a href="#LiveData里面的postValue-和-setValue分析" class="headerlink" title="LiveData里面的postValue 和 setValue分析"></a>LiveData里面的postValue 和 setValue分析</h3><p>这两个方法是用来更新数据的，使用postValue 和 setValue传递数据，在onChange（）方法里面传入数据参数，进行更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//子线程</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postValue</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">boolean</span> postTask;<br>    <span class="hljs-keyword">synchronized</span> (mDataLock) &#123;<br>        postTask = mPendingData == NOT_SET;<br>        mPendingData = value;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!postTask) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);<br>&#125;<br></code></pre></td></tr></table></figure><p>我没有贴全部的代码。<code>ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</code>很显然这个是把数据又传递回主线程，在主线程中，又会调用setValue（）方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主线程</span><br><span class="hljs-meta">@MainThread</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;<br>    assertMainThread(<span class="hljs-string">&quot;setValue&quot;</span>);<br>    mVersion++;<br>    mData = value;<br>    dispatchingValue(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主线程检查，赋值，分发的操作，主要的逻辑在dispatchingValue（）方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Object</span> <span class="hljs-variable">mData</span> <span class="hljs-operator">=</span> NOT_SET;<br></code></pre></td></tr></table></figure><p>这里需要提一个很重要的变量mData，存放数据的变量，可以看到它可以接受Object类型的数据，而且他是volatile类型，对于这个类型的变量，编译器会直接从原始的内存地址进行存取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jAVA"><span class="hljs-meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="hljs-comment">/* synthetic access */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchingValue</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;<br><span class="hljs-comment">// mDispatchingValue的判断主要是为了解决并发调用dispatchingValue的情况</span><br><span class="hljs-comment">// 当对应数据的观察者在执行的过程中, 如有新的数据变更, 则不会再次通知到观察者。所以观察者内的执行不应进行耗时工作</span><br>    <span class="hljs-keyword">if</span> (mDispatchingValue) &#123;<br>        <span class="hljs-comment">//标记当前分发无效</span><br>        mDispatchInvalidated = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//标记正在分发</span><br>    mDispatchingValue = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        mDispatchInvalidated = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (initiator != <span class="hljs-literal">null</span>) &#123;<br>            considerNotify(initiator);<br>            initiator = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="hljs-built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =<br>                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;<br>                considerNotify(iterator.next().getValue());<br>                <span class="hljs-keyword">if</span> (mDispatchInvalidated) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (mDispatchInvalidated);<br>    mDispatching<br></code></pre></td></tr></table></figure><p>确实很复杂，但是我们只需要理解它最终是调用了considerNotify（）方法来分发我们的mData。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">considerNotify</span><span class="hljs-params">(ObserverWrapper observer)</span> &#123;<br>    <span class="hljs-comment">//检查活跃状态</span><br>    <span class="hljs-keyword">if</span> (!observer.mActive) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// we still first check observer.active to keep it as the entrance for events. So even if</span><br>    <span class="hljs-comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span><br>    <span class="hljs-comment">// notify for a more predictable notification order.</span><br>    <span class="hljs-keyword">if</span> (!observer.shouldBeActive()) &#123;<br>        observer.activeStateChanged(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//检查版本号</span><br>    <span class="hljs-comment">//每次setValue，version都会加一，当它超过我们的预设版本后，直接返回，防止我们多次调用onChange方法。</span><br>    <span class="hljs-keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    observer.mLastVersion = mVersion;<br>    <span class="hljs-comment">//noinspection unchecked</span><br>    observer.mObserver.onChanged((T) mData);<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的onChange（）方法相当眼熟啊！这里收到了mData变量。</p><h2 id="自定义LiveData时候会使用的方法："><a href="#自定义LiveData时候会使用的方法：" class="headerlink" title="自定义LiveData时候会使用的方法："></a>自定义LiveData时候会使用的方法：</h2><p>void onActive ()<br>Called when the number of active observers change to 1 from 0.<br>This callback can be used to know that this LiveData is being used thus should be kept up to date.</p><p>当这个方法被调用时，表示LiveData的观察者数量从0变为了1，这时就我们的位置监听来说，就应该注册我们的时间监听了。</p><p>void onInactive ()<br>Called when the number of active observers change from 1 to 0.<br>This does not mean that there are no observers left, there may still be observers but their lifecycle states aren’t STARTED or RESUMED (like an Activity in the back stack).<br>You can check if there are observers via hasObservers().</p><p>这个方法被调用时，表示LiveData的观察者数量变为了0，既然没有了观察者，也就没有理由再做监听，此时我们就应该将位置监听移除</p><h2 id="LiveData-数据监听机制流程图"><a href="#LiveData-数据监听机制流程图" class="headerlink" title="LiveData 数据监听机制流程图"></a>LiveData 数据监听机制流程图</h2><p><img src="/2023/03/28/LiveData%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATGVlU3R1ZGlvXw==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android进阶知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>匿名内部类</title>
    <link href="/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类，就是没有名字的一种嵌套类。它是Java对类的定义方式之</p><h2 id="为什么要使用匿名内部类"><a href="#为什么要使用匿名内部类" class="headerlink" title="为什么要使用匿名内部类"></a>为什么要使用匿名内部类</h2><p>在实际开发中，我们常常遇到这样的情况：一个接口&#x2F;类的方法的某个实现方式在程序中只会执行一次，但为了使用它，我们需要创建它的实现类&#x2F;子类去实现&#x2F;重写。此时可以使用匿名内部类的方式，可以无需创建新的类，减少代码冗余。</p><p><strong>匿名内部类是局部内部类的一种简化形式.本质上是一个对象,是实现了该接口或继承了该抽象类的子类对象.</strong></p><p>下面详细说明一下</p><p>假设当前有一个接口，接口中只有一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interface01</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了使用该接口的show方法，我们需要去创建一个实现类，同时书写show方法的具体实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Interface01Impl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interface01</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m a impl class...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果实现类Interface01Impl全程只使用一次，那么为了这一次的使用去创建一个类，未免太过麻烦。我们需要一个方式来帮助我们摆脱这个困境。匿名内部类则可以很好的解决这个问题。</p><p>我们使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Interface01</span> <span class="hljs-variable">interface01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Interface01</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;这里使用了匿名内部类&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//调用接口方法</span><br>    interface01.show();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="给匿名内部类名命"><a href="#给匿名内部类名命" class="headerlink" title="给匿名内部类名命:"></a>给匿名内部类名命:</h3><p><strong>虽然这是匿名内部类,但是仍然可以利用多态来给匿名内部类名命</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//匿名内部类</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aa</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;aaaaaaaaaaaaaaaa&quot;</span>);<br>            &#125;<br> <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hehe</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;hehehehehehhehehhe&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//此时,要想用同一个对象调用多个方法时,就会很难办到.这个时候给匿名内部类名命就可以解决了!</span><br>        <span class="hljs-comment">//利用多态进行名命</span><br>        <span class="hljs-type">AA</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aa</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;aaaaaaaaaaaaaa744444aa&quot;</span>);<br>            &#125;<br> <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hehe</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;hehehehehe888877777hhehehhe&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//这样就可以调用多个方法了</span><br>        aa.aa();<br>        aa.hehe();<br> <br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aa</span><span class="hljs-params">()</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hehe</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类的好处"><a href="#匿名内部类的好处" class="headerlink" title="匿名内部类的好处:"></a>匿名内部类的好处:</h3><p>匿名内部类，经常作为参数，或返回值，使用比较方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//匿名内部类，经常作为参数，或返回值，使用比较方便。</span><br>       <br>        test(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WW</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hehe</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;111111111&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br> <br>    <span class="hljs-comment">//方法的形参要一个抽象类类型，传递一个该抽象类的子类对象.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(WW ww)</span> &#123;<br>        ww.hehe();<br>    &#125;<br>&#125;<br> <br> <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WW</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hehe</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BB</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> getBB();<br>        bb.bb();<br> <br>        <span class="hljs-comment">//匿名内部类，作为返回值，返回方便</span><br>    &#125;<br> <br>    <span class="hljs-comment">//方法的返回值是一个抽象类 类型，返回一个该抽象类的子类对象。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BB <span class="hljs-title function_">getBB2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">BB</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BB</span>() &#123;<br> <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bb</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;bbbbbbbbbbbbbbbbb222222222&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//匿名内部类，作为返回值，返回方便</span><br>        <span class="hljs-keyword">return</span> b2;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bb</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一个类中可以嵌套一个接口"><a href="#一个类中可以嵌套一个接口" class="headerlink" title="一个类中可以嵌套一个接口:"></a>一个类中可以嵌套一个接口:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inter</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//this 代表匿名内部类</span><br>                System.out.println(<span class="hljs-built_in">this</span>.a);          <br>                System.out.println(Inter.a);         <br> <br> <br>            &#125;<br>        &#125;.show();<br> <br>    &#125;<br>&#125;<br> <br> <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://blog.csdn.net/a850661962/article/details/109642780">匿名内部类</a></p><p><a href="https://blog.csdn.net/a850661962/article/details/109642780">什么是匿名内部类，如何使用匿名内部类</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>final关键字</title>
    <link href="/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h1><p>java中的final关键字可以用来声明成员变量、本地变量、类、方法，并且经常和static一起使用声明常量。</p><h2 id="final关键字的含义"><a href="#final关键字的含义" class="headerlink" title="final关键字的含义:"></a>final关键字的含义:</h2><p>final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变吴再次初始化的话，编译路会报编译错误。</p><h3 id="final-变量"><a href="#final-变量" class="headerlink" title="final 变量"></a>final 变量</h3><p>​对于一个fianl变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改;如果是引用类型的变量，则在对其初始化之后便不能再让其指向另子个对象，但是地址中的值是可以改变的。</p><h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法:"></a>final方法:</h3><p>​final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为fnal。final方法比非fnal方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。</p><h3 id="final类"><a href="#final类" class="headerlink" title="final类:"></a>final类:</h3><p>​使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，警如StringInterger以及其他包装类。</p><h2 id="下面总结了一些使用final关键字的好处"><a href="#下面总结了一些使用final关键字的好处" class="headerlink" title="下面总结了一些使用final关键字的好处"></a>下面总结了一些使用final关键字的好处</h2><ol><li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li><li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li><li>使用final关键字，JVM会对方法、变量及类进行优化。</li><li>不可变类<br>创建不可变类要使用final关键字。不可变类是指它的对象一旦被创建了就不能被更改了。String是不可变类的代表。不可变类有很多好处譬如它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销等等。</li></ol><h2 id="关于final的重要知识点"><a href="#关于final的重要知识点" class="headerlink" title="关于final的重要知识点"></a>关于final的重要知识点</h2><ol><li>final关键字可以用于成员变量、本地变量、方法以及类。</li><li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</li><li>你不能够对final变量再次赋值。</li><li>本地变量必须在声明时赋值。</li><li>在匿名类中所有变量都必须是final变量。</li><li>final方法不能被重写。</li><li>final类不能被继承。</li><li>final关键字不同于finally关键字，后者用于异常处理。</li><li>final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。</li><li>接口中声明的所有变量本身是final的。</li><li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li><li>final方法在编译阶段绑定，称为静态绑定(static binding)</li><li>没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</li><li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li><li>按照Java代码惯例，final变量就是常量，而且通常常量名要大写:</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON学习笔记</title>
    <link href="/JSON%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/JSON%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="JSON的概念"><a href="#JSON的概念" class="headerlink" title="JSON的概念"></a>JSON的概念</h2><ul><li>JSON ：javascript object notation</li><li>JSON 是存储和交换文本信息的语法，类似 XML。但是json比xml更小、更快、更容易解析。</li><li>JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</li><li>JSON适用于进行数据交互的场景，如网站前台与后台之间的数据交互。</li></ul><h2 id="JSON的语法"><a href="#JSON的语法" class="headerlink" title="JSON的语法"></a>JSON的语法</h2><ol><li>json的语法是Javascript的语法子集。<ul><li>数据在<strong>名称&#x2F;值</strong>对中</li><li>数据由逗号 <strong>,</strong> 分隔</li><li>使用斜杆 *<em>*</em> 来转义字符</li><li>大括号 <strong>{}</strong> 保存对象</li><li>中括号 <strong>[]</strong> 保存数组，数组可以包含多个对象</li></ul></li><li>json 的数据结构<ul><li>1.大括号{ }保存的的对象是一个无序的<strong>名称&#x2F;值</strong>对的合集。一个对象以左括号 <strong>{</strong> 开始， 右括号 <strong>}</strong> 结束。每个”键”后跟一个冒号 <strong>:<strong>，</strong>名称&#x2F;值</strong>对使用逗号 <strong>,</strong> 分隔。</li><li><strong>数组：</strong>中括号 <strong>[]</strong> 保存的数组是值（value）的有序集合。一个数组以左中括号 <strong>[</strong> 开始， 右中括号 <strong>]</strong> 结束，值之间使用逗号 <strong>,</strong> 分隔。</li></ul></li></ol><h2 id="json的书写格式"><a href="#json的书写格式" class="headerlink" title="json的书写格式"></a>json的书写格式</h2><p>JSON 数据的书写格式是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">key <span class="hljs-punctuation">:</span> value<br></code></pre></td></tr></table></figure><p>JSON 值可以是：</p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在中括号中）</li><li>对象（在大括号中）</li><li>null</li></ul><p>JSON 对象：JSON 对象在大括号 <strong>{}</strong> 中书写。下面就是一个json对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">41</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;重庆&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;weather_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN101040100&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>JSON 数组：JSON 数组在中括号 <strong>[]</strong> 中书写，数组可包含多个对象。</p><p>下面的例子是对象city是包含四个对象的数组。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">41</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;重庆&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;weather_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN101040100&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">42</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;永川&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;weather_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN101040200&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">43</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;合川&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;weather_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN101040300&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">44</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;南川&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;weather_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN101040400&quot;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><a href="https://c.runoob.com/front-end/53/">JSON格式化工具</a></p><h1 id="Android-中解析json数据的方法"><a href="#Android-中解析json数据的方法" class="headerlink" title="Android 中解析json数据的方法"></a>Android 中解析json数据的方法</h1><h2 id="1-JsonObject"><a href="#1-JsonObject" class="headerlink" title="1.JsonObject"></a>1.JsonObject</h2><p>使用JSONObject解析JSON数据，这是Android中最基本的数据解析方式。谷歌官方提供的解析json数据的方法。</p><p>Android中提供的Json解析类</p><blockquote><ul><li>JSONObject： Json对象，可以完成Json字符串与Java对象的相互转换</li><li>JSONArray： Json数组，可以完成Json字符串与Java集合或对象的相互转换</li><li>JSONStringer： Json文本构建类，这个类可以帮助快速和便捷的创建JSON text， 每个JSONStringer实体只能对应创建一个JSON text</li><li>JSONTokener：Json解析类</li><li>JSONException：Json异常</li></ul></blockquote><p>下面使用代码实例进行分析：</p><h3 id="1-使用JSONArray类解析JSON数据的主要逻辑代码"><a href="#1-使用JSONArray类解析JSON数据的主要逻辑代码" class="headerlink" title="1.使用JSONArray类解析JSON数据的主要逻辑代码"></a>1.使用<strong>JSONArray类解析JSON数据的主要逻辑代码</strong></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;LiLi&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;95&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;LiLei&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;99&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;王明&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;100&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;LiLei&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;89&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>注意：因为””有申明字符串的意思我们初始化的是一个String字符串,所以在对象中需要<strong>用\对”进行转义</strong>，否则会造成String字符串提前结束的问题.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">JsonEg</span><span class="hljs-params">()</span>&#123;<br>    String json=<span class="hljs-string">&quot;[&#123;\&quot;name\&quot;:\&quot;LiLi\&quot;,\&quot;score\&quot;:\&quot;95\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;LiLei\&quot;,\&quot;score\&quot;:\&quot;99\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;王明\&quot;,\&quot;score\&quot;:\&quot;100\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;LiLei\&quot;,\&quot;score\&quot;:\&quot;89\&quot;&#125;]&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        JSONArray jsonArray=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>(json);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;jsonArray.length();i++)&#123;<br>            JSONObject object=jsonArray.getJSONObject(i);<br>            String name=object.optString(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-type">int</span> score=object.optInt(<span class="hljs-string">&quot;score&quot;</span>);<br>            Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;JsonEg: &quot;</span>+name+<span class="hljs-string">&quot;_______&quot;</span>+score);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/28/JSON%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Users\sc\AppData\Roaming\Typora\typora-user-images\image-20230322234500145.png" alt="image-20230322234500145"></p><p><strong>optString和getString区别</strong>：<br>    optString(“key”)如果为空返回 “” ，不报异常。优点：并不会应为key值使程序错误<br>    getString(“key”)如果为空，返回空指针异常。</p><h3 id="2-jsonObject对象解析"><a href="#2-jsonObject对象解析" class="headerlink" title="2.jsonObject对象解析"></a>2.jsonObject对象解析</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;alex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;18&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMan&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrgJSONTest</span> &#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;user\&quot;:&#123;\&quot;name\&quot;:\&quot;alex\&quot;,\&quot;age\&quot;:\&quot;18\&quot;,\&quot;isMan\&quot;:true&#125;&#125;&quot;</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">JSONObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(json);<span class="hljs-comment">//最外层的JSONObject对象</span><br>                <span class="hljs-type">JSONObject</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> obj.getJSONObject(<span class="hljs-string">&quot;user&quot;</span>);<span class="hljs-comment">//通过user字段获取其所包含的JSONObject对象</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getString(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//通过name字段获取其所包含的字符串</span><br>                System.out.println(name);<br>            &#125; <span class="hljs-keyword">catch</span> (JSONException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p> 打印结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">alex</span><br></code></pre></td></tr></table></figure><h3 id="3-创建一个json数据，将json数据解析并且打印。"><a href="#3-创建一个json数据，将json数据解析并且打印。" class="headerlink" title="3.创建一个json数据，将json数据解析并且打印。"></a>3.创建一个json数据，将json数据解析并且打印。</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;cat&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;it&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;languages&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ide&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Eclipse&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Java&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ide&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;XCode&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Swift&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ide&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Visual Studio&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;C#&quot;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>具体代码：</p><p>activity_main.xml代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;com.oak.d4_json.MainActivity&quot;</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;创建&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/bt_create&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;读取&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/bt_read&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>MainActivity.java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.widget.Button;<br><span class="hljs-keyword">import</span> android.widget.TextView;<br><span class="hljs-keyword">import</span> android.widget.Toast;<br><span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> org.json.JSONArray;<br><span class="hljs-keyword">import</span> org.json.JSONException;<br><span class="hljs-keyword">import</span> org.json.JSONObject;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">private</span> Button bt_create;<span class="hljs-comment">//声明创建按钮组件变量</span><br>    <span class="hljs-keyword">private</span> Button bt_read;<span class="hljs-comment">//声明读取按钮组件变量</span><br>    <span class="hljs-keyword">private</span> File file;<span class="hljs-comment">//声明一个文件对象</span><br>    <span class="hljs-keyword">private</span> TextView tv;<span class="hljs-comment">//声明TextView组件变量</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        bt_create = (Button) findViewById(R.id.bt_create);<span class="hljs-comment">//获取到创建按钮组件</span><br>        bt_read = (Button) findViewById(R.id.bt_read);<span class="hljs-comment">//获取到读取按钮组件</span><br>        tv = (TextView) findViewById(R.id.tv);<span class="hljs-comment">//获取到TextView组件</span><br><br>        file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(getFilesDir(),<span class="hljs-string">&quot;Test.json&quot;</span>);<span class="hljs-comment">//获取到应用在内部的私有文件夹下对应的Test.json文件</span><br>        bt_create.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<span class="hljs-comment">//实例一个JSONObject对象</span><br>                    root.put(<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;it&quot;</span>);<span class="hljs-comment">//对其添加一个数据</span><br><br>                    <span class="hljs-type">JSONArray</span> <span class="hljs-variable">languages</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<span class="hljs-comment">//实例一个JSON数组</span><br>                    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">lan1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<span class="hljs-comment">//实例一个lan1的JSON对象</span><br>                    lan1.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//对lan1对象添加数据</span><br>                    lan1.put(<span class="hljs-string">&quot;ide&quot;</span>,<span class="hljs-string">&quot;Eclipse&quot;</span>);<span class="hljs-comment">//对lan1对象添加数据</span><br>                    lan1.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Java&quot;</span>);<span class="hljs-comment">//对lan1对象添加数据</span><br>                    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">lan2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<span class="hljs-comment">//实例一个lan2的JSON对象</span><br>                    lan2.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//对lan2对象添加数据</span><br>                    lan2.put(<span class="hljs-string">&quot;ide&quot;</span>,<span class="hljs-string">&quot;XCode&quot;</span>);<span class="hljs-comment">//对lan2对象添加数据</span><br>                    lan2.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Swift&quot;</span>);<span class="hljs-comment">//对lan2对象添加数据</span><br>                    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">lan3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<span class="hljs-comment">//实例一个lan3的JSON对象</span><br>                    lan3.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//对lan3对象添加数据</span><br>                    lan3.put(<span class="hljs-string">&quot;ide&quot;</span>,<span class="hljs-string">&quot;Visual Studio&quot;</span>);<span class="hljs-comment">//对lan3对象添加数据</span><br>                    lan3.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;C#&quot;</span>);<span class="hljs-comment">//对lan3对象添加数据</span><br>                    languages.put(<span class="hljs-number">0</span>,lan1);<span class="hljs-comment">//将lan1对象添加到JSON数组中去，角标为0</span><br>                    languages.put(<span class="hljs-number">1</span>,lan2);<span class="hljs-comment">//将lan2对象添加到JSON数组中去，角标为1</span><br>                    languages.put(<span class="hljs-number">2</span>,lan3);<span class="hljs-comment">//将lan3对象添加到JSON数组中去，角标为2</span><br><br>                    root.put(<span class="hljs-string">&quot;languages&quot;</span>,languages);<span class="hljs-comment">//然后将JSON数组添加到名为root的JSON对象中去</span><br><br>                    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<span class="hljs-comment">//创建一个文件输出流</span><br>                    fos.write(root.toString().getBytes());<span class="hljs-comment">//将生成的JSON数据写出</span><br>                    fos.close();<span class="hljs-comment">//关闭输出流</span><br>                    Toast.makeText(getApplicationContext(),<span class="hljs-string">&quot;创建成功！&quot;</span>,Toast.LENGTH_SHORT).show();<br>                &#125; <span class="hljs-keyword">catch</span> (JSONException | IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        bt_read.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<span class="hljs-comment">//获取一个文件输入流</span><br>                    <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis);<span class="hljs-comment">//读取文件内容</span><br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<span class="hljs-comment">//将字符流放入缓存中</span><br>                    String line;<span class="hljs-comment">//定义一个用来临时保存数据的变量</span><br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<span class="hljs-comment">//实例化一个字符串序列化</span><br>                    <span class="hljs-keyword">while</span>((line = bf.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                        sb.append(line);<span class="hljs-comment">//将数据添加到字符串序列化中</span><br>                    &#125;<br>                    <span class="hljs-comment">//关闭流</span><br>                    fis.close();<br>                    isr.close();<br>                    bf.close();<br>                    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(sb.toString());<span class="hljs-comment">//用JSONObject进行解析</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> root.getString(<span class="hljs-string">&quot;cat&quot;</span>);<span class="hljs-comment">//获取字符串类型的键值对</span><br>                    tv.append(<span class="hljs-string">&quot;cat&quot;</span>+<span class="hljs-string">&quot;=&quot;</span>+cat+<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-comment">//显示数据</span><br>                    tv.append(<span class="hljs-string">&quot;---------------&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-comment">//分割线</span><br>                    <span class="hljs-type">JSONArray</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> root.getJSONArray(<span class="hljs-string">&quot;languages&quot;</span>);<span class="hljs-comment">//获取JSON数据中的数组数据</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;array.length(); i++)&#123;<br>                        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> array.getJSONObject(i);<span class="hljs-comment">//遍历得到数组中的各个对象</span><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> object.getInt(<span class="hljs-string">&quot;id&quot;</span>);<span class="hljs-comment">//获取第一个值</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">ide</span> <span class="hljs-operator">=</span> object.getString(<span class="hljs-string">&quot;ide&quot;</span>);<span class="hljs-comment">//获取第二个值</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> object.getString(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//获取第三个值</span><br>                        tv.append(<span class="hljs-string">&quot;id&quot;</span>+<span class="hljs-string">&quot;=&quot;</span>+id+<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-comment">//显示数据</span><br>                        tv.append(<span class="hljs-string">&quot;ide&quot;</span>+<span class="hljs-string">&quot;=&quot;</span>+ide+<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-comment">//显示数据</span><br>                        tv.append(<span class="hljs-string">&quot;name&quot;</span>+<span class="hljs-string">&quot;=&quot;</span>+name+<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-comment">//显示数据</span><br>                        tv.append(<span class="hljs-string">&quot;---------------&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-comment">//分割线</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | JSONException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-GSON"><a href="#2-GSON" class="headerlink" title="2.GSON"></a>2.GSON</h2><p>​使用 Gson 获取 Json 中的数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;stuID&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1111</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;passwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx@123.com&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;authority&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;error&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>创建一个 <code>FullBackResponse.java</code> 文件用于处理数据。<br>大体的思想是，非<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%A5%97&spm=1001.2101.3001.7020">嵌套</a>数据使用 <code>getting</code> 和 <code>setting</code> 方法将值赋值给变量，<br>嵌套的数据通过上述方法赋值给一个 实体类，在实体类里面获取对应的变量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FullBackResponse</span> &#123;<br>    <span class="hljs-keyword">private</span> dataBean data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> error;<br><br><span class="hljs-comment">// Json 内嵌套的实体类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dataBean</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> stuID;<br>        <span class="hljs-keyword">private</span> String passwd;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> String email;<br>        <span class="hljs-keyword">private</span> String authority;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> state;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStuID</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> stuID;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStuID</span><span class="hljs-params">(<span class="hljs-type">int</span> stuID)</span> &#123;<br>            <span class="hljs-built_in">this</span>.stuID = stuID;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPasswd</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> passwd;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPasswd</span><span class="hljs-params">(String passwd)</span> &#123;<br>            <span class="hljs-built_in">this</span>.passwd = passwd;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEmail</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> email;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmail</span><span class="hljs-params">(String email)</span> &#123;<br>            <span class="hljs-built_in">this</span>.email = email;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthority</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> authority;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthority</span><span class="hljs-params">(String authority)</span> &#123;<br>            <span class="hljs-built_in">this</span>.authority = authority;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> state;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span> &#123;<br>            <span class="hljs-built_in">this</span>.state = state;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> dataBean <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(dataBean data)</span> &#123;<br>         <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getError</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> error;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setError</span><span class="hljs-params">(<span class="hljs-type">int</span> error)</span> &#123;<br>        <span class="hljs-built_in">this</span>.error = error;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// res 是 String 类型的 Json 数据</span><br><span class="hljs-type">FullBackResponse</span> <span class="hljs-variable">fullBackResponse</span> <span class="hljs-operator">=</span> gson.fromJson(res, FullBackResponse.class);<br><br><span class="hljs-comment">// 将数据赋值给变量</span><br><span class="hljs-comment">// 这两个是 Json 内嵌套的 实体类 里的数据</span><br><span class="hljs-type">int</span> <span class="hljs-variable">LoginResponse_stuID</span> <span class="hljs-operator">=</span> fullBackResponse.getData().getStuID();<br><span class="hljs-type">String</span> <span class="hljs-variable">LoginResponse_passwd</span> <span class="hljs-operator">=</span> fullBackResponse.getData().getPasswd()；<br><span class="hljs-comment">// 着个不是嵌套的数据</span><br><span class="hljs-type">int</span> <span class="hljs-variable">LoginResponse_error</span> <span class="hljs-operator">=</span> fullBackResponse.getError();<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git生成ssh密钥详细步骤</title>
    <link href="/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90ssh%E5%AF%86%E9%92%A5%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/"/>
    <url>/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90ssh%E5%AF%86%E9%92%A5%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="git生成ssh密钥详细步骤"><a href="#git生成ssh密钥详细步骤" class="headerlink" title="git生成ssh密钥详细步骤"></a>git生成ssh密钥详细步骤</h1><p>Git是一个开源的分布式版本控制系统，可以高效敏捷的处理任何项目，用于帮助管理Linux内核开发。而生成一个ssh是十分必要的，可以使电脑和code服务器之间建立安全的加密连接。</p><p><strong>git生成ssh密钥详细步骤</strong></p><ol><li>首先右键点击电脑桌面，点击选择”Git Bash Here”，打开git命令窗口;</li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240120180050.png"><ol start="2"><li>在git命令窗口配置用户，输入命令：**git config –global user.name “blkj”**。其中“blkj”是你自己要填的用户名;</li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240120180111.png"><ol start="3"><li>接着进行邮箱配置，输入命令：**git config –global user.email “<a href="mailto:&#x62;&#x6c;&#x6b;&#106;&#64;&#98;&#111;&#114;&#x61;&#x6e;&#x65;&#116;&#46;&#99;&#x6f;&#109;&#46;&#x63;&#x6e;">&#x62;&#x6c;&#x6b;&#106;&#64;&#98;&#111;&#114;&#x61;&#x6e;&#x65;&#116;&#46;&#99;&#x6f;&#109;&#46;&#x63;&#x6e;</a>“**。”<a href="mailto:&#98;&#108;&#x6b;&#x6a;&#x40;&#x62;&#111;&#114;&#97;&#110;&#101;&#x74;&#x2e;&#99;&#x6f;&#x6d;&#x2e;&#x63;&#x6e;">&#98;&#108;&#x6b;&#x6a;&#x40;&#x62;&#111;&#114;&#97;&#110;&#101;&#x74;&#x2e;&#99;&#x6f;&#x6d;&#x2e;&#x63;&#x6e;</a>“就是填入你自己的邮箱地址;</li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240120180133.png"><ol start="4"><li>此时在C:\Users\Administrator目录下会生成.gitconfig配置文件，这个文件不能删除;</li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240120180142.png"><p>5 .接着查看.gitconfig配置文件里的内容;</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240120180426.png"><ol start="6"><li>继续在git命令窗口中输入命令：**ssh-keygen -t rsa -C “<a href="mailto:&#x62;&#x6c;&#x6b;&#x6a;&#x40;&#x62;&#x6f;&#114;&#x61;&#110;&#101;&#116;&#x2e;&#x63;&#x6f;&#109;&#x2e;&#99;&#x6e;">&#x62;&#x6c;&#x6b;&#x6a;&#x40;&#x62;&#x6f;&#114;&#x61;&#110;&#101;&#116;&#x2e;&#x63;&#x6f;&#109;&#x2e;&#99;&#x6e;</a>“**，就可以生成SSH公钥和私钥了;</li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240120180152.png"><ol start="7"><li>进入C:\Users\Administrator.ssh目录，查看生成的SSH密钥;</li></ol><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240120180157.png"><p>8 .在git命令窗口中输入命令：<strong>cat ~&#x2F;.ssh&#x2F;id_rsa.pub</strong>，就能查看公钥和私钥了。</p><img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240120180207.png">]]></content>
    
    
    <categories>
      
      <category>工具知识</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
