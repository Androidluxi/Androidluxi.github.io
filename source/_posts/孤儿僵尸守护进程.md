---
title: 孤儿/僵尸/守护进程
index_img: https://s2.loli.net/2024/02/19/6W3goKc7ePnaCwd.png
category:
  - Linux
tags:
  - 进程
abbrlink: aa6
date: 2024-01-21 23:08:12
---

<meta name="referrer" content="no-referrer"/>

# 1.进程

讲到进程，我们要先了解一下另一个概念：`程序`。

程序说白了就是躺在电脑硬盘上的一个文件而已（如同硬盘女神一样），在被 CPU 执行之前，它啥也做不了。

当程序被执行之后，它运行的实例就称为`进程` 。一个程序可以对应多个进程。

进程是系统的工作单元。系统由多个进程组成，其中有的是操作系统进程（执行系统代码），其他的是用户进程（执行用户代码）。所有这些进程都会并发执行，例如通过在单 CPU 上采用多路复用来实现。

你可以使用 <span class="label label-primary">ps</span>命令查看 Linux 系统中的所有进程 。

```css
$ ps -ax
        PID TTY         STAT   TIME COMMAND
        1 ?     Ss      0:01 /usr/lib/systemd/systemd rhgb --switched-root --sys
        2 ?     S       0:00 [kthreadd]
        3 ?     I<      0:00 [rcu_gp]
        4 ?     I<      0:00 [rcu_par_gp]
```

当一个进程调用 `fork` 函数生成另一个进程，原进程就称为父进程，新生成的进程则称为子进程。

Linux 系统中这样父子进程非常多，我们可以使用 `pstree` 命令查看系统上的进程「谱系」。

```scss
$ pstree -psn
systemd(1)─┬─systemd-journal(952)
        ├─systemd-udevd(963)
        ├─systemd-oomd(1137)
        ├─systemd-resolve(1138)
        ├─systemd-userdbd(1139)─┬─systemd-userwor(12707)
        │                     ├─systemd-userwor(12714)
        │                     └─systemd-userwor(12715)
        ├─auditd(1140)───{auditd}(1141)
        ├─dbus-broker-lau(1164)───dbus-broker(1165)
        ├─avahi-daemon(1166)───avahi-daemon(1196)
        ├─bluetoothd(1167)
```

每个进程在系统中都被分配了一个编号。在这所有的进程中，有个非常特殊的进程，它的 ID 号是 1 。它是系统在引导过程中执行的第一个进程，PID 1 之后的每个后续进程都是它的后代。

# 2. 孤儿进程

- 孤儿进程是一个比父进程存活时间更长的进程
- 孤立进程被init所采用
- Init等待被收养的子进程终止
- 采用孤儿进程后，getppid()返回init的PID；通常下**init的PID为1**
- 在使用upstart作为init system的系统上，或者在某些配置中使用systemd的系统上，情况是不同的

父进程如果不等待子进程退出，在子进程之前就结束了自己的“生命”此时的子进程叫做孤儿进程。====**爹没了**
Linux避免系统存在过多的孤儿进程，init进程收留孤儿进程，变成孤儿进程的父进程。====**init养父**

# 3.僵尸进程

{% note success %} 

 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。 

{% endnote %}

**注意：**

​			僵尸进程还会消耗一定的系统资源，并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息。一旦父进程得到想要的信息，僵尸进程就会结束。

## 3.1**僵尸进程怎样产生的：**

一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用 exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。
在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装 SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了， 那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。**但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是 为什么系统中有时会有很多的僵尸进程。**



<img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20240122003624.png"/>

## 3.2 查看僵尸进程

利用命令：**ps**，可以看到有标记为**Z**的进程就是僵尸进程

## 3.3 僵尸进程的危害

内核为每个子进程保留了一个数据结构，包括进程编号、终止状态、使用CPU时间等。父进程如果处理了子进程退出的信息，内核就会释放这个数据结构，父进程如果没有处理子进程退出的信息，内核就不会释放这个数据结构，子进程的进程编号将一直被占用。系统可用的进程编号是有限的，如果产生了大量的僵尸进程，将因为没有可用的进程编号而导致系统不能产生新的进程。

## 3.4 如何杀死僵尸进程

对于普通进程，我们可以通过使用 `kill` 命令来杀死它们。`kill` 命令它还有几个兄弟，比如 `pkill` 和 `killall` ，虽然它们名称里都带 `kill` 这样杀气腾腾的字眼，但它们实际上是被设计为向一个或多个进程发送信号。

在未指定的情况下，这几个命令默认发送的是 `SIGTERM` 信号。

普通进程可以被 `kill` ，但僵尸进程是不行的。为什么？因为僵尸进程本身就已经「死」过一次了！如果还可以再「死」，那「僵尸」这个名号就没多大意义了。

僵尸进程其实已经就是退出的进程，因此无法再利用kill命令杀死僵尸进程。僵尸进程的罪魁祸首是父进程没有回收它的资源，那我们可以想办法它其它进程去回收僵尸进程的资源，这个进程就是 init 进程。

### 3.4.1改写父进程，在子进程死后要为它收尸

具体做法是接管**SIGCHLD**信号。子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子进程收尸。这是基于这样的原理：就算父进程没有调用 wait，内核也会向它发送SIGCHLD消息，尽管对的默认处理是忽略，如果想响应这个消息，可以设置一个处理函数。

### 3.4.2 把父进程杀掉

父进程死后，僵尸进程成为"孤儿进程"，过继给进程init，init始终会负责清理僵尸进程。它产生的所有僵尸进程也跟着消失。**僵尸进程将会导致资源浪费，而孤儿则不会。**

# 4.守护进程

## 4.1 定义

- 守护进程是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或循环等待处理某些事件的发生；它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。
- 守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机才随之一起停止运行；
- 守护进程一般都以root用户权限运行，因为要使用某些特殊的端口（1-1024）或者资源；
- 守护进程的父进程一般都是init进程，因为它真正的父进程在fork出守护进程后就直接退出了，所以守护进程都是孤儿进程，由init接管；
- 守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。
- 守护进程的名称通常以d结尾，比如sshd、xinetd、crond等

## 4.2 创建守护进程的过程：

1. fork()创建子进程，父进程exit()退出

   这是创建守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。

2. 在子进程中调用 setsid() 函数创建新的会话
   在调用了fork()函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来。

3. 再次 fork() 一个孙进程并让子进程退出
   为什么要再次fork呢，假定有这样一种情况，之前的父进程fork出子进程以后还有别的事情要做，在做事情的过程中因为某种原因阻塞了，而此时的子进程因为某些非正常原因要退出的话，就会形成僵尸进程，所以由子进程fork出一个孙进程以后立即退出，孙进程作为守护进程会被init接管，此时无论父进程想做什么都随它了。

4. 在孙进程中调用 chdir() 函数，让根目录 ”/” 成为孙进程的工作目录

   这一步也是必要的步骤，使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“/mnt/usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）。因此，通常的做法是让"/"作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp，改变工作目录的常见函数是chdir。

5. 在孙进程中调用 umask() 函数，设置进程的文件权限掩码为0

   文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的使用方法为umask(0)。

6. 在孙进程中关闭任何不需要的文件描述符
   同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。

   在上面的第2)步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭。

8. 守护进程退出处理
   当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。所以，守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出。