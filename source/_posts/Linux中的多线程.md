---
title: Linux中的线程
date: 2025-04-13 01:19:12
index_img: /img/siteicon/多线程.png
category:
  - Linux
tags:
  - 线程
---

<meta name="referrer" content="no-referrer"/>

## 线程概念

###  什么是线程

- 在一个程序里的一个执行路线就叫做线程。更准确的定义是：线程是“一个进程内部的控制序列”
- 一切进程都至少有一个执行线程
- 线程在进程内部运行，本质是在进程地址空间内运行
- 在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更轻量化
- 透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流

进程的创建伴随着[进程控制块](https://so.csdn.net/so/search?q=进程控制块&spm=1001.2101.3001.7020)，进程地址空间以及页表的创建，虚拟地址和物理地址就是通过页表建立映射的。
但是如果我们在创建“进程”时，只创建**task_struct**，并要求创建出来的**task_struct**和父**task_struct**共享进程地址空间和页表，那么创建的结果就是这样的

<img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/进程空间.png"/>

此时我们创建的实际上就是四个线程：

其中每一个线程都是当前进程里面的一个执行流，也就是我们说的“线程是进程内部的一个执行分支”。
同时我们也可以看出，线程在进程内部运行，本质就是线程在进程地址空间内运行，也就是说曾经这个进程申请的所有资源，几乎都是被所有线程共享的。
注意：单纯从技术角度，这个是一定能实现的，因为它比创建一个原始进程所做的工作更加轻量化了。

<font color="red" size="5">该如何理解之前的进程？</font>

<img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/进程空间2.png"/>

所谓的进程并不是通过**task_struct**来衡量的，除了**task_struct**之外，一个进程还要有进程地址空间，文件，信号等等，合起来称为一个进程。
如果我们站在内核角度来看，承担分配系统资源的基本实体，叫做进程。
换言之，当我们创建进程时是创建一个**task_struct**，创建地址空间，维护页表，然后在物理内存当中开辟空间，构建映射，打开进程默认打开的相关文件，注册信号对应的处理方案等等。
而我们之前接触到的进程都只有一个**task_struct**，也就是该进程内部只有一个执行流，即单执行流进程，反之，内部有多个执行流的进程叫做多执行流进程。
<font color="red" size="5">在Linux中，站在CPU的角度，能否识别当前调度的task_struct是进程还是线程？</font>

<font color="green">不能！也不需要。</font>CPU只关心一个一个的独立执行流。无论进程内部只有一个执行流还是有多个执行流，CPU都是以task_struct为单位进行调度的。

单执行流进程被调度：

<img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/单执行流-进程.png"/>

多执行流进程被调度：

<img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/多执行流进程.png"/>

**Linux并不存在真正的线程，Linux中的线程是用进程模拟的！**

操作系统中存在大量的进程，一个进程内又存在一个或多个线程，因此线程的数量一定比进程的数量多，当线程的数量足够多的时候，很明显线程的执行粒度要比进程更细。

如果一款操作系统要支持线程，那么就需要对这些线程进行管理，比如线程创建，线程调度，线程切换，线程资源分配，线程资源释放及回收等等，这些操作相比于进程都需要另起炉灶，搭建一套比进程平行的线程管理模块。

因此，如果要支持线程一定会提高操作系统设计的复杂程度。但是在Linux看来，描述进程的控制块和描述线程的控制块是很类似的，于是Linux就没有重新为线程设计管理模块，而是直接复用了进程控制块，所以我们可以说Linux中的线程也叫做轻量级进程。

也有真的为线程设计控制块的操作系统，比如Window操作系统，因此Windows操作系统的实现逻辑一定比Linux的实现逻辑要复杂的多。

**既然在Linux中没有真正的线程，那么也就没有真正与线程相关的系统调用！**

Linux中都没有真正意义上的线程了，自然也就没有真正意义上的与线程相关的系统调用了。但是Linux提供了创建轻量级进程的接口，也就是创建进程，共享空间，比如vfork函数。

**vfork可以创建子进程，但是父子共享进程地址空间。**

相对于vfork，可能我们更加熟悉fork函数。

​	**vfork**的返回值与**fork**函数返回值相同，都是给父进程返回子进程PID，给子进程返回0。

​	复制父进程：**fork** 创建的子进程会获得父进程数据段、堆栈段以及代码段的副本。

​	资源共享：虽然文件描述符等资源会在父子进程间共享，但内存空间是独立的。这意味着对内存的任何修改在父进程中不可见，在子进程中则是独立的。

下面我们可以对比一下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int g_val_1 = 100;
int g_val_2 = 100;


int main()
{
    pid_t id1 = fork();
    if (id1 == 0)
    {
        g_val_1 = 200;
        exit(0);
    }
    // 使用vfork创建一个子进程
    // vfork()函数与fork()类似，但创建的子进程只能执行exec或exit函数
    // 子进程不会生成独立的地址空间，会与父进程共享地址空间
    pid_t id2 = vfork();
    if (id2 == 0)
    {
        // 这里的修改会影响到父进程，因为子进程与父进程共享地址空间
        g_val_2 = 300;
        exit(0);
    }
    sleep(3);
    printf("g_val: %d\n", g_val_1);
    printf("g_val: %d\n", g_val_2);
    return 0;
}
```

输出结果：

```sh
g_val: 100
g_val: 300
```

Linux中，在内核角度没有真正意义上与线程有关的接口，但是站在用户角度，系统为用户封装并提供了原生线程库pthread。

`pthread`库其实就是对轻量级进程的系统调用进行了封装，在用户层模拟实现了一套线程相关的接口。

因此对于我们来讲，我们要在Linux下学习线程实际上就是学习用户层的这一套接口，而非操作系统的接口。

### pthread 库

全称为POSIX线程（POSIX Threads），是用于多线程编程的一个标准接口集，旨在提供一种跨不同操作系统平台的可移植方式来编写并发程序。

POSIX（Portable Operating System Interface，可移植操作系统接口）是一个由IEEE制定的标准集合，旨在促进软件在不同Unix系统间的兼容性和可移植性。随着其发展，POSIX标准也被广泛应用于类Unix系统之外的操作系统上，包括许多版本的Linux、macOS，甚至一些实时操作系统和微软Windows上的某些子系统。

**POSIX标准的重要性**

- 提高软件的可移植性：通过遵循POSIX标准，开发人员可以编写能够在多个操作系统上运行的应用程序，只需少量或无需修改代码。

- 促进互操作性：POSIX定义了API和shell及工具的行为，使得不同的操作系统能够以一致的方式进行交互。

- 支持多线程编程：POSIX线程（pthread）提供了一种标准化的多线程编程接口，增强了程序并发处理能力。


POSIX标准涵盖了很多方面，主要包括但不限于：

- 系统接口：定义了操作系统提供的基本服务，如文件I/O、进程控制、信号处理等。
- C库函数：包括标准输入输出、字符串操作、数学计算等基础函数。
- Shell和工具：规定了命令行解释器（Shell）以及一系列常用命令的行为。
- 线程管理：提供了创建、同步、调度线程的机制，即pthread库。
- 网络编程：涵盖了套接字编程接口，允许程序之间通过网络进行通信。

### 线程的优点

- 创建一个新线程的代价比创建一个新进程小得多

- 与进程之间的切换相比，线程之间的切换需要操作系统做的工作更少

- 线程占用的资源比进程少很多

- 能充分利用多处理器的可并行数量

- 在等待慢速IO操作结束的同时，程序可以执行其他的计算任务

- 计算密集型应用，为了能在多处理器上运行，将计算分解到多个线程中实现

- IO密集型应用，为了提高性能，将IO操作重叠，线程可以同时等待不同的IO操作

### 线程的缺点

- 性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与其他线程共享一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能有较大的能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。

- 健壮性降低：编写多线程需要更全面深入的考虑，在一个多线程程序里，因时间分配上的细微差别或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说，线程之间是缺乏保护的。

- 缺乏访问控制：进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。

- 编程难度提高：编写与调试一个多线程程序比单线程程度困难得多。

### 线程异常

- 单个线程如果出现除0，野指针等问题导致线程崩溃，进程也会随着崩溃。
- 线程是进程的执行分支，线程出现异常，就类似进程出现异常，会除法信号机制，终止进程，进程终止之后该进程内所有线程也会随即退出。

### 线程用途

- 合理地使用多线程，能提高CPU密集型程序的执行效率。
- 合理地使用多线程，能提高IO密集型程序的用户体验。

### 二级页表

**以32位平台为例，在32位平台下一共有2^32个地址，也就意味着需要有2^32个地址需要被映射**

如果我们所谓的页表就是单纯的一张表，那么这张表就需要建议2^32个[虚拟地址](https://so.csdn.net/so/search?q=虚拟地址&spm=1001.2101.3001.7020)与物理地址之间的映射关系，即这张表要有2^32个映射项。且每一个表项中除了要有虚拟地址与其映射的物理地址之外，实际上还需要有一些权限信息，比如我们所说的用户级页表和内核级页表，实际就是通过权限进行区分的。

<img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/二级页表.png"/>

每个页表中存储一个物理地址和一个虚拟地址就需要8个字节，考虑到还需要包含权限相关的各种信息，这里每一个表项就按10个字节计算。这里一共有232个表项，也就意味着存储这张页表我们需要用232 * 10个字节，也就是40GB。而在32位平台下我们的内存可能一共就只有4GB，也就是说我们根本无法存储这样一张页表。

**因此所谓的页表就不是单纯的一张表**

还是以32位平台为例，其页表的映射如下：

1. 选择虚拟地址的前10个比特位在页目录下进行查找，找到对应的页表

2. 再选择虚拟地址的10个比特位在对应的页表当中进行查找，找到物理内存中对应页框的起始地址
3. 最后将虚拟地址中剩下的12个比特位作为偏移量从对应页框的起始地址处向后偏移，找到物理内存中某一个对应的字节数据

相关说明：

1. 物理内存实际是被划分成一个个4KB大小的页框的，而磁盘上的程序也是被划分成一个个4KB大小的页帧的，当内存和磁盘进行数据交换时就是以4KB为单位进行加载和保存的。
2. 4KB实际上就是2^12个字节，也就是说一个页框中有2^12个字节，而访问内存的基本大小是1字节，因此一个页框中就有2^12个地址，于是我们就可以将剩下的12个比特位作为偏移量，从页框的起始地址处开始向后进行便宜，从而找到物理内存中某一个对应字节数据。

<img src="https://gitee.com/silent-learner/imgs/raw/master/2025图片/20250413151221177.png"/>

这实际上就是我们所谓的二级页表，其中页目录项是一级页表，页表项是二级页表。

每一个表项还是按10字节计算，页目录和页表的表项都是2^10个，因此一个表的大小就是2^10 * 10个字节，也就是10KB。而页目录有2^10个表项也就意味着页表有2^10个，也就是说一级页表有1张，二级页表有2^10张，总共算下来就是10MB，内存消耗并不高，Linux实际上就是这样映射的。

上面所说的所有映射过程，都是由MMU这个硬件完成的，该硬件是集成在CPU内的。页表是一种软件映射，MMU是一种硬件映射，所以计算机进行虚拟地址到物理地址的转化采用的是软硬件结合的方式。

注意：在Linux中，32位平台下用的是二级页表，64位平台下采用的是多级页表。

<font color="red" >修改常量字符串为什么会触发段错误？</font>

当我们要修改一个字符串常量时，虚拟地址必须经过页表映射找到对应的物理内存，而在查表过程中发现其权限是只读的，此时你要对其进行修改就会在MMU内部触发硬件错误，操作系统在识别到是哪一个进程导致的之后，就会给该进程发送的信号对其进行终止。

### 线程与进程对比

进程是承担分配系统资源的基本实体，线程是调度的基本单位。

线程共享进程数据，但也拥有自己的一部分数据：

- 线程ID
- 一组寄存器
- 栈空间
- errno变量
- 信号屏蔽字
- 调度优先级

同一进程的线程共享一些资源：

因为是在同一个地址空间，因此所谓的代码段（Text Segment），数据段（Data Segment）都是共享的：

- 如果定义一个函数，在各线程中都可以使用
- 如果定义一个全局变量，在各线程中都可以访问到

除此之外，各线程还共享以下进程资源和环境：

- 文件描述符表（进程打开一个文件后，其他进程也能看到）
- 每种信号的处理方式（SIG_IGN，SIG_DFL或者自定义的信号处理函数）
- 当前工作目录
- 用户ID
