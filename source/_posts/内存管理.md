---
title: 内存管理
index_img: /img/siteicon/内存.png
date: 2024-09-11 21:54:51
tags:
  - 操作系统
abbrlink: db19
category:
---

<meta name="referrer" content="no-referrer"/>

# 内存管理

## 1.内存的基础知识

### 1.1存储单元

内存的作用：存放数据。程序执行前需要先放到内存中才能被CFPU处理。

意义：缓和CPU与硬盘之间的速度矛盾。

存储单元：内存中的最小存储单位。可以理解成内存中的一个个的小房间。

内存地址从0开始（逻辑地址），每个地址对应一个存储单元。

计算机分为“字节编码”和“字长编码”

如果是字节编码的计算机，每个存储单元的大小是1B（byte），也就是8个二进制位（bit）

如果是字长位16位的计算机“按字编码”，则每个存储单元大小是1字。也就是16个二进制位（bit）

### 1.2指令运行的基本原理

#### 1.2.1指令的工作原理—操作码+若干参数（可能包含地址参数）

<img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241023222733.png"/>

<img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241023222812.png"/>

<img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241023222827.png"/>可见,我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读/写数据,这个数据应该做什么样的处理。

在这个例子中,我们默认让这个进程的相关内容从地址#0开始连续存放,指令中的地址参数直接给出了变量x的实际存放地址(物理地址)。

程序经过编译、链接后生成的指令中指明的是逻辑地址(相对地址),  即:相对于进程的起始地址而言的地址。

#### 1.1.2逻辑地址（相对地址）vs 物理地址（绝对地址）

物理地址是指在计算机内存中的实际位置，逻辑地址是指相对于进程申请内存的起始地址的位置。

#### 1.1.3从写程序到程序运行—编译、链接、装入

<img src="https://gitee.com/silent-learner/imgs/raw/master/imgs/%202023_Imgs/20241023222842.png"/>

编译:由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译为机器语言

链接:由链接程序将编译后形成的一组目标模块,以及所需需库函数链接在一起,形成一个完整的装入模块

装入(装载):由装入程序将装入模块装入内存运行。   *.exe文件也就是装入模块

#### 1.1.4三种装入方式

1. 绝对装入

   绝对装入:在编译时,如果知道程序将放到内存中的哪个位置,编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址,将程序和数据装入内存。

   **绝对装入只适用于单道程序环境**。程序中使用的绝对地址,可在编译或汇编时给出,也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对时地址。

   缺点：对程序员不透明，而且程序只能在固定电脑运行。

2. 静态重定位

   静态重定位:又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的,指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。。可根据内存的当前情况,将装入模块装入到内存的适当位置。装入时对地址进行**"重定位**",将逻辑地址变变换为物理地址(地址变换是在装入时一次完成的)。

   缺点：静态重定位的特点是在一个作业装入内存时,必须**分配其要求的全部内存空间**,如果没有足够的内存,就不能装入该作业一旦进入内存后,在**运行期间就不能再移动**,也不能**再申请内存空间**。

3. 动态重定位

   动态重定位:又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后,并不会立即把逻辑地址转换为物理地址,而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。

   重定位寄存器:存放装入模块存放的起始位置

## 2.内存管理的概念

## 3.覆盖与交换

## 4.连续分配管理方式
